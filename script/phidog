#!/usr/bin/env ruby

puts("Loading Rails environment...")

require './config/environment'

class Phidog

  include Phidippides

  def process_stubs(path)
    puts("Processing stubs in #{path}")

    datasets_in_path(path).each do |dataset|
      if find_or_create_dataset_metadata(dataset)
        find_or_create_page_metadata(dataset, path)
      end
    end
  end

  private

  def find_or_create_dataset_metadata(data)
    datasetId = data['id']
    domain = data['domain']
    CurrentDomain.set_domain(domain)
    puts("Processing dataset metadata for #{datasetId} which belongs to domain #{domain}")

    result = fetch_dataset_metadata(datasetId)

    if result[:status] == '200'
      puts("Found existing dataset metadata for #{datasetId}")
      success = true

    elsif result[:status] == '404'
      result = create_dataset_metadata(data)
      if result[:status] == '201'
        warning = ''
        if result[:body] != data
          warning = "WARNING: JSON data doesn't match"
        end
        puts("CREATED dataset metadata for #{datasetId} #{warning}")
        jj json_diff(result[:body], data) if warning && ARGV[0] == '-v'
        success = true

      else
        puts("FAILED to create_dataset_metadata for dataset #{datasetId} with error: #{result.inspect}")
        success = false
      end

    else
      puts("ERROR: fetch_dataset_metadata returned an error: #{result.inspect}")
      success = false
    end

    success
  end

  def find_or_create_page_metadata(data, path)
    datasetId = data['id']

    pages_for_dataset_in_path(datasetId, path).each do |page|
      pageId = page['pageId']
      puts("Looking for page #{pageId} for dataset #{datasetId}")
      result = fetch_page_metadata(pageId)

      if result[:status] == '200'

        if result[:body][:pageId] == pageId
          puts("UPDATING page #{pageId} for dataset #{datasetId}")
          result = update_page_metadata(pageId, :data => page)
        else
          puts("ERROR: pageId mismatch (#{result[:body][:pageId]} != #{pageId}. UPDATE SKIPPED.")
        end

      elsif result[:status] == '404'

        puts("CREATING new page since existing page #{pageId} was not found.")
        result = create_page_metadata(page)

        if result[:status] == '201'
          pageId = result[:body][:pageId]
          oldPageId = page['pageId']
          page['pageId'] = pageId
          warning = ''
          if result[:body] != page
            warning = "WARNING: JSON data doesn't match"
          end
          puts("CREATED page metadata #{pageId} (formerly known as #{oldPageId}) #{warning}")
          jj json_diff(result[:body], page) if warning && ARGV[0] == '-v'
        else
          puts("FAILED to create_page_metadata for dataset #{datasetId} with error: #{result.inspect}")
        end

      else
        puts("ERROR: Unhandled exception returned from fetch_page_metadata: #{result.inspect}")
      end
    end
  end

  def pages_for_dataset_in_path(datasetId, path)
    Dir.glob("#{path}/pages/????-????.json").map do |file|
      data = JSON.parse(File.read(file))
      data['datasetId'] == datasetId ? data : nil
    end.compact
  end

  def datasets_in_path(path)
    Dir.glob("#{path}/datasets/????-????.json").map do |file|
      JSON.parse(File.read(file))
    end
  end

  def json_diff(a, b, bi_directional=true)
    return [a.class.name, nil] if !a.nil? && b.nil?
    return [nil, b.class.name] if !b.nil? && a.nil?

    differences = {}
    a.each do |k, v|
      if !v.nil? && b[k].nil?
        differences[k] = [v, nil]
        next
      elsif !b[k].nil? && v.nil?
        differences[k] = [nil, b[k]]
        next
      end

      if v.is_a?(Hash)
        unless b[k].is_a?(Hash)
          differences[k] = "Different types"
          next
        end
        diff = json_diff(a[k], b[k])
        differences[k] = diff if !diff.nil? && diff.count > 0

      elsif v.is_a?(Array)
        unless b[k].is_a?(Array)
          differences[k] = "Different types"
          next
        end

        c = 0
        diff = v.map do |n|
          if n.is_a?(Hash)
            diffs = json_diff(n, b[k][c])
            c += 1
            ["Differences: ", diffs] unless diffs.nil?
          else
            c += 1
            [n , b[c]] unless b[c] == n
          end
        end.compact

        differences[k] = diff if diff.count > 0

      else
        differences[k] = [v, b[k]] unless v == b[k]

      end
    end

    return differences if !differences.nil? && differences.count > 0
  end

end

puts("Using Phidippides endpoint: #{Phidog.new.service_end_point}")

Phidog.new.process_stubs('./public/stubs')
