JIRA_TICKET_REGEX = /[A-z]+\-\d+/ # EN-12345, en-12345

namespace :manifest do
  %w[ staging release ].each do |environment|
    desc "Create a changelog between the last two #{environment} releases"
    task environment.to_sym, [:output_file, :auto] do |_, args|
      tags = `git tag -l frontend-#{environment}/*`.split.sort.reverse.first((ENV['RELEASE_TAGS'] || 10).to_i)

      # Find your tags to compare
      to_tag = ENV['TO_TAG'] || tags[0]
      from_tag = ENV['FROM_TAG'] || tags[1]

      if args.auto.present? && args.auto == 'true'
        puts ">>>>>>>>>>>>>>>>>>>>>>>>>>>>EMAIL BEGIN<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n"
      else
        puts "Default comparison is #{from_tag} .. #{to_tag}"
        puts "Press <Enter> to continue, or 'n' to choose a previous tag"
        answer = STDIN.gets.downcase.chomp
      end

      # Override the default compare if requested
      if answer == 'n'
        puts "Select a recent tag to compare:"
        tags.each_with_index{ |tag, index| puts " #{index + 1}) #{tag}" }
        from_tag_index = STDIN.gets.chomp.to_i
        from_tag = tags[from_tag_index - 1]
      end

      # Generate the manifest info
      manifest_output = ("\n\n= FRONTEND = (from #{from_tag} to #{to_tag})")
      manifest_output << "\n\nGit diff: https://github.com/socrata/frontend/compare/#{from_tag}...#{to_tag}"

      # We put JIRA ticket references in commit subjects.
      # Some place ticket references in each normal commit.
      # Some place ticket references in the merge commit only.
      # We search all commit subjects for ticket references (merge and normal).
      # We allow merge commits without ticket references but
      # warn for all normal commits without ticket references.
      # We also need to ignore changes in storyteller directories.

      # TODO: Remove this list once all intended repositories are merged into platform-ui.
      ignore_list = %w[ 76a15bc5f5f34f9c73199e26df04f06bd48bcb43 ]
      git_log_flags = '--no-color --right-only --cherry-pick --reverse --no-merges'
      git_log_revision_range = "#{from_tag}...#{to_tag}"
      # NOTE: Excluding storyteller via -- . ':(exclude)storyteller' also ends up ignoring empty merge
      # commits (because of the '.' that is required for excludes to work). If you need to get merges,
      # pass --full-history (though note this will end up including non-frontend merges).
      git_log_query = "^#{ignore_list.join(' ^')} -- :/ ':(exclude)storyteller'"
      git_log_cmd = "git log #{git_log_flags} #{git_log_revision_range} #{git_log_query}"

      manifest_output << "\nDiff Command: #{git_log_cmd}`\n"

      git_log_output = `#{git_log_cmd}`

      manifest_output << "\n\nLink to Jira query for current issues...\n"
      manifest_output << jira_query(git_log_output)
      manifest_output << "\n\n----Commits with JIRA tickets:----\n"
      require 'byebug'
      manifest_output << get_commits_with_jira(git_log_output).map do |ticket, commit_messages|
        cleaned_messages = commit_messages.map do |single_message|
          single_message.
            gsub(JIRA_TICKET_REGEX, ''). # Remove common duplication of ticket ID.
            sub(/^[:,]*/, '').
            sub(/^\[\s*\]/, ''). # Nuke empty brackets.
            sub(/^[\s*-:]*/, ''). # Nuke junk people like to use to space out ticket IDs.
            sub(/ \(#\d+\)$/, ''). # Nuke autogenerated PR number (causes dupe lines).
            strip
        end.sort.uniq
        jira_link = jira_web_link(ticket)

        if cleaned_messages.length == 1
          "#{jira_link}: #{cleaned_messages.first}"
        else
          "#{jira_link}:\n\t#{cleaned_messages.join("\n\t")}"
        end
      end.sort.uniq.join("\n")

      commits_without_jira_tickets = get_commits_without_jira(git_log_output).join("\n")
      if commits_without_jira_tickets.present?
        manifest_output << "\n\n----Commits without JIRA tickets:----\n"
        manifest_output << commits_without_jira_tickets
      end

      manifest_output << "\n\n----Git log:----\n" << git_log_output
      puts manifest_output
      puts "\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>EMAIL END<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n" if (args.auto.present? && args.auto == 'true')
      puts

     # Write the manifest to a file
      if args.output_file.present?
        puts "\nWriting manifest file to... #{File.expand_path(args.output_file)}"
        File.open(args.output_file, 'w') do |f|
          f << manifest_output
        end
      else
        puts manifest_output
      end
    end
  end

  desc 'Generates useful information for the current release'
  task :release_info, [:auto, :manifest_file] do |_, args|
    args.with_defaults(:auto => false, :manifest_file => nil)

    manifest_file_path = args[:manifest_file] ?
      File.expand_path(args[:manifest_file]) :
      File.expand_path("manifest_#{Time.now.strftime('%Y%m%d-%H%M%S')}.txt")

    puts
    Rake::Task['manifest:release'].invoke(manifest_file_path, args[:auto])
    puts

    copy_cmd = "cat #{manifest_file_path} | pbcopy"
    puts 'Copying the manifest file contents to your clipboard...'
    puts
    puts "\t#{copy_cmd}"

    system(copy_cmd)
  end
end

def jira_query(git_log_output)
  jira_tickets = get_commits_with_jira(git_log_output).keys
  jira_query = "id in (#{jira_tickets.join(', ')}) "

  URI("https://socrata.atlassian.net/issues/?jql=#{URI.encode(jira_query)}").to_s
end

# This is all we care about for now, no need to pull in heavyweight library
def escape(str)
  str.gsub('/', '%2F')
end

# Return a list of all jira tickets mentioned in a string
def extract_jira_tickets(string)
  string.scan(JIRA_TICKET_REGEX).sort.uniq
end

# Returns a web link to a jira ticket.
def jira_web_link(ticket_id)
  "http://socrata.atlassian.net/browse/#{ticket_id}"
end

# Returns a hash of commits that map JIRA ticket references to arrays commit subjects.
# Example return value:
# {
#   'EN-12345' => [ 'Some commit subject', 'Wait another commit' ],
#   'EN-99999' => [ 'Wow another subject' ]
# }
def get_commits_with_jira(git_log_output)
  if git_log_output.nil?
    []
  else
    commits = {}
    git_log_output.lines.each do |line|
      extract_jira_tickets(line).each do |id|
        (commits[id] ||= []).push(line.sub(/^\s+[*]/, '').strip) # Clean up merge noise.
      end
    end
    commits
  end
end

def get_commits_without_jira(git_log_output)
  commits_without_jira = []
  commits = git_log_output.split(/^commit /)
  commits.each do |commit|
    unless commit.match(JIRA_TICKET_REGEX) || commit == ''
      sha = commit[0..6] || ''
      author = commit.match(/^Author:(.*)</)[1].strip || ''
      first_line_of_commit = commit.match(/^Date:.*$\n\n^(.*)$/)[1].strip || ''
      commits_without_jira.push("#{author} - #{sha} - #{first_line_of_commit}")
    end
  end
  commits_without_jira.sort
end
