(function(root) {

  'use strict';

  var socrata = root.socrata;
  var storyteller = socrata.storyteller;
  var utils = socrata.utils;

  function _saveDraft(storyUid) {
    utils.assertIsOneOfTypes(storyUid, 'string');
    utils.assert(storyteller.storyStore.storyExists(storyUid), 'Cannot save draft of non-existent story');

    var storyJson = JSON.stringify(
      storyteller.storyStore.serializeStory(storyUid)
    );

    // important note here: we need to use the storyteller server's csrf token on the page
    var storytellerCsrfToken = $('meta[name="csrf-token"]').attr('content');

    // Should be updated from the X-Story-Digest header in the last save repsonse
    var storyDigest = storyteller.storyStore.getStoryDigest(storyUid);

    var appToken = storyteller.config.coreServiceAppToken;

    storyteller.dispatcher.dispatch({
      action: Actions.STORY_SAVE_STARTED,
      storyUid: storyUid
    });

    utils.assert(storyDigest && storyDigest.length > 0, 'storyDigest is not present, cannot save.');

    return $.ajax({
      type: 'POST',
      url: '/stories/api/v1/stories/{0}/drafts'.format(storyUid),
      data: storyJson,
      contentType: 'application/json',
      dataType: 'json',
      headers: {
        'X-Socrata-Host': location.host,
        'X-CSRF-Token': storytellerCsrfToken,
        'If-Match': storyDigest,
        'X-App-Token': appToken
      }
    }).
    then(function(data, status, response) {
      // Get the new draft digest from the response X-Story-Digest header.
      var newDigest = response.getResponseHeader('X-Story-Digest');
      if (_.isString(newDigest) && newDigest.length > 0) {
        return newDigest;
      } else {
        return new $.Deferred().reject('X-Story-Digest was not provided in save draft response').promise();
      }
    }).
    done(function(newDigest) {
      storyteller.dispatcher.dispatch({
        action: Actions.STORY_SAVED,
        storyUid: storyUid,
        digest: newDigest
      });
    }).
    fail(function(data) {
      storyteller.dispatcher.dispatch({
        action: Actions.STORY_SAVE_FAILED,
        storyUid: storyUid,
        message: data,
        conflictingUserId: _.get(data, 'responseJSON.conflictingUserId'),
        // A 412 (Precondition Failed) means our If-Match check failed, indicating someone else already
        // saved over the version of the story our user is editing. Aside: it's not 409 (Conflict) because
        // this error is generated by the If-Match, which is a precondition header.
        // Downstream code needs to handle this case specially, so it is called out as a separate field.
        conflict: data.status === 412
      });
    });
  }

  storyteller.StoryDraftCreator = {
    /**
     * Saves a new draft of a story.
     * Emits STORY_SAVE_STARTED, STORY_SAVE_FAILED, and STORY_SAVED as steps are completed.
     *
     * @param {string} storyUid - The UID of the story to save.
     * @return {Promise<string>} A promise for the new story draft's digest.
     */
    saveDraft: _saveDraft
  };

})(window);
