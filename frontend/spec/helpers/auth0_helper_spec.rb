require 'rails_helper'

describe Auth0Helper do
  include TestHelperMethods

  before do
    stub_request(:get, 'https://exists/api/v2/connections?fields=name').
      to_return(:status => 200, :body => '[{"name": "test"}]', :headers => {'Content-Type' => 'application/json'})
  end

  context 'legacy cookies' do

    it 'can be generated by frontend' do
      # Core produces a base64 encoded cookie of the form "uid expiration salt signature"
      cookie_parts = Base64.strict_decode64(gen_cookie('abcd-efgh')).split(' ')
      expect(cookie_parts.length).to eq(4)
      expect(cookie_parts[0]).to eq('abcd-efgh')
      expiration = cookie_parts[1].to_i
      # Expiration is within 30 minutes from now
      expect(Time.now.to_i < expiration).to eq(true)
      expect(expiration < Time.now.to_i + 60 * 30).to eq(true)
    end

  end

  context 'token' do
    let(:federated_user_token) do
      OmniAuth::AuthHash.new(
        'provider' => 'samlp',
        'uid' => 'samlp|magicstring',
        'socrata_user_id' => 'samlp|magicstring|contoso.com',
        'socrata_role' => 'viewer',
        'name' => 'alterego',
        'email' => 'alterego@testshib.org',
        'identities' => [{ 'isSocial' => false }]
      )
    end

    let(:social_user_token) do
      OmniAuth::AuthHash.new(
        'provider' => 'facebook',
        'uid' => 'facebook|magicstring',
        'socrata_user_id' => 'facebook|magicstring|facebook',
        'identities' => [{ 'isSocial' => true }]
      )
    end

    it 'understands federation' do
      expect(valid_token?(federated_user_token)).to eq(true)
    end

    it 'understands social' do
      expect(valid_token?(social_user_token)).to eq(true)
    end

    it 'is rejected when missing a required field' do
      required_fields = %w(email name socrata_user_id)
      required_fields.each do |required_field|
        bad_token = federated_user_token
        bad_token.delete(required_field)
        expect(valid_token?(bad_token)).to be_falsey
      end
    end

    it 'extracts the UID correctly' do
      uid = 'abcd-efgh'
      socrata_user_id = 'auth0|abcd-efgh|socrata.com'
      extracted_uid = extract_uid(socrata_user_id).to_s
      expect(extracted_uid).to eq(uid)
    end

    it 'returns true for username_password_connection? when passed username and password' do
      username_password_id = 'auth0|abcd-efgh|socrata.com'
      expect(username_password_connection?(username_password_id)).to eq(true)
    end

    it 'returns false for username_password_connection? when passed a saml id' do
      saml_id = 'samlp|_c3ac275de528ddea41f237a4142a5704'
      expect(username_password_connection?(saml_id)).to be_falsey
    end

    it 'is rejected when the socrata_user_id is a bad format' do
      authHash = federated_user_token
      authHash['socrata_user_id'] = 'samlp|_somestuff|'
      expect(valid_token?(authHash)).to be_falsey
    end

  end

  context 'generate_authorize_uri' do
    it 'returns the correct URI' do
      expect(generate_authorize_uri('test', '/test/callback')).to eq(
        'https://exists/authorize?scope=openid%20profile&response_type=code&connection=test&callbackURL=/test/callback&sso=true&client_id=exists&redirect_uri=/test/callback'
      )
    end
  end

  context '#transform_connections' do
    it 'identifies connection status' do
      source = [
        {
          'name' => 'Active Connection',
          'options' => {
            'domain_aliases' => [
              'socrata.com'
            ]
          }
        },
        {
          'name' => 'Disabled Connection',
          'options' => {
            'domain_aliases' => [
              'THIS CONNECTION IS DISABLED.'
            ]
          }
        }
      ]
      actual = transform_connections(source)
      expect(actual).to contain_exactly(
        { name: 'Disabled Connection', domain_aliases: ['THIS CONNECTION IS DISABLED.'], status: false },
        { name: 'Active Connection', domain_aliases: ['socrata.com'], status: true }
      )
    end
  end

  context 'auth0 config' do
    it 'gets config values from config' do
      auth0_connections = []
      auth0_connections.push("name"=>"Test", "connection"=>"some-test-connection")

      auth0_forced_connections = []
      auth0_forced_connections.push("match"=>"^.*\\.[cC][tT][rR]@some\\.gov$","connection"=>"some-gov-connection")

      auth0_modal_config = {"text"=>"This is a government system. Don’t do bad things."}

      auth0_message = "Some message"
      auth0_form_message = "Another message"

      config = Hashie::Mash.new(
        auth0_connections: auth0_connections,
        auth0_forced_connections: auth0_forced_connections,
        auth0_modal_config: auth0_modal_config,
        auth0_message: auth0_message,
        auth0_form_message: auth0_form_message
      )

      set_auth0_variables_from_config(config)

      expect(@auth0_connections).to eq(auth0_connections)
      expect(@auth0_forced_connections).to eq(auth0_forced_connections)
      expect(@auth0_modal_config).to eq(auth0_modal_config)
      expect(@auth0_message).to eq(auth0_message)
      expect(@auth0_form_message).to eq(auth0_form_message)
    end

    it 'does nothing with empty config' do
      set_auth0_variables_from_config(nil)

      expect(@auth0_connections).to be_nil
      expect(@auth0_forced_connections).to be_nil
      expect(@auth0_modal_config).to be_nil
      expect(@auth0_message).to be_nil
      expect(@auth0_form_message).to be_nil
    end

    it 'properly validates auth0_connections' do
      # valid
      auth0_connections = []
      auth0_connections.push(:name => "Test", :connection => "some-test-connection")
      expect(valid_auth0_connections?(auth0_connections)).to be true

      # must be an array
      auth0_connections = {:name => "Test", :connection =>"some-test-connection"}
      expect(valid_auth0_connections?(auth0_connections)).to be false

      # must have name
      auth0_connections = []
      auth0_connections.push(:connection => "some-test-connection")
      expect(valid_auth0_connections?(auth0_connections)).to be false

      # must have connection
      auth0_connections = []
      auth0_connections.push(:name =>"Test")
      expect(valid_auth0_connections?(auth0_connections)).to be false
    end

    it 'properly validates auth0_forced_connections' do
      # valid
      auth0_forced_connections = []
      auth0_forced_connections.push(:match => "^.*\\.[cC][tT][rR]@some\\.gov$", :connection => "some-gov-connection")
      expect(valid_auth0_forced_connections?(auth0_forced_connections)).to be true

      # must be an array
      auth0_forced_connections = {:match => "^.*\\.[cC][tT][rR]@some\\.gov$", :connection => "some-gov-connection"}
      expect(valid_auth0_forced_connections?(auth0_forced_connections)).to be false

      # must have match
      auth0_forced_connections = []
      auth0_forced_connections.push(:connection => "some-gov-connection")
      expect(valid_auth0_forced_connections?(auth0_forced_connections)).to be false

      # must have connection
      auth0_forced_connections = []
      auth0_forced_connections.push(:match => "^.*\\.[cC][tT][rR]@some\\.gov$")
      expect(valid_auth0_forced_connections?(auth0_forced_connections)).to be false
    end

    it 'properly validates auth0_modal_config' do
      # valid
      auth0_modal_config = {:text => "This is a government system. Don’t do bad things."}
      expect(valid_auth0_modal_config?(auth0_modal_config)).to be true

      # must have text
      auth0_modal_config = {}
      expect(valid_auth0_modal_config?(auth0_modal_config)).to be false
    end
  end

end
