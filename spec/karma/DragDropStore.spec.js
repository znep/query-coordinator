describe('DragDropStore', function() {
  'use strict';

  beforeEach(standardMocks);
  afterEach(standardMocks.unmock);

  var draggedBlockId = 'draggedBlockId';

  function dragOver(storyUid, draggedBlockId) {
    window.dispatcher.dispatch({
      action: Constants.STORY_DRAG_OVER,
      storyUid: storyUid,
      pointer: {},
      storyElement: {},
      draggedBlockId: draggedBlockId
    });
  }

  function dragLeave(storyUid) {
    window.dispatcher.dispatch({
      action: Constants.STORY_DRAG_LEAVE,
      storyUid: storyUid
    });
  }

  function dragDrop(storyUid, blockId) {
    window.dispatcher.dispatch({
      action: Constants.STORY_DROP,
      storyUid: storyUid,
      blockId: blockId
    });
  }


  describe('given STORY_DRAG_OVER action', function() {
    describe('with a valid storyUid and blockId', function() {
      it('should update its hint position', function(done) {
        window.dragDropStore.addChangeListener(function() {
          var hint = window.dragDropStore.getReorderHintPosition();
          assert.equal(hint.storyUid, standardMocks.validStoryUid);
          assert.equal(hint.dropIndex, 2);
          done();
        });

        dragOver(standardMocks.validStoryUid, draggedBlockId);
      });

      describe('but then an over a story that already has the dragged block', function() {
        it('should clear its hint position', function(done) {
          dragOver(standardMocks.validStoryUid, draggedBlockId);

          window.dragDropStore.addChangeListener(function() {
            var hint = window.dragDropStore.getReorderHintPosition();
            assert.isNull(hint);
            done();
          });

          dragOver(standardMocks.validStoryUid, standardMocks.validBlockId);
        });
      });

      describe('but then an invalid storyId', function() {
        it('should clear its hint position', function(done) {
          dragOver(standardMocks.validStoryUid, draggedBlockId);

          window.dragDropStore.addChangeListener(function() {
            var hint = window.dragDropStore.getReorderHintPosition();
            assert.isNull(hint);
            done();
          });

          dragOver(standardMocks.invalidStoryUid, standardMocks.invalidBlockId);
        });
      });

      describe('but then a STORY_DRAG_LEAVE event', function() {
        describe('over some other story', function() {
          it('should preserve the existing hint', function() {
            dragOver(standardMocks.validStoryUid, draggedBlockId);
            var originalHint = window.dragDropStore.getReorderHintPosition();
            assert.isNotNull(originalHint);

            window.dragDropStore.addChangeListener(function() {
              throw new Error('expected no change');
            });

            dragLeave(standardMocks.invalidStoryUid);

            var hint = window.dragDropStore.getReorderHintPosition();
            assert.equal(hint, originalHint);

          });
        });
        describe('over the dragged story', function() {
          it('should clear the hint', function(done) {
            dragOver(standardMocks.validStoryUid, draggedBlockId);
            var originalHint = window.dragDropStore.getReorderHintPosition();
            assert.isNotNull(originalHint);

            window.dragDropStore.addChangeListener(function() {
              var hint = window.dragDropStore.getReorderHintPosition();
              assert.isNull(hint);
              done();
            });

            dragLeave(standardMocks.validStoryUid);
          });
        });
      });
    });
  });

  describe('given STORY_DROP action', function() {
    describe('while dragging over the story', function() {
      it('should invoke a correct BLOCK_COPY_INTO_STORY', function(done) {
        dragOver(standardMocks.validStoryUid, draggedBlockId);

        dispatcher.register(function(payload) {
          if(payload.action === Constants.BLOCK_COPY_INTO_STORY) {
            assert.propertyVal(payload, 'blockId', standardMocks.validBlockId);
            assert.propertyVal(payload, 'storyUid', standardMocks.validStoryUid);
            assert.propertyVal(payload, 'insertAt', 2);
            done();
          }
        });

        dragDrop(standardMocks.validStoryUid, standardMocks.validBlockId);

      });
    });

    describe('that refers to some other story', function() {
      it('should invoke no further action', function() {
        dragOver(standardMocks.validStoryUid, standardMocks.firstBlockId);

        var spy = sinon.spy();
        dispatcher.register(spy);
        dragDrop(standardMocks.invalidStoryUid, standardMocks.invalidBlockId);
        assert(spy.calledOnce); // Once for the STORY_DROP generated by dragDrop in the test.
      });
    });

    describe('while not dragging', function() {
      it('should invoke no further action', function() {
        var spy = sinon.spy();
        dispatcher.register(spy);
        dragDrop(standardMocks.validStoryUid, standardMocks.validBlockId);
        assert(spy.calledOnce); // Once for the STORY_DROP generated by dragDrop in the test.
      });
    });

  });

  describe('isDraggingOverStory', function() {
    describe('while not dragging', function() {
      it('should return false', function() {
        assert.isFalse(window.dragDropStore.isDraggingOverStory(standardMocks.validStoryUid));
      });
    });

    describe('while dragging', function() {
      beforeEach(function() {
        dragOver(standardMocks.validStoryUid, draggedBlockId);
      });
      describe('over the story in the argument', function() {
        it('should return true', function() {
          assert.isTrue(window.dragDropStore.isDraggingOverStory(standardMocks.validStoryUid));
        });
      });
      describe('over a story other than the one in the argument', function() {
        it('should return false', function() {
          assert.isFalse(window.dragDropStore.isDraggingOverStory(standardMocks.invalidStoryUid));
        });
      });
    });

  });

});
