<button class="btn btn-default modal-trigger" data-full-screen="false">Trigger normal modal</button>
<button class="btn btn-default modal-trigger" data-full-screen="true">Trigger fullscreen modal</button>
<div id="modal-target"></div>

<script type="text/babel" data-presets="es2015,react">
  $(() => {
    const targetNode = document.getElementById('modal-target');

    const onDismiss = () => {
      const doDismiss = window.confirm('Are you sure you want to close this modal?');
      if (doDismiss) {
        // If you are unmounting a subtree, you won't have to do this, but
        // because unmounting the root node is slightly different, the current
        // wisdom is to wait for the stack to clear.
        //
        // See https://github.com/facebook/react/issues/3298#issuecomment-213225142
        _.defer(() => ReactDOM.unmountComponentAtNode(targetNode));
      }
    };

    $('.modal-trigger').click((event) => {
      const fullScreen = $(event.target).data('full-screen');

      const modalProps = {
        fullScreen,
        onDismiss
      };

      const headerProps = {
        title: 'Example Modal',
        onDismiss
      };

      ReactDOM.render(
        <styleguide.Modal {...modalProps} >
          <styleguide.ModalHeader {...headerProps} />

          <styleguide.ModalContent>
            <p>
              The same <code>onDismiss</code> handler is used for the close icon
              in the upper right corner, the Esc key, the Close button in the
              footer, and clicking on the modal overlay.
            </p>
          </styleguide.ModalContent>

          <styleguide.ModalFooter>
            <div>
              <button className="btn btn-default">Do Nothing</button>
              &nbsp;
              <button className="btn btn-primary" onClick={onDismiss}>Close</button>
            </div>
          </styleguide.ModalFooter>
        </styleguide.Modal>,
        targetNode
      );
    });
  });
</script>
