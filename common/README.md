# Socrata Platform Common Code

*IMPORTANT: Currently, frontend does not import common code directly. It pulls it in from the package
generated by packages/socrata-utils. This is a temporary situation while we finish the monorepo work.*

## Quick Links

* [JS Utils](https://github.com/socrata/platform-ui/blob/master/common/js_utils/README.md)
* [Analytics](https://github.com/socrata/platform-ui/blob/master/common/analytics/README.md)
* [Feature Flags](https://github.com/socrata/platform-ui/blob/master/common/feature_flags/README.md)
* [Karma tests](https://github.com/socrata/platform-ui/blob/master/common/karma_config/README.md)
* [socrata-utils legacy package](https://github.com/socrata/platform-ui/blob/master/packages/socrata-utils/README.md)

## Terminology

* Module: Unit of shared code in the `common` directory. Must live in its own subdirectory of `common`.

## Organization

The `common` directory contains code modules that are shared between at least two services in this repo.
Each directory within `common` defines a reusable code module in either Ruby, JavaScript, CSS, or HTML.

## File Structure

All files and folder in the `common` project must be underscorized (example: `common/feature_flags/flag_helpers.js`).
This is the least-surprising compromise between our rails-centric ruby codebase and our javascript codebase.

Important: A module's file structure is part of its public API! Keep this in mind when you are deciding your
module's structure.  It is highly recommended to define a single entry point for your module. That way, any
file renames or moves within the module do not affect consumers. It is also easier to provide fallbacks,
shims, or other iteration aids in this regime.

Prefer this:
```javascript
import { ColumnChart } from 'common/visualizations';
```
over this:
```javascript
import { ColumnChart } from 'common/visualizations/charts/column_chart';
```

You can see an example of this pattern [here](https://github.com/socrata/frontend-visualizations/blob/master/src/index.js).

## Module Requirements

*Note: This section will evolve as these structures are relatively young.*
*Note: Be responsible when changing these requirements. If your proposed change involves
making existing modules non-compliant, seriously consider your obligation to update
those existing modules.*

All modules, regardless of technology used, must satisfy these conditions:

0. Have a clear reason for being shared.
1. Have a clear underscorized name. For instance, `feature_flags`.
2. Define their implementation in `common/${MODULE_NAME}`.
3. Have a README.md in their folder.
4. Run a suite of tests when the `test` task is invoked from the shared Rakefile (`common/Rakefile`).
5. Run a linter when the `lint` task is invoked from the shared Rakefile (`common/Rakefile`).

## Contributing

When contributing a new module or modifying an existing one, please ensure your pull request
achieves the following:

1. Global checks pass (`rake test && rake lint` from the root of the repo).
2. Passes a design review with a senior-level or above engineer, if the change:
  1. Adds or removes a module.
  2. Adds, changes, or removes module API.
  3. Imports a new external library.
3. All usages of modified modules are updated to reflect the change, if applicable.
4. A demo is given of the changes in all relevant projects.

It is suggested that you consider these requirements _before_ you begin changing code. A series of small,
incremental changes is often preferable and faster to implement than a large, monolithic change that must
be merged all at once.
