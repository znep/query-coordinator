import _ from 'lodash';
import { assert } from 'chai';
import sinon from 'sinon';

import Actions from 'editor/Actions';
import Dispatcher from 'editor/Dispatcher';
import Store, {__RewireAPI__ as StoreAPI} from 'editor/stores/Store';
import DropHintStore, {__RewireAPI__ as DropHintStoreAPI} from 'editor/stores/DropHintStore';

describe('DropHintStore', function() {

  var dispatcher;
  var dropHintStore;
  var doesStoryExist;
  var validStoryUid = 'test-test';
  var invalidStoryUid = 'invalid-story';
  var invalidBlockId = 'invalid-block';
  var testBlockContent = 'testBlockContent';

  function dragOver(storyUid, blockContent) {
    dispatcher.dispatch({
      action: Actions.STORY_DRAG_OVER,
      storyUid: storyUid,
      pointer: {},
      storyElement: {},
      blockContent: blockContent
    });
  }

  function dragLeave(storyUid) {
    dispatcher.dispatch({
      action: Actions.STORY_DRAG_LEAVE,
      storyUid: storyUid
    });
  }

  function dragDrop(storyUid) {
    dispatcher.dispatch({
      action: Actions.STORY_DROP,
      storyUid: storyUid
    });
  }

  beforeEach(function() {
    doesStoryExist = true;
    dispatcher = new Dispatcher();

    StoreAPI.__Rewire__('dispatcher', dispatcher);

    var StoryStoreMock = function() {
      _.extend(this, new Store());
      this.doesStoryExist = function() {
        return doesStoryExist;
      };
    };

    DropHintStoreAPI.__Rewire__('dispatcher', dispatcher);
    DropHintStoreAPI.__Rewire__('storyStore', new StoryStoreMock());

    dropHintStore = new DropHintStore();
  });

  describe('given STORY_DRAG_OVER action', function() {
    describe('with a valid storyUid and blockId', function() {
      it('should update its hint position', function(done) {
        dropHintStore.addChangeListener(function() {
          var hint = dropHintStore.getDropHintPosition();
          assert.equal(hint.storyUid, validStoryUid);
          assert.equal(hint.dropIndex, 0);
          done();
        });

        dragOver(validStoryUid, testBlockContent);
      });

      describe('but then an invalid storyId', function() {
        it('should clear its hint position', function(done) {
          dragOver(validStoryUid, testBlockContent);

          dropHintStore.addChangeListener(function() {
            var hint = dropHintStore.getDropHintPosition();
            assert.isNull(hint);
            done();
          });

          doesStoryExist = false;
          dragOver(invalidStoryUid, invalidBlockId);
        });
      });

      describe('but then a STORY_DRAG_LEAVE event', function() {
        describe('over some other story', function() {
          it('should preserve the existing hint', function() {
            dragOver(validStoryUid, testBlockContent);
            var originalHint = dropHintStore.getDropHintPosition();
            assert.isNotNull(originalHint);

            dropHintStore.addChangeListener(function() {
              throw new Error('expected no change');
            });

            dragLeave(invalidStoryUid);

            var hint = dropHintStore.getDropHintPosition();
            assert.equal(hint, originalHint);

          });
        });
        describe('over the dragged story', function() {
          it('should clear the hint', function(done) {
            dragOver(validStoryUid, testBlockContent);
            var originalHint = dropHintStore.getDropHintPosition();
            assert.isNotNull(originalHint);

            dropHintStore.addChangeListener(function() {
              var hint = dropHintStore.getDropHintPosition();
              assert.isNull(hint);
              done();
            });

            dragLeave(validStoryUid);
          });
        });
      });
    });
  });

  describe('given STORY_DROP action', function() {
    describe('while dragging over the story', function() {
      it('should clear the reorder hint position', function(done) {
        dragOver(validStoryUid, testBlockContent);
        assert.deepEqual(
          dropHintStore.getDropHintPosition(validStoryUid),
          {
            storyUid: validStoryUid,
            dropIndex: 0
          }
        );

        dropHintStore.register(function() {
          assert.isNull(
            dropHintStore.getDropHintPosition(validStoryUid)
          );
          done();
        });
        dragDrop(validStoryUid);

      });
    });

    describe('while not dragging', function() {
      it('should invoke no further action', function() {
        var spy = sinon.spy();
        dispatcher.register(spy);
        dragDrop(validStoryUid);
        assert(spy.calledOnce); // Once for the STORY_DROP generated by dragDrop in the test.
      });
    });
  });

  describe('isDraggingOverStory', function() {
    describe('while not dragging', function() {
      it('should return false', function() {
        assert.isFalse(dropHintStore.isDraggingOverStory(validStoryUid));
      });
    });

    describe('while dragging', function() {
      beforeEach(function() {
        dragOver(validStoryUid, testBlockContent);
      });
      describe('over the story in the argument', function() {
        it('should return true', function() {
          assert.isTrue(dropHintStore.isDraggingOverStory(validStoryUid));
        });
      });
      describe('over a story other than the one in the argument', function() {
        it('should return false', function() {
          assert.isFalse(dropHintStore.isDraggingOverStory(invalidStoryUid));
        });
      });
    });
  });
});
