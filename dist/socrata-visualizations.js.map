{"version":3,"file":"socrata-visualizations.js","sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 6566155d22cdda42ffe2","webpack:///./src/index.js","webpack:///./src/views/index.js","webpack:///./src/views/ChoroplethMap.js","webpack:///./bower_components/simple-statistics/src/simple_statistics.js","webpack:///./bower_components/chroma-js/chroma.js","webpack:///(webpack)/buildin/module.js","webpack:///./src/views/Visualization.js","webpack:///./src/views/ChoroplethMapUtils.js","webpack:///./src/views/ColumnChart.js","webpack:///./src/views/Pager.js","webpack:///./src/views/TimelineChart.js","webpack:///./src/views/Table.js","webpack:///./src/views/DataTypeFormatter.js","webpack:///./src/views/FeatureMap.js","webpack:///./~/leaflet/dist/leaflet-src.js","webpack:///./src/views/FlyoutRenderer.js","webpack:///./src/views/RowInspector.js","webpack:///./src/dataProviders/index.js","webpack:///./src/dataProviders/GeospaceDataProvider.js","webpack:///./src/dataProviders/DataProvider.js","webpack:///./src/dataProviders/MetadataProvider.js","webpack:///./src/dataProviders/SoqlDataProvider.js","webpack:///./src/dataProviders/TileserverDataProvider.js","webpack:///./src/dataProviders/VectorTileManager.js","webpack:///./~/vector-tile/index.js","webpack:///./~/vector-tile/lib/vectortile.js","webpack:///./~/vector-tile/lib/vectortilelayer.js","webpack:///./~/vector-tile/lib/vectortilefeature.js","webpack:///./~/point-geometry/index.js","webpack:///./~/pbf/index.js","webpack:///./~/pbf/buffer.js","webpack:///./~/buffer/index.js","webpack:///./~/base64-js/lib/b64.js","webpack:///./~/ieee754/index.js","webpack:///./~/buffer/~/isarray/index.js","webpack:///./src/ChoroplethMap.js","webpack:///./src/dataProviders/SoqlHelpers.js","webpack:///./src/ColumnChart.js","webpack:///./src/FeatureMap.js","webpack:///./src/Table.js","webpack:///./src/TimelineChart.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"socrata.utils\"), require(\"d3\"), require(\"jQuery\"), require(\"_\"), require(\"moment\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"socrata.utils\", \"d3\", \"jQuery\", \"_\", \"moment\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"visualizations\"] = factory(require(\"socrata.utils\"), require(\"d3\"), require(\"jQuery\"), require(\"_\"), require(\"moment\"));\n\telse\n\t\troot[\"socrata\"] = root[\"socrata\"] || {}, root[\"socrata\"][\"visualizations\"] = factory(root[\"socrata\"][\"utils\"], root[\"d3\"], root[\"jQuery\"], root[\"_\"], root[\"moment\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_4__, __WEBPACK_EXTERNAL_MODULE_8__, __WEBPACK_EXTERNAL_MODULE_9__, __WEBPACK_EXTERNAL_MODULE_17__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 6566155d22cdda42ffe2\n **/","'use strict';\n\nvar views = require('./views');\nvar dataProviders = require('./dataProviders');\n// vv these requires have the side effect of registering jQuery plugins vv\nvar ChoroplethMap = require('./ChoroplethMap');\nvar ColumnChart = require('./ColumnChart');\nvar FeatureMap = require('./FeatureMap');\nvar Table = require('./Table');\nvar TimelineChart = require('./TimelineChart');\n\n// TODO: add exported function here called `init` which takes a VIF and instantiates the\n// appropriate visualization based on the VIF's `type` field\n\nmodule.exports = {\n  views: views,\n  dataProviders: dataProviders,\n  ChoroplethMap: ChoroplethMap,\n  ColumnChart: ColumnChart,\n  FeatureMap: FeatureMap,\n  Table: Table,\n  TimelineChart: TimelineChart\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/index.js\n ** module id = 0\n ** module chunks = 0\n **/","'use strict';\n\nvar ChoroplethMap = require('./ChoroplethMap');\nvar ChoroplethMapUtils = require('./ChoroplethMapUtils');\nvar ColumnChart = require('./ColumnChart');\nvar Pager = require('./Pager');\nvar TimelineChart = require('./TimelineChart');\nvar Table = require('./Table');\nvar FeatureMap = require('./FeatureMap');\nvar FlyoutRenderer = require('./FlyoutRenderer');\nvar RowInspector = require('./RowInspector');\n\nmodule.exports = {\n  ChoroplethMap: ChoroplethMap,\n  ChoroplethMapUtils: ChoroplethMapUtils,\n  ColumnChart: ColumnChart,\n  Pager: Pager,\n  Table: Table,\n  TimelineChart: TimelineChart,\n  FeatureMap: FeatureMap,\n  FlyoutRenderer: FlyoutRenderer,\n  RowInspector: RowInspector\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/views/index.js\n ** module id = 1\n ** module chunks = 0\n **/","'use strict';\n\n/**\n * TODO:\n * - Lowercase \"constants\" that are really configurations\n * - Pass in either savedExtent or defaultExtent, rather than both\n */\n\nvar utils = require('socrata-utils');\nvar d3 = require('d3');\nvar ss = require('simple-statistics');\nvar chroma = require('chroma-js');\nvar $ = require('jquery');\nvar _ = require('lodash');\n\nvar Visualization = require('./Visualization');\nvar ChoroplethMapUtils = require('./ChoroplethMapUtils');\n\nfunction ChoroplethMap(element, vif) {\n\n  _.extend(this, new Visualization(element, vif));\n\n  var self = this;\n  // Data mapping to geojson\n  var LABEL_GEOJSON_PROPERTY_NAME = vif.configuration.shapefile.columns.name;\n  var UNFILTERED_GEOJSON_PROPERTY_NAME = vif.configuration.shapefile.columns.unfiltered;\n  var FILTERED_GEOJSON_PROPERTY_NAME = vif.configuration.shapefile.columns.filtered;\n  var SELECTED_GEOJSON_PROPERTY_NAME = vif.configuration.shapefile.columns.selected;\n  // Map configuration\n  var MAP_MIN_ZOOM = vif.configuration.mapMinZoom || 1;\n  var MAP_MAX_ZOOM = vif.configuration.mapMaxZoom || 18;\n  var MAP_ENABLE_ZOOM_ANIMATION = vif.configuration.mapZoomAnimation || false;\n  var MAP_SINGLE_CLICK_SUPPRESSION_THRESHOLD_MILLISECONDS = 200;\n  var MAP_DOUBLE_CLICK_THRESHOLD_MILLISECONDS = 400;\n  // Choropleth class derivation\n  var MAXIMUM_NUMBER_OF_CLASS_BREAKS_ALLOWED = vif.configuration.maxJenksClassBreaks || 7;\n  // Choropleth region rendering\n  var CHOROPLETH_REGION_DEFAULT_STROKE_WIDTH = vif.configuration.defaultFeatureStrokeWidth || 1;\n  var CHOROPLETH_REGION_HIGHLIGHTED_STROKE_WIDTH = vif.configuration.highlightedFeatureStrokeWidth || 4;\n  // Legend rendering\n  var CONTINUOUS_LEGEND_ZERO_COLOR = '#ffffff';\n  var CONTINUOUS_LEGEND_POSITIVE_COLOR = '#003747';\n  var CONTINUOUS_LEGEND_NEGATIVE_COLOR = '#c6663d';\n  var DISCRETE_LEGEND_ZERO_COLOR = '#eeeeee';\n  var DISCRETE_LEGEND_POSITIVE_COLOR = '#408499';\n  var DISCRETE_LEGEND_NEGATIVE_COLOR = '#c6663d';\n\n  var _utilConstants = {\n    UNFILTERED_GEOJSON_PROPERTY_NAME: UNFILTERED_GEOJSON_PROPERTY_NAME,\n    FILTERED_GEOJSON_PROPERTY_NAME: FILTERED_GEOJSON_PROPERTY_NAME,\n    SELECTED_GEOJSON_PROPERTY_NAME: SELECTED_GEOJSON_PROPERTY_NAME,\n    MAXIMUM_NUMBER_OF_CLASS_BREAKS_ALLOWED: MAXIMUM_NUMBER_OF_CLASS_BREAKS_ALLOWED\n  };\n\n  var _visualizationUtils = new ChoroplethMapUtils(_utilConstants);\n\n  var _choroplethContainer;\n  var _choroplethMapContainer;\n  var _choroplethLegend;\n  // These configuration options belong to Leaflet, not the visualization we are\n  // building on top of it.\n  var _mapOptions = _.extend(\n    {\n      attributionControl: false,\n      center: [47.609895, -122.330259], // Center on Seattle by default.\n      keyboard: false,\n      scrollWheelZoom: false,\n      zoom: 1,\n      zoomControlPosition: 'topleft',\n      minZoom: MAP_MIN_ZOOM,\n      maxZoom: MAP_MAX_ZOOM,\n      zoomAnimation: MAP_ENABLE_ZOOM_ANIMATION\n    },\n    vif.configuration.mapOptions\n  );\n\n  var _lastElementWidth;\n  var _lastElementHeight;\n\n  var _map;\n  var _baseTileLayer;\n  var _minLng;\n  var _maxLng;\n  var _minLat;\n  var _maxLat;\n  var _boundsArray;\n  var _coordinates;\n\n  // Keep track of the geojson layers so that we can remove them cleanly.\n  // Every redraw of the map forces us to remove the layer entirely because\n  // there is no way to mutate already-rendered geojson objects.\n  var _geojsonBaseLayer = null;\n\n  // Watch for first render so we know whether or not to update the center/bounds.\n  // (We don't update the center or the bounds if the choropleth has already been\n  // rendered so that we can retain potential panning and zooming done by the user.\n  var _firstRender = true;\n\n  var _lastRenderOptions = {};\n  var _lastRenderedVif;\n\n  var _interactive = vif.configuration.interactive === true;\n\n  // Keep track of click details so that we can zoom on double-click but\n  // still selects on single clicks.\n  var _lastClick = 0;\n  var _lastClickTimeout = null;\n\n  // Render layout\n  _renderTemplate(self.element);\n\n  // Construct leaflet map\n  _map = L.map(_choroplethMapContainer[0], _mapOptions);\n\n  // Attach Miscellaneous Events\n  _attachEvents();\n\n  // Initialize map's bounds if provided with that data\n  var _extentsDefined = (!_.isEmpty(vif.configuration.defaultExtent) || !_.isEmpty(vif.configuration.savedExtent));\n\n  // If bounds are not defined, this will get handled when render is first\n  // called, as the fallback bounds calculation requires the geoJSON data.\n  if (_firstRender && _extentsDefined) {\n    _initializeMap(_choroplethContainer);\n  }\n\n  // Setup legend\n  var _LegendType = _LegendContinuous;\n\n  if (vif.configuration.hasOwnProperty('legend')) {\n\n    if (vif.configuration.legend.hasOwnProperty('negativeColor')) {\n      CONTINUOUS_LEGEND_NEGATIVE_COLOR = vif.configuration.legend.negativeColor;\n    }\n\n    if (vif.configuration.legend.hasOwnProperty('zeroColor')) {\n      CONTINUOUS_LEGEND_ZERO_COLOR = vif.configuration.legend.negativeColor;\n    }\n\n    if (vif.configuration.legend.hasOwnProperty('positiveColor')) {\n      CONTINUOUS_LEGEND_POSITIVE_COLOR = vif.configuration.legend.negativeColor;\n    }\n\n    if (vif.configuration.legend.hasOwnProperty('type') && vif.configuration.legend.type === 'discrete') {\n      _LegendType = _LegendDiscrete;\n\n      if (vif.configuration.legend.hasOwnProperty('negativeColor')) {\n        DISCRETE_LEGEND_NEGATIVE_COLOR = vif.configuration.legend.negativeColor;\n      }\n\n      if (vif.configuration.legend.hasOwnProperty('zeroColor')) {\n        DISCRETE_LEGEND_ZERO_COLOR = vif.configuration.legend.negativeColor;\n      }\n\n      if (vif.configuration.legend.hasOwnProperty('positiveColor')) {\n        DISCRETE_LEGEND_POSITIVE_COLOR = vif.configuration.legend.negativeColor;\n      }\n    }\n  }\n\n  var _legend = new _LegendType(self.element.find('.choropleth-legend'), self.element);\n\n  /**\n   * Public methods\n   */\n\n  this.render = function(data, options) {\n    // Stop rendering if element has no width or height\n    if (_choroplethContainer.width() <= 0 || _choroplethContainer.height() <= 0) {\n      if (window.console && window.console.warn) {\n        console.warn('Aborted rendering choropleth map: map width or height is zero.');\n      }\n      return;\n    }\n\n    // Why are we merging the options here but replacing them in other\n    // visualization implementations?\n    _.merge(_lastRenderOptions, options);\n    // Eventually we may only want to pass in the VIF instead of other render\n    // options as well as the VIF, but for the time being we will just treat it\n    // as another property on `options`.\n    _lastRenderedVif = options.vif;\n\n    // Calling _initializeMap should only occur here if bounds were not specified in the VIF.\n    // We call it here because the fallback bounds calculation requires geoJSON.\n    if (_firstRender) {\n      _initializeMap(_choroplethContainer, data);\n    }\n\n    _updateFeatureLayer(data);\n\n    // TODO: React to active filters being cleared.\n  };\n\n  // TODO: Remove this once Data Lens is using the new (correct)\n  // `.invalidateSize()` method instead of `.updateDimensions()`.\n  this.updateDimensions = function() {\n    _updateDimensions(_choroplethContainer);\n  };\n\n  this.invalidateSize = function() {\n    _updateDimensions(_choroplethContainer);\n  };\n\n  this.updateTileLayer = function(options) {\n    _.merge(_lastRenderOptions, options);\n    _updateTileLayer(options.baseLayer.url, options.baseLayer.opacity);\n  };\n\n  this.renderError = function() {\n    // TODO: Some helpful error message.\n  };\n\n  this.destroy = function() {\n\n    // Remove Miscellaneous Events\n    _detachEvents();\n\n    if (_map) {\n      _map.remove();\n    }\n\n    self.element.empty();\n  };\n\n\n  /**\n   * Private methods\n   */\n\n  /**\n   * Creates HTML for visualization and adds it to the provided element.\n   *\n   * @param {jQuery Element} element - element to append visualization\n   */\n  function _renderTemplate(el) {\n\n    // jQuery doesn't support SVG, so we have to create these elements manually :(\n    var xmlns = 'http://www.w3.org/2000/svg';\n\n    var ticks = document.createElementNS(xmlns, 'g');\n    ticks.setAttribute('class', 'ticks');\n\n    var legendTicks = document.createElementNS(xmlns, 'svg');\n    legendTicks.setAttribute('class', 'legend-ticks');\n    $(legendTicks).append(ticks);\n\n    var gradient = document.createElementNS(xmlns, 'svg');\n    gradient.setAttribute('class', 'gradient');\n\n    var choroplethLegend = $(\n      '<div>',\n      {\n        'class': 'choropleth-legend'\n      }\n    ).append([\n      gradient,\n      legendTicks\n    ]);\n\n    var choroplethMapContainer = $(\n      '<div>',\n      {\n        'class': 'choropleth-map-container'\n      }\n    );\n\n    var choroplethContainer = el.find('.choropleth-container');\n\n    if (_.isEmpty(choroplethContainer)) {\n      choroplethContainer = $(\n        '<div>',\n        {\n          'class': 'choropleth-container'\n        }\n      );\n    }\n\n    choroplethContainer.append([\n      choroplethMapContainer,\n      choroplethLegend\n    ]);\n\n    // Cache element selections\n    _choroplethContainer = choroplethContainer;\n    _choroplethMapContainer = choroplethMapContainer;\n    _choroplethLegend = choroplethLegend;\n\n    el.append(choroplethContainer);\n  }\n\n  function _initializeMap(el, data) {\n    // Only update bounds on the first render so we can persist\n    // users' panning and zooming.\n    // It is critical to invalidate size prior to updating bounds\n    // Otherwise, Leaflet will fit the bounds to an incorrectly sized viewport.\n    // This manifests itself as the map being zoomed all of the way out.\n    _map.invalidateSize();\n    _updateBounds(data, vif.configuration.defaultExtent, vif.configuration.savedExtent);\n    _firstRender = false;\n\n    _lastElementWidth = el.width();\n    _lastElementHeight = el.height();\n  }\n\n  /**\n   * Attach Miscellanous Events\n   */\n  function _attachEvents() {\n\n    _choroplethLegend.on('mousemove', '.choropleth-legend-color', _showLegendFlyout);\n    _choroplethLegend.on('mouseout', '.choropleth-legend-color', _hideFlyout);\n\n    _map.on('mouseout', _hideFlyout);\n    _map.on('zoomend dragend', _emitExtentEventsFromMap);\n  }\n\n  /**\n   * Detach Miscellanous Events\n   */\n  function _detachEvents() {\n\n    _choroplethLegend.off('mousemove', '.choropleth-legend-color', _showLegendFlyout);\n    _choroplethLegend.off('mouseout', '.choropleth-legend-color', _hideFlyout);\n\n    _map.off('mouseout', _hideFlyout);\n    _map.off('zoomend dragend', _emitExtentEventsFromMap);\n  }\n\n  /**\n   * Handle mouse over feature.\n   */\n  function _onFeatureMouseOver(event) {\n    _addHighlight(event);\n    _showFlyout(event);\n  }\n\n  /**\n   * Handle mousing out of a feature.\n   */\n  function _onFeatureMouseOut(event) {\n    _removeHighlight(event);\n    _hideFlyout();\n  }\n\n  /**\n   * Handle clicking on a feature.\n   */\n  function _onSelectRegion(event) {\n    var now = Date.now();\n    var delay = now - _lastClick;\n\n    _lastClick = now;\n\n    if (_interactive) {\n      if (delay < MAP_DOUBLE_CLICK_THRESHOLD_MILLISECONDS) {\n        if (!_.isNull(_lastClickTimeout)) {\n\n          // If this is actually a double click, cancel the timeout which\n          // selects the feature and zoom in instead.\n          window.clearTimeout(_lastClickTimeout);\n          _lastClickTimeout = null;\n          _map.setView(event.latlng, _map.getZoom() + 1);\n        }\n      } else {\n        _lastClickTimeout = window.setTimeout(\n          function() { _emitSelectRegionEvent(event); },\n          MAP_SINGLE_CLICK_SUPPRESSION_THRESHOLD_MILLISECONDS\n        );\n      }\n    }\n  }\n\n  function _emitSelectRegionEvent(event) {\n    utils.assertHasProperties(\n      _lastRenderedVif,\n      'configuration.shapefile.primaryKey'\n    );\n\n    var feature = event.target.feature;\n    var shapefilePrimaryKey = _lastRenderedVif.\n      configuration.\n      shapefile.\n      primaryKey;\n\n    if (feature.properties.hasOwnProperty(shapefilePrimaryKey)) {\n      self.emitEvent(\n        'SOCRATA_VISUALIZATION_CHOROPLETH_SELECT_REGION',\n        {\n          // TODO: Once Data Lens has been updated, kill the `layer` and\n          // `feature` properties of the emitted event payload.\n          layer: event.target,\n          feature: event.target.feature,\n          shapefileFeatureId: feature.properties[shapefilePrimaryKey]\n        }\n      );\n    }\n  }\n\n  function _showFlyout(event) {\n    var feature = event.target.feature;\n    var unfilteredValueUnit;\n    var filteredValueUnit;\n    var payload = {\n      element: event.target,\n      clientX: event.originalEvent.clientX,\n      clientY: event.originalEvent.clientY,\n      title: feature.properties[LABEL_GEOJSON_PROPERTY_NAME],\n      unfilteredValueLabel: self.getLocalization('FLYOUT_UNFILTERED_AMOUNT_LABEL'),\n      filteredValueLabel: self.getLocalization('FLYOUT_FILTERED_AMOUNT_LABEL'),\n      selectedNotice: self.getLocalization('FLYOUT_SELECTED_NOTICE'),\n      selected: feature.properties[SELECTED_GEOJSON_PROPERTY_NAME]\n    };\n\n    if (feature.properties[UNFILTERED_GEOJSON_PROPERTY_NAME] === 1) {\n\n      unfilteredValueUnit = (_.has(_lastRenderOptions, 'unit.one')) ?\n        _lastRenderOptions.unit.one :\n        vif.unit.one;\n\n    } else {\n\n      unfilteredValueUnit = (_.has(_lastRenderOptions, 'unit.other')) ?\n        _lastRenderOptions.unit.other :\n        vif.unit.other;\n    }\n\n    if (feature.properties[FILTERED_GEOJSON_PROPERTY_NAME] === 1) {\n\n      filteredValueUnit = (_.has(_lastRenderOptions, 'unit.one')) ?\n        _lastRenderOptions.unit.one :\n        vif.unit.one;\n\n    } else {\n\n      filteredValueUnit = (_.has(_lastRenderOptions, 'unit.other')) ?\n        _lastRenderOptions.unit.other :\n        vif.unit.other;\n    }\n\n    if (_.isNumber(feature.properties[UNFILTERED_GEOJSON_PROPERTY_NAME])) {\n\n      payload.unfilteredValue = '{0} {1}'.format(\n        utils.formatNumber(feature.properties[UNFILTERED_GEOJSON_PROPERTY_NAME]),\n        unfilteredValueUnit\n      );\n\n    } else {\n\n      payload.unfilteredValue = self.getLocalization('NO_VALUE');\n    }\n\n    if (_lastRenderOptions.showFiltered) {\n\n      if (_.isNumber(feature.properties[FILTERED_GEOJSON_PROPERTY_NAME])) {\n\n        payload.filteredValue = '{0} {1}'.format(\n          utils.formatNumber(feature.properties[FILTERED_GEOJSON_PROPERTY_NAME]),\n          filteredValueUnit\n        );\n\n      } else {\n\n        payload.filteredValue = self.getLocalization('NO_VALUE');\n      }\n    }\n\n    self.emitEvent(\n      'SOCRATA_VISUALIZATION_CHOROPLETH_FEATURE_FLYOUT',\n      payload\n    );\n  }\n\n  function _showLegendFlyout(event) {\n\n    var el = event.target;\n\n    var payload = {\n      title: el.getAttribute('data-flyout-text'),\n      element: el\n    };\n\n    self.emitEvent(\n      'SOCRATA_VISUALIZATION_CHOROPLETH_LEGEND_FLYOUT',\n      payload\n    );\n  }\n\n  function _hideFlyout() {\n\n    self.emitEvent(\n      'SOCRATA_VISUALIZATION_CHOROPLETH_FLYOUT_HIDE',\n      null\n    );\n  }\n\n  function _emitExtentEventsFromMap() {\n    var leafletBounds = _map.getBounds();\n\n    utils.assert(leafletBounds.isValid(), 'Bounds object is not valid.');\n\n    var updatedBounds = {\n      southwest: {\n        lat: leafletBounds.getSouth(),\n        lng: leafletBounds.getWest()\n      },\n      northeast: {\n        lat: leafletBounds.getNorth(),\n        lng: leafletBounds.getEast()\n      }\n    };\n\n    self.emitEvent(\n      'SOCRATA_VISUALIZATION_CHOROPLETH_EXTENT_CHANGE',\n      updatedBounds\n    );\n  }\n\n  /**\n   * Creates a new base tile layer and adds it to the map.\n   *\n   * @param {String} url - tile server endpoint to use\n   * @param {Number} opacity - opacity of the tile layer\n   */\n  function _updateTileLayer(url, opacity) {\n\n    if (_baseTileLayer) {\n      _map.removeLayer(_baseTileLayer);\n    }\n\n    _baseTileLayer = L.tileLayer(\n      url,\n      {\n        attribution: '',\n        detectRetina: false,\n        opacity: opacity,\n        unloadInvisibleTiles: true\n      }\n    );\n\n    _map.addLayer(_baseTileLayer);\n  }\n\n  /**\n   * Creates a new feature layer and adds it to the map.\n   *\n   * @param {Object} data - geoJson feature collection to be rendered\n   */\n  function _updateFeatureLayer(data) {\n\n    // Validate data is geoJson\n    utils.assertHasProperties(\n      data,\n      'features',\n      'type'\n    );\n\n    // Emit render started\n    self.emitEvent(\n      'SOCRATA_VISUALIZATION_CHOROPLETH_RENDER_START',\n      {\n        timestamp: Date.now()\n      }\n    );\n\n    // Determine dimensions\n    var dimensions = {\n      width: _lastElementWidth,\n      height: _lastElementHeight\n    };\n\n    // Add legend and get color scale\n    var _coloring = _legend.update(data, dimensions);\n\n    var featureOptions = {\n      onEachFeature: function(feature, layer) {\n        layer.on({\n          mouseover: _onFeatureMouseOver,\n          mouseout: _onFeatureMouseOut,\n          mousemove: _showFlyout,\n          click: _onSelectRegion\n        });\n      },\n      style: _visualizationUtils.getStyleFn(_coloring)\n    };\n\n    if (!_.isNull(_geojsonBaseLayer)) {\n      _map.removeLayer(_geojsonBaseLayer);\n    }\n\n    _geojsonBaseLayer = L.geoJson(data, featureOptions);\n    _geojsonBaseLayer.addTo(_map);\n\n    // Emit render complete\n    self.emitEvent(\n      'SOCRATA_VISUALIZATION_CHOROPLETH_RENDER_COMPLETE',\n      {\n        timestamp: Date.now()\n      }\n    );\n  }\n\n  /**\n   * Update map bounds.\n   */\n  function _updateBounds(geojsonData, defaultExtent, savedExtent) {\n\n    function _buildPositionArray(positions) {\n\n      var cleanPositions = positions.filter(function(position) {\n        return _.isNumber(position[0]) && _.isNumber(position[1]);\n      });\n\n      // IMPORTANT NOTE: in geojson, positions are denoted as [longitude, latitude] pairs\n      var lngs = _.map(cleanPositions, function(lngLat) { return lngLat[0]; });\n      var lats = _.map(cleanPositions, function(lngLat) { return lngLat[1]; });\n\n      // Clamp values to min and max\n      if (_.min(lngs) < _minLng) {\n        _minLng = _.min(lngs);\n      }\n\n      if (_.max(lngs) > _maxLng) {\n        _maxLng = _.max(lngs);\n      }\n\n      if (_.min(lats) < _minLat) {\n        _minLat = _.min(lats);\n      }\n\n      if (_.max(lats) > _maxLat) {\n        _maxLat = _.max(lats);\n      }\n    }\n\n    function _buildBounds(featureExtent) {\n\n      var southWest = L.latLng(featureExtent.southwest[0], featureExtent.southwest[1]);\n      var northEast = L.latLng(featureExtent.northeast[0], featureExtent.northeast[1]);\n      var bounds = L.latLngBounds(southWest, northEast);\n\n      utils.assert(bounds.isValid(), 'Bounds is not valid.');\n\n      return bounds;\n    }\n\n    _minLng = 180;\n    _maxLng = -180;\n    _minLat = 90;\n    _maxLat = -90;\n    _boundsArray = [\n      [_maxLat, _maxLng],\n      [_minLat, _minLng]\n    ];\n\n    if (!_.isUndefined(geojsonData)) {\n\n      if (geojsonData.type !== 'FeatureCollection') {\n        throw new Error('Cannot calculate geojson bounds: geojsonData is not of type <FeatureCollection>.');\n      }\n\n      _.each(geojsonData.features, function(feature) {\n        _coordinates = feature.geometry.coordinates;\n\n        switch (feature.geometry.type) {\n\n          // Polygon or MultiLineString coordinates\n          // = arrays of position arrays\n          case 'Polygon':\n          case 'MultiLineString':\n            _.each(_coordinates, function(positionArrays) {\n              _buildPositionArray(positionArrays);\n            });\n            break;\n\n          // MultiPolygon coordinates = an array of Polygon coordinate arrays\n          case 'MultiPolygon':\n            _.each(_coordinates, function(polygonCoordinates) {\n              _.each(polygonCoordinates, function(positionArrays) {\n                _buildPositionArray(positionArrays);\n              });\n            });\n            break;\n\n          // LineString coordinates = position array\n          case 'LineString':\n            _buildPositionArray(_coordinates);\n            break;\n        }\n      });\n\n      _boundsArray = [\n        [_maxLat, _maxLng],\n        [_minLat, _minLng]\n      ];\n    }\n\n    var computedBounds = L.latLngBounds([\n      _boundsArray[1][0],\n      _boundsArray[1][1]\n    ], [\n      _boundsArray[0][0],\n      _boundsArray[0][1]\n    ]);\n    var initialBounds = computedBounds;\n\n    if (!_.isEmpty(savedExtent)) {\n      initialBounds = _buildBounds(savedExtent);\n    } else if (!_.isEmpty(defaultExtent)) {\n      var defaultBounds = _buildBounds(defaultExtent);\n\n      if (!defaultBounds.contains(computedBounds)) {\n        initialBounds = defaultBounds;\n      }\n    }\n\n    // We need to explicitly pass an options object with\n    // animate set to false because (in some cases) Leaflet\n    // will default to an empty object if none is explicitly\n    // provided and then check the value of a non-existent\n    // animate property, causing a TypeError and halting\n    // execution.\n    _map.fitBounds(\n      initialBounds,\n      {\n        animate: false\n      }\n    );\n  }\n\n  function _updateDimensions(el) {\n    var mapWidth = el.width();\n    var mapHeight = el.height();\n\n    // Recenter map if container's dimensions have changed\n    if (_lastElementWidth !== mapWidth || _lastElementHeight !== mapHeight) {\n      _map.invalidateSize();\n\n      _lastElementWidth = mapWidth;\n      _lastElementHeight = mapHeight;\n    }\n  }\n\n  /**\n   * Add highlighted style to layer.\n   */\n  function _addHighlight(event) {\n\n    var layer = event.target;\n\n    if (!_isLayerSelected(layer)) {\n      layer.setStyle({\n        weight: CHOROPLETH_REGION_HIGHLIGHTED_STROKE_WIDTH\n      });\n\n      // IE HACK (CORE-3566): IE exhibits (not fully-characterized) pointer madness if you bring a layer\n      // containing a MultiPolygon which actually contains more than one polygon to the\n      // front in a featureMouseOver. The rough cause is that the paths corresponding to this\n      // layer get removed and re-added elsewhere in the dom while the mouseover is getting handled.\n      // The symptoms of this are IE spewing mouseout events all over the place on each mousemove.\n      if (!L.Browser.ie) {\n        layer.bringToFront();\n      }\n    }\n  }\n\n  /**\n   * Remove highlighted style to layer.\n   */\n  function _removeHighlight(event) {\n\n    var layer = event.target;\n\n    if (!_isLayerSelected(layer)) {\n      layer.setStyle({\n        weight: CHOROPLETH_REGION_DEFAULT_STROKE_WIDTH\n      });\n      layer.bringToBack();\n    }\n  }\n\n  /**\n   * Determines whether or not the given layer is selected.\n   */\n  function _isLayerSelected(layer) {\n\n    var selectedPropertyName = 'feature.properties.{0}'.\n      format(SELECTED_GEOJSON_PROPERTY_NAME);\n\n    return _.get(layer, selectedPropertyName);\n  }\n\n  /**\n   * A choropleth legend, with discrete colors for ranges of values.\n   */\n  function _LegendDiscrete(legendElement, container) {\n    this.legendElement = legendElement;\n    this.container = container;\n  }\n\n  $.extend(_LegendDiscrete.prototype, {\n\n    /**\n     * Generates a color scale for the given classBreaks.\n     * @param {Number[]} classBreaks The values that define the boundaries of the different\n     *   discrete groups of values.\n     * @return {Object} an object with 'colors' and 'scale' functions, that mirror a chroma scale.\n     */\n    colorScaleFor: function(classBreaks) {\n\n      var marginallyNegative = chroma.interpolate(\n        DISCRETE_LEGEND_ZERO_COLOR,\n        DISCRETE_LEGEND_NEGATIVE_COLOR,\n        0.1\n      );\n      var marginallyPositive = chroma.interpolate(\n        DISCRETE_LEGEND_ZERO_COLOR,\n        DISCRETE_LEGEND_POSITIVE_COLOR,\n        0.1\n      );\n\n      if (classBreaks.length === 1) {\n\n        // There's only one value. So give it only one color.\n        var color;\n        if (classBreaks[0] < 0) {\n          color = DISCRETE_LEGEND_NEGATIVE_COLOR;\n        } else if (classBreaks[0] > 0) {\n          color = DISCRETE_LEGEND_POSITIVE_COLOR;\n        } else {\n          color = DISCRETE_LEGEND_ZERO_COLOR;\n        }\n\n        var singleColorScale = _.constant([color]);\n        singleColorScale.colors = _.constant([color]);\n\n        return singleColorScale;\n      }\n\n      if (classBreaks[0] < 0) {\n\n        // If we have values that straddle zero, add the zero point as one of our breaks\n        if (_.last(classBreaks) > 0) {\n          var indexOfZero = classBreaks.indexOf(0);\n          if (indexOfZero < 0) {\n            throw 'Expecting classBreaks to contain a break at 0, if the values straddle 0';\n          }\n\n          var negatives = classBreaks.slice(0, indexOfZero + 1);\n          var positives = classBreaks.slice(indexOfZero);\n\n          // When the values straddle 0 unevenly, we want the brightness of the colors to be\n          // proportional to how far from 0 it is. In particular, we want eg 5 and -5 to have\n          // about the same amount of luminosity. So - have the colors scale to the same absolute\n          // distance from zero.\n          var negativeHeavy = -classBreaks[0] > _.last(classBreaks);\n          if (negativeHeavy) {\n\n            // The last value of classBreaks is interpreted as the highest value that's in the\n            // last class. Since we're adding another value to the end, it's meaning changes - now\n            // it is the lowest value (inclusive) of the last break. Since we actually want that\n            // value to be included in the last class, we have to increment it.\n            positives[positives.length - 1] += (-classBreaks[0] - _.last(positives)) / 100;\n            positives.push(-classBreaks[0]);\n          } else {\n            negatives.unshift(-_.last(classBreaks));\n          }\n\n          var negativeColorScale = _visualizationUtils.calculateColoringScale(\n            [DISCRETE_LEGEND_NEGATIVE_COLOR, marginallyNegative],\n            negatives\n          );\n          var positiveColorScale = _visualizationUtils.calculateColoringScale(\n            [marginallyPositive, DISCRETE_LEGEND_POSITIVE_COLOR],\n            positives\n          );\n\n          // Create a faux colorScale that implements the interface, but delegates to the positive\n          // or negative actual-scale depending on what you're trying to scale.\n          var fauxColorScale = _.bind(function(value) {\n            if (value === 0) {\n              return chroma(DISCRETE_LEGEND_ZERO_COLOR);\n            } else {\n              return (value < 0 ? negativeColorScale : positiveColorScale)(value);\n            }\n          }, this);\n\n          /**\n           * Our faux .colors method basically just retrieves the positive and negative arrays and\n           * combines them.\n           */\n          fauxColorScale.colors = function() {\n\n            var negColors = negativeColorScale.colors();\n            var posColors = positiveColorScale.colors();\n\n            // We added a break to catch the most-luminescent color, on the scale that didn't have\n            // values as high as the other one. So - drop that color.\n            if (negativeHeavy) {\n              posColors.pop();\n            } else {\n              negColors.shift();\n            }\n\n            // chroma gives us 2 colors if we give it a domain of only 2 values. This messes\n            // things up later on when we assume that classBreaks.length == colors.length + 1, so\n            // shave off some colors if we have to.\n            if (negatives.length === 2) {\n              negColors = negColors.slice(0, 1);\n            }\n            if (positives.length === 2) {\n              posColors = posColors.slice(1);\n            }\n\n            return negColors.concat(posColors);\n          };\n\n          return fauxColorScale;\n\n        } else {\n\n          // All the numbers are negative. Give them the negative color scale.\n          return _visualizationUtils.calculateColoringScale(\n            [DISCRETE_LEGEND_NEGATIVE_COLOR, marginallyNegative],\n            classBreaks\n          );\n        }\n      } else {\n        // Otherwise, it's all positive, so give them the positive color scale.\n        return _visualizationUtils.calculateColoringScale(\n          [marginallyPositive, DISCRETE_LEGEND_POSITIVE_COLOR],\n          classBreaks\n        );\n      }\n    },\n\n    /**\n     * Updates the legend.\n     *\n     * @param {Number[]} data The data being plotted on the map.\n     *\n     * @return {chroma.scale} A chroma color scale that maps a datum value to a color.\n     */\n    update: function(data) {\n\n      var classBreaks = _visualizationUtils.calculateDataClassBreaks(\n        data,\n        UNFILTERED_GEOJSON_PROPERTY_NAME\n      );\n\n      _visualizationUtils.addZeroIfNecessary(classBreaks);\n\n      var numTicks = 3;\n      var tickValues;\n      var colorScale = this.colorScaleFor(classBreaks);\n\n      switch (classBreaks.length) {\n\n        case 0:\n          this.legendElement.hide();\n          return null;\n\n        case 1:\n          tickValues = classBreaks.slice(0);\n\n          // If there is just 1 value, make it range from 0 to that value.\n          if (classBreaks[0] === 0) {\n\n            // ...the only value is 0. Give 'em a fake range. It's all they deserve.\n            classBreaks.push(1);\n          } else if (classBreaks[0] < 0) {\n            classBreaks.push(0);\n          } else {\n            classBreaks.unshift(0);\n          }\n          break;\n\n        case 2:\n\n          // If there are two values, duplicate the max value, to allow there to be a color stop\n          tickValues = classBreaks.slice(0);\n          classBreaks = [classBreaks[0], classBreaks[1], classBreaks[1]];\n          break;\n\n        default:\n          if (this.container.height() < 250) {\n            numTicks = 3;\n          } else {\n            numTicks = Math.min(classBreaks.length, 4);\n          }\n      }\n\n      var minBreak = classBreaks[0];\n      var maxBreak = _.last(classBreaks);\n\n      // Size of the colored scale.\n      var COLOR_BAR_WIDTH = 15;\n      var colorBarHeight = Math.floor(Math.min(this.container.height() - 60, 250));\n\n      // Reserve some padding space for the bottom-most tick label text.\n      var BOTTOM_PADDING = 15;\n\n      var colors = colorScale.colors();\n\n      // Give the svg an empty datum, so that it will create/reuse one svg\n      var svg = d3.select(this.legendElement[0]).\n        selectAll('svg').\n        data([{}]);\n\n      svg.enter().\n        append('svg');\n\n      svg.attr('height', colorBarHeight + BOTTOM_PADDING);\n\n      var yTickScale = d3.scale.linear().range([colorBarHeight - 1, 1]);\n      var yLabelScale = d3.scale.linear().range([colorBarHeight, 0]);\n      var yAxis = d3.svg.\n        axis().\n        scale(yTickScale).\n        orient('left');\n\n      if (tickValues) {\n        yAxis.tickValues(tickValues);\n      } else {\n        yAxis.ticks(numTicks);\n      }\n\n      // Ensure that there's always a 0 tick\n      /* FIXME (jerjou): 2015-02-04 I can't seem to get a d3 range to NOT give me a 0 if it\n       * straddles 0. So while I could leave this block in, I can't figure out a way to verify\n       * that it works.\n      if (minBreak <= 0 && maxBreak >= 0) {\n        var ticks = yTickScale.ticks(numTicks);\n        var index = ticks.indexOf(0);\n        if (-1 === index) {\n          ticks.splice(0, 0, 0);\n        }\n        yAxis.tickValues(ticks);\n      }\n      */\n\n      var yTickScaleDomain = yTickScale.domain([minBreak, maxBreak]);\n      var yLabelScaleDomain = yLabelScale.domain([minBreak, maxBreak]);\n\n      // 'ss' is simple_statistics.js\n      var isLargeRange = ss.standard_deviation(classBreaks) > 10;\n\n      if (isLargeRange) {\n\n        // d3 quirk: using a #tickFormat formatter that just returns the value\n        // gives unexpected results due to floating point math.\n        // We want to just return the value for \"small-ranged\" data.\n        // --> do not call a tickFormatter on yAxis if range is small.\n        yAxis.tickFormat(_visualizationUtils.bigNumTickFormatter);\n\n        // Due to similar issues, d3's scale#nice method also has\n        // floating point math issues.\n        yTickScaleDomain.nice();\n        yLabelScaleDomain.nice();\n\n        // Update first and last class breaks to nice y domain\n        classBreaks[0] = yTickScale.domain()[0];\n        classBreaks[classBreaks.length - 1] = yTickScale.domain()[1];\n      }\n\n      // Give it some data so it creates the container element\n      var labels = svg.selectAll('.labels').\n          data([null]);\n\n      labels.enter().\n        append('g').\n        attr('class', 'labels');\n\n      // Remove axis line that comes with d3 axis\n      labels.\n        call(yAxis).\n        select('path').\n        remove();\n\n      labels.\n        exit().\n        remove();\n\n      var labelTextElement = this.legendElement.find('.labels > .tick > text');\n      var maxLabelWidth = _.reduce(labelTextElement, function(accumulator, el) {\n        return Math.max(accumulator, $(el).width());\n      }, 0);\n      var tickAreaWidth = maxLabelWidth + yAxis.tickSize() + yAxis.tickPadding();\n\n      // The d3 axis places all elements LEFT of the origin (negative X coords).\n      // Translate everything to within the bounds of the SVG.\n      labels.\n        attr('transform', 'translate({0})'.format(tickAreaWidth));\n\n      // Size the SVG appropriately.\n      svg.attr('width', tickAreaWidth + COLOR_BAR_WIDTH);\n\n      // Size the container appropriately\n      _choroplethLegend.css('height', colorBarHeight + BOTTOM_PADDING);\n      _choroplethLegend.css('width', tickAreaWidth + COLOR_BAR_WIDTH);\n\n      // draw legend colors\n      var rects = svg.\n        selectAll('.choropleth-legend-color').\n        data(colors);\n\n      rects.enter().\n        append('rect');\n\n      rects.\n        attr('class', 'choropleth-legend-color').\n        attr('width', COLOR_BAR_WIDTH).\n        attr('height', _.bind(function(c, i) {\n          return Math.floor(\n            yLabelScale(classBreaks[i]) -\n            yLabelScale(classBreaks[i + 1])\n          );\n        }, this)).\n        attr('x', tickAreaWidth).\n        attr('y', function(c, i) {\n          return Math.floor(yLabelScale(classBreaks[i + 1]));\n        }).\n        style('fill', function(c) {\n          return c;\n        });\n\n      if ((tickValues ? tickValues.length : numTicks) === 1) {\n        var value = _.filter(classBreaks)[0];\n        if (isLargeRange) {\n          rects.\n            attr('data-flyout-text', _visualizationUtils.bigNumTickFormatter(value));\n        } else {\n          rects.\n            attr('data-flyout-text', value);\n        }\n      } else {\n        if (isLargeRange) {\n          rects.\n            attr('data-flyout-text', _.bind(function(color, i) {\n              return _visualizationUtils.bigNumTickFormatter(classBreaks[i]) + ' – ' +\n                _visualizationUtils.bigNumTickFormatter(classBreaks[i + 1]);\n            }, this));\n        } else {\n          rects.\n            attr('data-flyout-text', function(color, i) {\n              return '{0} – {1}'.format(classBreaks[i], classBreaks[i + 1]);\n            });\n        }\n      }\n\n      rects.exit().\n        remove();\n\n      return colorScale;\n    }\n  });\n\n  /**\n   * A Legend with a continuous scale.\n   */\n  function _LegendContinuous(legendElement, container) {\n\n    this.legendElement = legendElement.addClass('continuous');\n    this.container = container;\n    this.gradientId = 'gradient-{0}'.format(_.uniqueId());\n  }\n\n  $.extend(_LegendContinuous.prototype, {\n    /**\n     * Finds an array of values, including the min, max, and numStops - 2 more values,\n     * evenly-spaced between the min and max.\n     *\n     * @param {d3.scale} scale a d3 scale whose domain is the value domain.\n     * @param {Number} numStops the number of values to find.\n     *\n     * @return {Number[]} a sorted array of numbers, of length numStops. The first element is the\n     *   smallest value in the features, the last element is the largest, and the other values are\n     *   evenly spaced between them (and may not actually appear in the dataset).\n     * @private\n     */\n    findTickStops: function(scale, numStops) {\n\n      var scaleForReversing = scale.copy().range([0, 1]);\n      var stops = _.map(\n        _.range(0, 1, 1 / (numStops - 1)),\n        _.bind(scaleForReversing.invert, scaleForReversing)\n      ).concat(_.last(scaleForReversing.domain()));\n\n      if (_.last(stops) - stops[0] > 5) {\n        stops = _.map(stops, Math.round);\n      }\n\n      // For log scales, if the first stop is zero, set it to the minimum value.\n      if (scale.base && _.first(stops) === 0) {\n        stops[0] = _.first(scale.domain());\n      }\n\n      return stops;\n    },\n\n    /**\n     * Draw an SVG rectangle with the appropriate gradient.\n     *\n     * @param {jQuery selection} gradientSvg The node to render into.\n     * @param {Number[]} tickStops the values at which ticks will be drawn. The first value should\n     *   be the minimum value, and the last value should be the maximum.\n     * @param {d3.scale} colorScale a scale from a value, to a color.\n     *\n     * @private\n     */\n    drawGradient: function(gradientSvg, tickStops, colorScale) {\n\n      var gradientSvgSelection = d3.select(gradientSvg[0]);\n\n      if (d3.select('#' + this.gradientId).empty()) {\n        gradientSvgSelection.append('linearGradient').attr({\n          id: this.gradientId,\n          gradientUnits: 'userSpaceOnUse',\n          y1: '100%',\n          x1: 0,\n          x2: 0,\n          y2: 0\n        });\n      }\n\n      // Due to a webkit bug (https://bugs.webkit.org/show_bug.cgi?id=83438), we can't select a\n      // camelCase element. So select it by id\n      var gradient = gradientSvgSelection.selectAll('#{0}'.format(this.gradientId));\n\n      // Create a scale for positioning values by percentage\n      var positionScale = colorScale.copy().range([0, 100]);\n      var domain = positionScale.domain();\n      if (domain.length > 2) {\n        positionScale.domain([domain[0], _.last(domain)]);\n      }\n\n      // We'll make a stop in the gradient for each tick stop, to ensure the gradients grade\n      // similarly.\n      var gradientStops = gradient.selectAll('stop').data(tickStops);\n      gradientStops.enter().append('stop');\n      gradientStops.attr({\n        'offset': function(value) {\n          return '{0}%'.format(positionScale(value));\n        },\n        'stop-color': colorScale\n      });\n      gradientStops.exit().remove();\n\n      // Draw the rectangles in pieces, so as to store the data, so the ticks can access them.\n      var rectangles = gradientSvgSelection.\n        selectAll('rect').\n        data(tickStops);\n\n      rectangles.enter().\n        append('rect');\n\n      rectangles.attr({\n        x: 0,\n        y: function(value) {\n\n          // Since y is actually 'top', and we want the lowest value at the bottom, subtract\n          // from 100\n          return '{0}%'.format(100 - positionScale(value));\n        },\n        width: '100%',\n        height: function(value, i) {\n          if (i === 0) {\n            return 0;\n          }\n          return '{0}%'.format(Math.abs(positionScale(value) - positionScale(tickStops[i - 1])));\n        },\n        fill: 'url(#{0})'.format(this.gradientId)\n      });\n\n      rectangles.exit().remove();\n    },\n\n    /**\n     * Creates the d3 scale used to map from a value to a color.\n     *\n     * @param {Number[]} tickStops an array of values, the first of which should be the minimum\n     *   value of the data, the last of which should be the maximum value of the data.\n     * @param {d3.scale} scale a d3 scale whose domain is the value domain.\n     *\n     * @return {d3.scale} a scale mapping from a value within features, to a color.\n     * @private\n     */\n    createColorScale: function(tickStops, scale) {\n\n      var domain;\n      var range = [\n        CONTINUOUS_LEGEND_NEGATIVE_COLOR,\n        CONTINUOUS_LEGEND_ZERO_COLOR,\n        CONTINUOUS_LEGEND_POSITIVE_COLOR\n      ];\n      var min = tickStops[0];\n      var max = _.last(tickStops);\n\n      if (min >= 0) {\n\n        // All positive values\n        domain = [min, max];\n        range = range.slice(1);\n      } else if (max <= 0) {\n\n        // All negative values\n        domain = [min, max];\n        range = range.slice(0, 2);\n      } else {\n\n        // Straddle zero\n        domain = [min, 0, max];\n      }\n\n      // For log scales, if the domain includes zero, set it to the minimum value instead.\n      if (scale.base && _.first(domain) === 0) {\n        domain[0] = min;\n      }\n\n      return scale.copy().\n        domain(domain).\n        range(range);\n    },\n\n    /**\n     * Draw the ticks and labels for the legend.\n     *\n     * @param {jQuery selection} ticksSvg The node to render into.\n     * @param {jQuery selection} gradientSvg The associated gradient node to consult for layout.\n     * @param {Number[]} tickStops the values at which ticks will be drawn. The first value should\n     *   be the minimum value, and the last value should be the maximum.\n     * @param {d3.scale} colorScale a scale from a value, to a color.\n     * @param {Number} indexOfZero The index of the origin in ticks.\n     *\n     * @private\n     */\n    drawAxis: function(ticksSvg, gradientSvg, tickStops, scale, indexOfZero) {\n\n      var ticksGroup = ticksSvg.find('g.ticks');\n      var positionScale = scale.copy().range([this.legendElement.height(), 0]);\n      var axis = d3.svg.axis().\n        scale(positionScale).\n        tickValues(tickStops).\n        orient('left');\n\n      if (_.last(tickStops) - tickStops[0] > 10) {\n        axis.tickFormat(_visualizationUtils.bigNumTickFormatter);\n      }\n\n      axis(ticksGroup);\n\n      // We want to size the ticks differently than d3's default. Do that manually.\n      var ticks = d3.select(ticksGroup[0]).selectAll('g.tick');\n\n      // Round ticks close to zero to fix logarithmic special cases.\n      ticks.each(function(d) {\n        if (Math.abs(d) < 1) {\n          d3.select(this).select('text').text('0');\n        }\n      });\n\n      // Alternate small/big, starting with big.\n      var isSmall = true;\n\n      ticks.classed('small', function(value, i) {\n\n        // Zero was added artificially. Show a tick, but make it small.\n        if (i === indexOfZero) {\n          return true;\n        }\n\n        // Always make the end ticks big\n        if (tickStops.length === (i + 1)) {\n          return false;\n        }\n\n        // For normal ticks, alternate big and small\n        isSmall = !isSmall;\n        return isSmall;\n\n      }).style('opacity', ''); // d3 sets an opacity for some reason. unset it.\n\n      // D3's axis draws ticks left-of-origin, which causes issues with browsers that won't render\n      // SVG elements outside of the parent SVG node's bounds (PhantomJS).\n      // So shift the ticks right into positive X coordinates, and then move the entire SVG left\n      // to compensate.\n      // Similarly, D3's tick text extends above and below the SVG bounds. Compensate much the same way.\n      var MAGICAL_FONT_RENDERING_ALLOWANCE = 10;\n      var tickMaxWidth = d3.max(\n        ticksGroup.find('g.tick').map(function(i, el) {\n          return el.getBoundingClientRect().width;\n        })\n      ) + MAGICAL_FONT_RENDERING_ALLOWANCE;\n\n      var tickMaxHeight = d3.max(\n        ticksGroup.find('g.tick').map(function(i, el) {\n          return el.getBoundingClientRect().height;\n        })\n      );\n\n      // Allow for 1/2 tick height above and below by bumping up height.\n      ticksSvg.height(gradientSvg.height() + tickMaxHeight);\n      ticksSvg.width(gradientSvg.width() + tickMaxWidth);\n\n      // Shift the entire SVG appropriately.\n      ticksSvg.css('left', '{0}px'.format(-tickMaxWidth));\n      ticksSvg.css('top', '{0}px'.format(parseInt(gradientSvg.css('top'), 10) - tickMaxHeight / 2));\n\n      // Now listen to me very carefully. Compensate for shift in SVG by putting the ticks back.\n      ticksGroup.attr('transform', 'translate({0},{1})'.format(tickMaxWidth, tickMaxHeight / 2));\n    },\n\n    /**\n     * Determines the type of d3 scale to create for the given values, and creates it.\n     *\n     * @param {Number[]} values the data values we're visualizing.\n     * @param {Number=} min the minimum value within values. Saves us the trouble of finding it,\n     *   if you already have it.\n     * @param {Number=} max the maximum value within values. Saves us the trouble of finding it,\n     *   if you already have it.\n     *\n     * @return {d3.scale} a d3 scale of the determined type, with the domain set.\n     */\n    scaleForValues: function(values, min, max) {\n\n      var scale;\n\n      min = min || _.min(values);\n      max = max || _.max(values);\n\n      if (min > 0 || max < 0) {\n\n        // Eligible for logarithmic scale, if all-positive or all-negative values\n        var deltaMagnitude = Math.log(max - min) / Math.LN10; // Originally `log10` from lodash-mixins.js in Frontend\n        if (deltaMagnitude >= 3) {\n\n          // Only logarithmic if we've got a large change in magnitude\n          scale = d3.scale.log();\n        } else {\n          scale = d3.scale.linear();\n        }\n      } else {\n        scale = d3.scale.linear();\n      }\n\n      return scale.domain([min, max]).nice();\n    },\n\n    NUM_TICKS: 5,\n\n    /**\n     * Redraw the legend.\n     *\n     * @return {d3.scale} a scale mapping from value to color.\n     */\n    update: function(data, dimensions) {\n\n      if (!(data.features && data.features.length)) {\n        return undefined;\n      }\n\n      var values = _.pluck(\n        _.pluck(data.features, 'properties'),\n        UNFILTERED_GEOJSON_PROPERTY_NAME\n      );\n      var min = _.min(values);\n      var max = _.max(values);\n\n      if (min === max) {\n\n        // If there's only one value, make it a scale from 0 to that value.\n        if (max < 0) {\n          values.push(0);\n          max = 0;\n        } else if (min > 0) {\n          values.unshift(0);\n          min = 0;\n\n        // ...the only value is 0. Give 'em a fake range. It's all they deserve.\n        } else {\n          values.push(1);\n          max = 1;\n        }\n      }\n\n      var scale = this.scaleForValues(values, min, max);\n      var tickStops = this.findTickStops(scale, Math.min(values.length, this.NUM_TICKS));\n      var indexOfZero = _visualizationUtils.addZeroIfNecessary(tickStops);\n\n      var colorScale = this.createColorScale(tickStops, scale);\n      var gradientSvg = this.legendElement.find('svg.gradient');\n      var ticksSvg = this.legendElement.find('svg.legend-ticks');\n\n      // Grab the top and bottom padding from the css.\n      var legendPaddingTop = parseInt(this.legendElement.css('padding-top'), 10);\n      var legendPaddingBottom = parseInt(this.legendElement.css('padding-bottom'), 10);\n      var legendVerticalPadding = legendPaddingTop + legendPaddingBottom;\n\n      // We want the maximum height that will fit inside the visualization,\n      // which comes down to: visualizationHeight - legendVerticalPadding.\n      var legendHeight = Math.min(\n        dimensions.height - legendVerticalPadding,\n        parseInt(this.legendElement.css('maxHeight'), 10)\n      );\n\n      // Assign this height to both the legend container and the gradient.\n      // This will cause the legend to be rendered inside the visualization\n      // in all cases, and at its maximum height if the visualization is\n      // sufficiently tall.\n      this.legendElement.height(legendHeight);\n      gradientSvg.height(legendHeight);\n\n      this.drawGradient(gradientSvg, tickStops, colorScale);\n      this.drawAxis(ticksSvg, gradientSvg, tickStops, scale, indexOfZero);\n\n      return colorScale;\n    }\n  });\n}\n\nmodule.exports = ChoroplethMap;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/views/ChoroplethMap.js\n ** module id = 2\n ** module chunks = 0\n **/","'use strict';\n\n/* global module */\n// # simple-statistics\n//\n// A simple, literate statistics system. The code below uses the\n// [Javascript module pattern](http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth),\n// eventually assigning `simple-statistics` to `ss` in browsers or the\n// `exports` object for node.js\n(function() {\n    var ss = {};\n\n    if (typeof module !== 'undefined') {\n        // Assign the `ss` object to exports, so that you can require\n        // it in [node.js](http://nodejs.org/)\n        module.exports = ss;\n    } else {\n        // Otherwise, in a browser, we assign `ss` to the window object,\n        // so you can simply refer to it as `ss`.\n        this.ss = ss;\n    }\n\n    // # [Linear Regression](http://en.wikipedia.org/wiki/Linear_regression)\n    //\n    // [Simple linear regression](http://en.wikipedia.org/wiki/Simple_linear_regression)\n    // is a simple way to find a fitted line\n    // between a set of coordinates.\n    function linear_regression() {\n        var linreg = {},\n            data = [];\n\n        // Assign data to the model. Data is assumed to be an array.\n        linreg.data = function(x) {\n            if (!arguments.length) return data;\n            data = x.slice();\n            return linreg;\n        };\n\n        // Calculate the slope and y-intercept of the regression line\n        // by calculating the least sum of squares\n        linreg.mb = function() {\n            var m, b;\n\n            // Store data length in a local variable to reduce\n            // repeated object property lookups\n            var data_length = data.length;\n\n            //if there's only one point, arbitrarily choose a slope of 0\n            //and a y-intercept of whatever the y of the initial point is\n            if (data_length === 1) {\n                m = 0;\n                b = data[0][1];\n            } else {\n                // Initialize our sums and scope the `m` and `b`\n                // variables that define the line.\n                var sum_x = 0, sum_y = 0,\n                    sum_xx = 0, sum_xy = 0;\n\n                // Use local variables to grab point values\n                // with minimal object property lookups\n                var point, x, y;\n\n                // Gather the sum of all x values, the sum of all\n                // y values, and the sum of x^2 and (x*y) for each\n                // value.\n                //\n                // In math notation, these would be SS_x, SS_y, SS_xx, and SS_xy\n                for (var i = 0; i < data_length; i++) {\n                    point = data[i];\n                    x = point[0];\n                    y = point[1];\n\n                    sum_x += x;\n                    sum_y += y;\n\n                    sum_xx += x * x;\n                    sum_xy += x * y;\n                }\n\n                // `m` is the slope of the regression line\n                m = ((data_length * sum_xy) - (sum_x * sum_y)) /\n                    ((data_length * sum_xx) - (sum_x * sum_x));\n\n                // `b` is the y-intercept of the line.\n                b = (sum_y / data_length) - ((m * sum_x) / data_length);\n            }\n\n            // Return both values as an object.\n            return { m: m, b: b };\n        };\n\n        // a shortcut for simply getting the slope of the regression line\n        linreg.m = function() {\n            return linreg.mb().m;\n        };\n\n        // a shortcut for simply getting the y-intercept of the regression\n        // line.\n        linreg.b = function() {\n            return linreg.mb().b;\n        };\n\n        // ## Fitting The Regression Line\n        //\n        // This is called after `.data()` and returns the\n        // equation `y = f(x)` which gives the position\n        // of the regression line at each point in `x`.\n        linreg.line = function() {\n\n            // Get the slope, `m`, and y-intercept, `b`, of the line.\n            var mb = linreg.mb(),\n                m = mb.m,\n                b = mb.b;\n\n            // Return a function that computes a `y` value for each\n            // x value it is given, based on the values of `b` and `a`\n            // that we just computed.\n            return function(x) {\n                return b + (m * x);\n            };\n        };\n\n        return linreg;\n    }\n\n    // # [R Squared](http://en.wikipedia.org/wiki/Coefficient_of_determination)\n    //\n    // The r-squared value of data compared with a function `f`\n    // is the sum of the squared differences between the prediction\n    // and the actual value.\n    function r_squared(data, f) {\n        if (data.length < 2) return 1;\n\n        // Compute the average y value for the actual\n        // data set in order to compute the\n        // _total sum of squares_\n        var sum = 0, average;\n        for (var i = 0; i < data.length; i++) {\n            sum += data[i][1];\n        }\n        average = sum / data.length;\n\n        // Compute the total sum of squares - the\n        // squared difference between each point\n        // and the average of all points.\n        var sum_of_squares = 0;\n        for (var j = 0; j < data.length; j++) {\n            sum_of_squares += Math.pow(average - data[j][1], 2);\n        }\n\n        // Finally estimate the error: the squared\n        // difference between the estimate and the actual data\n        // value at each point.\n        var err = 0;\n        for (var k = 0; k < data.length; k++) {\n            err += Math.pow(data[k][1] - f(data[k][0]), 2);\n        }\n\n        // As the error grows larger, its ratio to the\n        // sum of squares increases and the r squared\n        // value grows lower.\n        return 1 - (err / sum_of_squares);\n    }\n\n\n    // # [Bayesian Classifier](http://en.wikipedia.org/wiki/Naive_Bayes_classifier)\n    //\n    // This is a naïve bayesian classifier that takes\n    // singly-nested objects.\n    function bayesian() {\n        // The `bayes_model` object is what will be exposed\n        // by this closure, with all of its extended methods, and will\n        // have access to all scope variables, like `total_count`.\n        var bayes_model = {},\n            // The number of items that are currently\n            // classified in the model\n            total_count = 0,\n            // Every item classified in the model\n            data = {};\n\n        // ## Train\n        // Train the classifier with a new item, which has a single\n        // dimension of Javascript literal keys and values.\n        bayes_model.train = function(item, category) {\n            // If the data object doesn't have any values\n            // for this category, create a new object for it.\n            if (!data[category]) data[category] = {};\n\n            // Iterate through each key in the item.\n            for (var k in item) {\n                var v = item[k];\n                // Initialize the nested object `data[category][k][item[k]]`\n                // with an object of keys that equal 0.\n                if (data[category][k] === undefined) data[category][k] = {};\n                if (data[category][k][v] === undefined) data[category][k][v] = 0;\n\n                // And increment the key for this key/value combination.\n                data[category][k][item[k]]++;\n            }\n            // Increment the number of items classified\n            total_count++;\n        };\n\n        // ## Score\n        // Generate a score of how well this item matches all\n        // possible categories based on its attributes\n        bayes_model.score = function(item) {\n            // Initialize an empty array of odds per category.\n            var odds = {}, category;\n            // Iterate through each key in the item,\n            // then iterate through each category that has been used\n            // in previous calls to `.train()`\n            for (var k in item) {\n                var v = item[k];\n                for (category in data) {\n                    // Create an empty object for storing key - value combinations\n                    // for this category.\n                    if (odds[category] === undefined) odds[category] = {};\n\n                    // If this item doesn't even have a property, it counts for nothing,\n                    // but if it does have the property that we're looking for from\n                    // the item to categorize, it counts based on how popular it is\n                    // versus the whole population.\n                    if (data[category][k]) {\n                        odds[category][k + '_' + v] = (data[category][k][v] || 0) / total_count;\n                    } else {\n                        odds[category][k + '_' + v] = 0;\n                    }\n                }\n            }\n\n            // Set up a new object that will contain sums of these odds by category\n            var odds_sums = {};\n\n            for (category in odds) {\n                // Tally all of the odds for each category-combination pair -\n                // the non-existence of a category does not add anything to the\n                // score.\n                for (var combination in odds[category]) {\n                    if (odds_sums[category] === undefined) odds_sums[category] = 0;\n                    odds_sums[category] += odds[category][combination];\n                }\n            }\n\n            return odds_sums;\n        };\n\n        // Return the completed model.\n        return bayes_model;\n    }\n\n    // # sum\n    //\n    // is simply the result of adding all numbers\n    // together, starting from zero.\n    //\n    // This runs on `O(n)`, linear time in respect to the array\n    function sum(x) {\n        var value = 0;\n        for (var i = 0; i < x.length; i++) {\n            value += x[i];\n        }\n        return value;\n    }\n\n    // # mean\n    //\n    // is the sum over the number of values\n    //\n    // This runs on `O(n)`, linear time in respect to the array\n    function mean(x) {\n        // The mean of no numbers is null\n        if (x.length === 0) return null;\n\n        return sum(x) / x.length;\n    }\n\n    // # geometric mean\n    //\n    // a mean function that is more useful for numbers in different\n    // ranges.\n    //\n    // this is the nth root of the input numbers multiplied by each other\n    //\n    // This runs on `O(n)`, linear time in respect to the array\n    function geometric_mean(x) {\n        // The mean of no numbers is null\n        if (x.length === 0) return null;\n\n        // the starting value.\n        var value = 1;\n\n        for (var i = 0; i < x.length; i++) {\n            // the geometric mean is only valid for positive numbers\n            if (x[i] <= 0) return null;\n\n            // repeatedly multiply the value by each number\n            value *= x[i];\n        }\n\n        return Math.pow(value, 1 / x.length);\n    }\n\n\n    // # harmonic mean\n    //\n    // a mean function typically used to find the average of rates\n    //\n    // this is the reciprocal of the arithmetic mean of the reciprocals\n    // of the input numbers\n    //\n    // This runs on `O(n)`, linear time in respect to the array\n    function harmonic_mean(x) {\n        // The mean of no numbers is null\n        if (x.length === 0) return null;\n\n        var reciprocal_sum = 0;\n\n        for (var i = 0; i < x.length; i++) {\n            // the harmonic mean is only valid for positive numbers\n            if (x[i] <= 0) return null;\n\n            reciprocal_sum += 1 / x[i];\n        }\n\n        // divide n by the the reciprocal sum\n        return x.length / reciprocal_sum;\n    }\n\n\n    // # min\n    //\n    // This is simply the minimum number in the set.\n    //\n    // This runs on `O(n)`, linear time in respect to the array\n    function min(x) {\n        var value;\n        for (var i = 0; i < x.length; i++) {\n            // On the first iteration of this loop, min is\n            // undefined and is thus made the minimum element in the array\n            if (x[i] < value || value === undefined) value = x[i];\n        }\n        return value;\n    }\n\n    // # max\n    //\n    // This is simply the maximum number in the set.\n    //\n    // This runs on `O(n)`, linear time in respect to the array\n    function max(x) {\n        var value;\n        for (var i = 0; i < x.length; i++) {\n            // On the first iteration of this loop, max is\n            // undefined and is thus made the maximum element in the array\n            if (x[i] > value || value === undefined) value = x[i];\n        }\n        return value;\n    }\n\n    // # [variance](http://en.wikipedia.org/wiki/Variance)\n    //\n    // is the sum of squared deviations from the mean\n    //\n    // depends on `mean()`\n    function variance(x) {\n        // The variance of no numbers is null\n        if (x.length === 0) return null;\n\n        var mean_value = mean(x),\n            deviations = [];\n\n        // Make a list of squared deviations from the mean.\n        for (var i = 0; i < x.length; i++) {\n            deviations.push(Math.pow(x[i] - mean_value, 2));\n        }\n\n        // Find the mean value of that list\n        return mean(deviations);\n    }\n\n    // # [standard deviation](http://en.wikipedia.org/wiki/Standard_deviation)\n    //\n    // is just the square root of the variance.\n    //\n    // depends on `variance()`\n    function standard_deviation(x) {\n        // The standard deviation of no numbers is null\n        if (x.length === 0) return null;\n\n        return Math.sqrt(variance(x));\n    }\n\n    // The sum of deviations to the Nth power.\n    // When n=2 it's the sum of squared deviations.\n    // When n=3 it's the sum of cubed deviations.\n    //\n    // depends on `mean()`\n    function sum_nth_power_deviations(x, n) {\n        var mean_value = mean(x),\n            sum = 0;\n\n        for (var i = 0; i < x.length; i++) {\n            sum += Math.pow(x[i] - mean_value, n);\n        }\n\n        return sum;\n    }\n\n    // # [variance](http://en.wikipedia.org/wiki/Variance)\n    //\n    // is the sum of squared deviations from the mean\n    //\n    // depends on `sum_nth_power_deviations`\n    function sample_variance(x) {\n        // The variance of no numbers is null\n        if (x.length <= 1) return null;\n\n        var sum_squared_deviations_value = sum_nth_power_deviations(x, 2);\n\n        // Find the mean value of that list\n        return sum_squared_deviations_value / (x.length - 1);\n    }\n\n    // # [standard deviation](http://en.wikipedia.org/wiki/Standard_deviation)\n    //\n    // is just the square root of the variance.\n    //\n    // depends on `sample_variance()`\n    function sample_standard_deviation(x) {\n        // The standard deviation of no numbers is null\n        if (x.length <= 1) return null;\n\n        return Math.sqrt(sample_variance(x));\n    }\n\n    // # [covariance](http://en.wikipedia.org/wiki/Covariance)\n    //\n    // sample covariance of two datasets:\n    // how much do the two datasets move together?\n    // x and y are two datasets, represented as arrays of numbers.\n    //\n    // depends on `mean()`\n    function sample_covariance(x, y) {\n\n        // The two datasets must have the same length which must be more than 1\n        if (x.length <= 1 || x.length != y.length){\n            return null;\n        }\n\n        // determine the mean of each dataset so that we can judge each\n        // value of the dataset fairly as the difference from the mean. this\n        // way, if one dataset is [1, 2, 3] and [2, 3, 4], their covariance\n        // does not suffer because of the difference in absolute values\n        var xmean = mean(x),\n            ymean = mean(y),\n            sum = 0;\n\n        // for each pair of values, the covariance increases when their\n        // difference from the mean is associated - if both are well above\n        // or if both are well below\n        // the mean, the covariance increases significantly.\n        for (var i = 0; i < x.length; i++){\n            sum += (x[i] - xmean) * (y[i] - ymean);\n        }\n\n        // the covariance is weighted by the length of the datasets.\n        return sum / (x.length - 1);\n    }\n\n    // # [correlation](http://en.wikipedia.org/wiki/Correlation_and_dependence)\n    //\n    // Gets a measure of how correlated two datasets are, between -1 and 1\n    //\n    // depends on `sample_standard_deviation()` and `sample_covariance()`\n    function sample_correlation(x, y) {\n        var cov = sample_covariance(x, y),\n            xstd = sample_standard_deviation(x),\n            ystd = sample_standard_deviation(y);\n\n        if (cov === null || xstd === null || ystd === null) {\n            return null;\n        }\n\n        return cov / xstd / ystd;\n    }\n\n    // # [median](http://en.wikipedia.org/wiki/Median)\n    //\n    // The middle number of a list. This is often a good indicator of 'the middle'\n    // when there are outliers that skew the `mean()` value.\n    function median(x) {\n        // The median of an empty list is null\n        if (x.length === 0) return null;\n\n        // Sorting the array makes it easy to find the center, but\n        // use `.slice()` to ensure the original array `x` is not modified\n        var sorted = x.slice().sort(function (a, b) { return a - b; });\n\n        // If the length of the list is odd, it's the central number\n        if (sorted.length % 2 === 1) {\n            return sorted[(sorted.length - 1) / 2];\n        // Otherwise, the median is the average of the two numbers\n        // at the center of the list\n        } else {\n            var a = sorted[(sorted.length / 2) - 1];\n            var b = sorted[(sorted.length / 2)];\n            return (a + b) / 2;\n        }\n    }\n\n    // # [mode](http://bit.ly/W5K4Yt)\n    //\n    // The mode is the number that appears in a list the highest number of times.\n    // There can be multiple modes in a list: in the event of a tie, this\n    // algorithm will return the most recently seen mode.\n    //\n    // This implementation is inspired by [science.js](https://github.com/jasondavies/science.js/blob/master/src/stats/mode.js)\n    //\n    // This runs on `O(n)`, linear time in respect to the array\n    function mode(x) {\n\n        // Handle edge cases:\n        // The median of an empty list is null\n        if (x.length === 0) return null;\n        else if (x.length === 1) return x[0];\n\n        // Sorting the array lets us iterate through it below and be sure\n        // that every time we see a new number it's new and we'll never\n        // see the same number twice\n        var sorted = x.slice().sort(function (a, b) { return a - b; });\n\n        // This assumes it is dealing with an array of size > 1, since size\n        // 0 and 1 are handled immediately. Hence it starts at index 1 in the\n        // array.\n        var last = sorted[0],\n            // store the mode as we find new modes\n            value,\n            // store how many times we've seen the mode\n            max_seen = 0,\n            // how many times the current candidate for the mode\n            // has been seen\n            seen_this = 1;\n\n        // end at sorted.length + 1 to fix the case in which the mode is\n        // the highest number that occurs in the sequence. the last iteration\n        // compares sorted[i], which is undefined, to the highest number\n        // in the series\n        for (var i = 1; i < sorted.length + 1; i++) {\n            // we're seeing a new number pass by\n            if (sorted[i] !== last) {\n                // the last number is the new mode since we saw it more\n                // often than the old one\n                if (seen_this > max_seen) {\n                    max_seen = seen_this;\n                    value = last;\n                }\n                seen_this = 1;\n                last = sorted[i];\n            // if this isn't a new number, it's one more occurrence of\n            // the potential mode\n            } else { seen_this++; }\n        }\n        return value;\n    }\n\n    // # [t-test](http://en.wikipedia.org/wiki/Student's_t-test)\n    //\n    // This is to compute a one-sample t-test, comparing the mean\n    // of a sample to a known value, x.\n    //\n    // in this case, we're trying to determine whether the\n    // population mean is equal to the value that we know, which is `x`\n    // here. usually the results here are used to look up a\n    // [p-value](http://en.wikipedia.org/wiki/P-value), which, for\n    // a certain level of significance, will let you determine that the\n    // null hypothesis can or cannot be rejected.\n    //\n    // Depends on `standard_deviation()` and `mean()`\n    function t_test(sample, x) {\n        // The mean of the sample\n        var sample_mean = mean(sample);\n\n        // The standard deviation of the sample\n        var sd = standard_deviation(sample);\n\n        // Square root the length of the sample\n        var rootN = Math.sqrt(sample.length);\n\n        // Compute the known value against the sample,\n        // returning the t value\n        return (sample_mean - x) / (sd / rootN);\n    }\n\n    // # [2-sample t-test](http://en.wikipedia.org/wiki/Student's_t-test)\n    //\n    // This is to compute two sample t-test.\n    // Tests whether \"mean(X)-mean(Y) = difference\", (\n    // in the most common case, we often have `difference == 0` to test if two samples\n    // are likely to be taken from populations with the same mean value) with\n    // no prior knowledge on standard deviations of both samples\n    // other than the fact that they have the same standard deviation.\n    //\n    // Usually the results here are used to look up a\n    // [p-value](http://en.wikipedia.org/wiki/P-value), which, for\n    // a certain level of significance, will let you determine that the\n    // null hypothesis can or cannot be rejected.\n    //\n    // `diff` can be omitted if it equals 0.\n    //\n    // [This is used to confirm or deny](http://www.monarchlab.org/Lab/Research/Stats/2SampleT.aspx)\n    // a null hypothesis that the two populations that have been sampled into\n    // `sample_x` and `sample_y` are equal to each other.\n    //\n    // Depends on `sample_variance()` and `mean()`\n    function t_test_two_sample(sample_x, sample_y, difference) {\n        var n = sample_x.length,\n            m = sample_y.length;\n\n        // If either sample doesn't actually have any values, we can't\n        // compute this at all, so we return `null`.\n        if (!n || !m) return null ;\n\n        // default difference (mu) is zero\n        if (!difference) difference = 0;\n\n        var meanX = mean(sample_x),\n            meanY = mean(sample_y);\n\n        var weightedVariance = ((n - 1) * sample_variance(sample_x) +\n            (m - 1) * sample_variance(sample_y)) / (n + m - 2);\n\n        return (meanX - meanY - difference) /\n            Math.sqrt(weightedVariance * (1 / n + 1 / m));\n    }\n\n    // # quantile\n    //\n    // This is a population quantile, since we assume to know the entire\n    // dataset in this library. Thus I'm trying to follow the\n    // [Quantiles of a Population](http://en.wikipedia.org/wiki/Quantile#Quantiles_of_a_population)\n    // algorithm from wikipedia.\n    //\n    // Sample is a one-dimensional array of numbers,\n    // and p is either a decimal number from 0 to 1 or an array of decimal\n    // numbers from 0 to 1.\n    // In terms of a k/q quantile, p = k/q - it's just dealing with fractions or dealing\n    // with decimal values.\n    // When p is an array, the result of the function is also an array containing the appropriate\n    // quantiles in input order\n    function quantile(sample, p) {\n\n        // We can't derive quantiles from an empty list\n        if (sample.length === 0) return null;\n\n        // Sort a copy of the array. We'll need a sorted array to index\n        // the values in sorted order.\n        var sorted = sample.slice().sort(function (a, b) { return a - b; });\n\n        if (p.length) {\n            // Initialize the result array\n            var results = [];\n            // For each requested quantile\n            for (var i = 0; i < p.length; i++) {\n                results[i] = quantile_sorted(sorted, p[i]);\n            }\n            return results;\n        } else {\n            return quantile_sorted(sorted, p);\n        }\n    }\n\n    // # quantile\n    //\n    // This is the internal implementation of quantiles: when you know\n    // that the order is sorted, you don't need to re-sort it, and the computations\n    // are much faster.\n    function quantile_sorted(sample, p) {\n        var idx = (sample.length) * p;\n        if (p < 0 || p > 1) {\n            return null;\n        } else if (p === 1) {\n            // If p is 1, directly return the last element\n            return sample[sample.length - 1];\n        } else if (p === 0) {\n            // If p is 0, directly return the first element\n            return sample[0];\n        } else if (idx % 1 !== 0) {\n            // If p is not integer, return the next element in array\n            return sample[Math.ceil(idx) - 1];\n        } else if (sample.length % 2 === 0) {\n            // If the list has even-length, we'll take the average of this number\n            // and the next value, if there is one\n            return (sample[idx - 1] + sample[idx]) / 2;\n        } else {\n            // Finally, in the simple case of an integer value\n            // with an odd-length list, return the sample value at the index.\n            return sample[idx];\n        }\n    }\n\n    // # [Interquartile range](http://en.wikipedia.org/wiki/Interquartile_range)\n    //\n    // A measure of statistical dispersion, or how scattered, spread, or\n    // concentrated a distribution is. It's computed as the difference between\n    // the third quartile and first quartile.\n    function iqr(sample) {\n        // We can't derive quantiles from an empty list\n        if (sample.length === 0) return null;\n\n        // Interquartile range is the span between the upper quartile,\n        // at `0.75`, and lower quartile, `0.25`\n        return quantile(sample, 0.75) - quantile(sample, 0.25);\n    }\n\n    // # [Median Absolute Deviation](http://en.wikipedia.org/wiki/Median_absolute_deviation)\n    //\n    // The Median Absolute Deviation (MAD) is a robust measure of statistical\n    // dispersion. It is more resilient to outliers than the standard deviation.\n    function mad(x) {\n        // The mad of nothing is null\n        if (!x || x.length === 0) return null;\n\n        var median_value = median(x),\n            median_absolute_deviations = [];\n\n        // Make a list of absolute deviations from the median\n        for (var i = 0; i < x.length; i++) {\n            median_absolute_deviations.push(Math.abs(x[i] - median_value));\n        }\n\n        // Find the median value of that list\n        return median(median_absolute_deviations);\n    }\n\n    // ## Compute Matrices for Jenks\n    //\n    // Compute the matrices required for Jenks breaks. These matrices\n    // can be used for any classing of data with `classes <= n_classes`\n    function jenksMatrices(data, n_classes) {\n\n        // in the original implementation, these matrices are referred to\n        // as `LC` and `OP`\n        //\n        // * lower_class_limits (LC): optimal lower class limits\n        // * variance_combinations (OP): optimal variance combinations for all classes\n        var lower_class_limits = [],\n            variance_combinations = [],\n            // loop counters\n            i, j,\n            // the variance, as computed at each step in the calculation\n            variance = 0;\n\n        // Initialize and fill each matrix with zeroes\n        for (i = 0; i < data.length + 1; i++) {\n            var tmp1 = [], tmp2 = [];\n            // despite these arrays having the same values, we need\n            // to keep them separate so that changing one does not change\n            // the other\n            for (j = 0; j < n_classes + 1; j++) {\n                tmp1.push(0);\n                tmp2.push(0);\n            }\n            lower_class_limits.push(tmp1);\n            variance_combinations.push(tmp2);\n        }\n\n        for (i = 1; i < n_classes + 1; i++) {\n            lower_class_limits[1][i] = 1;\n            variance_combinations[1][i] = 0;\n            // in the original implementation, 9999999 is used but\n            // since Javascript has `Infinity`, we use that.\n            for (j = 2; j < data.length + 1; j++) {\n                variance_combinations[j][i] = Infinity;\n            }\n        }\n\n        for (var l = 2; l < data.length + 1; l++) {\n\n            // `SZ` originally. this is the sum of the values seen thus\n            // far when calculating variance.\n            var sum = 0,\n                // `ZSQ` originally. the sum of squares of values seen\n                // thus far\n                sum_squares = 0,\n                // `WT` originally. This is the number of\n                w = 0,\n                // `IV` originally\n                i4 = 0;\n\n            // in several instances, you could say `Math.pow(x, 2)`\n            // instead of `x * x`, but this is slower in some browsers\n            // introduces an unnecessary concept.\n            for (var m = 1; m < l + 1; m++) {\n\n                // `III` originally\n                var lower_class_limit = l - m + 1,\n                    val = data[lower_class_limit - 1];\n\n                // here we're estimating variance for each potential classing\n                // of the data, for each potential number of classes. `w`\n                // is the number of data points considered so far.\n                w++;\n\n                // increase the current sum and sum-of-squares\n                sum += val;\n                sum_squares += val * val;\n\n                // the variance at this point in the sequence is the difference\n                // between the sum of squares and the total x 2, over the number\n                // of samples.\n                variance = sum_squares - (sum * sum) / w;\n\n                i4 = lower_class_limit - 1;\n\n                if (i4 !== 0) {\n                    for (j = 2; j < n_classes + 1; j++) {\n                        // if adding this element to an existing class\n                        // will increase its variance beyond the limit, break\n                        // the class at this point, setting the `lower_class_limit`\n                        // at this point.\n                        if (variance_combinations[l][j] >=\n                            (variance + variance_combinations[i4][j - 1])) {\n                            lower_class_limits[l][j] = lower_class_limit;\n                            variance_combinations[l][j] = variance +\n                                variance_combinations[i4][j - 1];\n                        }\n                    }\n                }\n            }\n\n            lower_class_limits[l][1] = 1;\n            variance_combinations[l][1] = variance;\n        }\n\n        // return the two matrices. for just providing breaks, only\n        // `lower_class_limits` is needed, but variances can be useful to\n        // evaluate goodness of fit.\n        return {\n            lower_class_limits: lower_class_limits,\n            variance_combinations: variance_combinations\n        };\n    }\n\n    // ## Pull Breaks Values for Jenks\n    //\n    // the second part of the jenks recipe: take the calculated matrices\n    // and derive an array of n breaks.\n    function jenksBreaks(data, lower_class_limits, n_classes) {\n\n        var k = data.length - 1,\n            kclass = [],\n            countNum = n_classes;\n\n        // the calculation of classes will never include the upper and\n        // lower bounds, so we need to explicitly set them\n        kclass[n_classes] = data[data.length - 1];\n        kclass[0] = data[0];\n\n        // the lower_class_limits matrix is used as indices into itself\n        // here: the `k` variable is reused in each iteration.\n        while (countNum > 1) {\n            kclass[countNum - 1] = data[lower_class_limits[k][countNum] - 2];\n            k = lower_class_limits[k][countNum] - 1;\n            countNum--;\n        }\n\n        return kclass;\n    }\n\n    // # [Jenks natural breaks optimization](http://en.wikipedia.org/wiki/Jenks_natural_breaks_optimization)\n    //\n    // Implementations: [1](http://danieljlewis.org/files/2010/06/Jenks.pdf) (python),\n    // [2](https://github.com/vvoovv/djeo-jenks/blob/master/main.js) (buggy),\n    // [3](https://github.com/simogeo/geostats/blob/master/lib/geostats.js#L407) (works)\n    //\n    // Depends on `jenksBreaks()` and `jenksMatrices()`\n    function jenks(data, n_classes) {\n\n        if (n_classes > data.length) return null;\n\n        // sort data in numerical order, since this is expected\n        // by the matrices function\n        data = data.slice().sort(function (a, b) { return a - b; });\n\n        // get our basic matrices\n        var matrices = jenksMatrices(data, n_classes),\n            // we only need lower class limits here\n            lower_class_limits = matrices.lower_class_limits;\n\n        // extract n_classes out of the computed matrices\n        return jenksBreaks(data, lower_class_limits, n_classes);\n\n    }\n\n    // # [Skewness](http://en.wikipedia.org/wiki/Skewness)\n    //\n    // A measure of the extent to which a probability distribution of a\n    // real-valued random variable \"leans\" to one side of the mean.\n    // The skewness value can be positive or negative, or even undefined.\n    //\n    // Implementation is based on the adjusted Fisher-Pearson standardized\n    // moment coefficient, which is the version found in Excel and several\n    // statistical packages including Minitab, SAS and SPSS.\n    //\n    // Depends on `sum_nth_power_deviations()` and `sample_standard_deviation`\n    function sample_skewness(x) {\n        // The skewness of less than three arguments is null\n        if (x.length < 3) return null;\n\n        var n = x.length,\n            cubed_s = Math.pow(sample_standard_deviation(x), 3),\n            sum_cubed_deviations = sum_nth_power_deviations(x, 3);\n\n        return n * sum_cubed_deviations / ((n - 1) * (n - 2) * cubed_s);\n    }\n\n    // # Standard Normal Table\n    // A standard normal table, also called the unit normal table or Z table,\n    // is a mathematical table for the values of Φ (phi), which are the values of\n    // the cumulative distribution function of the normal distribution.\n    // It is used to find the probability that a statistic is observed below,\n    // above, or between values on the standard normal distribution, and by\n    // extension, any normal distribution.\n    //\n    // The probabilities are taken from http://en.wikipedia.org/wiki/Standard_normal_table\n    // The table used is the cumulative, and not cumulative from 0 to mean\n    // (even though the latter has 5 digits precision, instead of 4).\n    var standard_normal_table = [\n        /*  z      0.00    0.01    0.02    0.03    0.04    0.05    0.06    0.07    0.08    0.09 */\n        /* 0.0 */\n        0.5000, 0.5040, 0.5080, 0.5120, 0.5160, 0.5199, 0.5239, 0.5279, 0.5319, 0.5359,\n        /* 0.1 */\n        0.5398, 0.5438, 0.5478, 0.5517, 0.5557, 0.5596, 0.5636, 0.5675, 0.5714, 0.5753,\n        /* 0.2 */\n        0.5793, 0.5832, 0.5871, 0.5910, 0.5948, 0.5987, 0.6026, 0.6064, 0.6103, 0.6141,\n        /* 0.3 */\n        0.6179, 0.6217, 0.6255, 0.6293, 0.6331, 0.6368, 0.6406, 0.6443, 0.6480, 0.6517,\n        /* 0.4 */\n        0.6554, 0.6591, 0.6628, 0.6664, 0.6700, 0.6736, 0.6772, 0.6808, 0.6844, 0.6879,\n        /* 0.5 */\n        0.6915, 0.6950, 0.6985, 0.7019, 0.7054, 0.7088, 0.7123, 0.7157, 0.7190, 0.7224,\n        /* 0.6 */\n        0.7257, 0.7291, 0.7324, 0.7357, 0.7389, 0.7422, 0.7454, 0.7486, 0.7517, 0.7549,\n        /* 0.7 */\n        0.7580, 0.7611, 0.7642, 0.7673, 0.7704, 0.7734, 0.7764, 0.7794, 0.7823, 0.7852,\n        /* 0.8 */\n        0.7881, 0.7910, 0.7939, 0.7967, 0.7995, 0.8023, 0.8051, 0.8078, 0.8106, 0.8133,\n        /* 0.9 */\n        0.8159, 0.8186, 0.8212, 0.8238, 0.8264, 0.8289, 0.8315, 0.8340, 0.8365, 0.8389,\n        /* 1.0 */\n        0.8413, 0.8438, 0.8461, 0.8485, 0.8508, 0.8531, 0.8554, 0.8577, 0.8599, 0.8621,\n        /* 1.1 */\n        0.8643, 0.8665, 0.8686, 0.8708, 0.8729, 0.8749, 0.8770, 0.8790, 0.8810, 0.8830,\n        /* 1.2 */\n        0.8849, 0.8869, 0.8888, 0.8907, 0.8925, 0.8944, 0.8962, 0.8980, 0.8997, 0.9015,\n        /* 1.3 */\n        0.9032, 0.9049, 0.9066, 0.9082, 0.9099, 0.9115, 0.9131, 0.9147, 0.9162, 0.9177,\n        /* 1.4 */\n        0.9192, 0.9207, 0.9222, 0.9236, 0.9251, 0.9265, 0.9279, 0.9292, 0.9306, 0.9319,\n        /* 1.5 */\n        0.9332, 0.9345, 0.9357, 0.9370, 0.9382, 0.9394, 0.9406, 0.9418, 0.9429, 0.9441,\n        /* 1.6 */\n        0.9452, 0.9463, 0.9474, 0.9484, 0.9495, 0.9505, 0.9515, 0.9525, 0.9535, 0.9545,\n        /* 1.7 */\n        0.9554, 0.9564, 0.9573, 0.9582, 0.9591, 0.9599, 0.9608, 0.9616, 0.9625, 0.9633,\n        /* 1.8 */\n        0.9641, 0.9649, 0.9656, 0.9664, 0.9671, 0.9678, 0.9686, 0.9693, 0.9699, 0.9706,\n        /* 1.9 */\n        0.9713, 0.9719, 0.9726, 0.9732, 0.9738, 0.9744, 0.9750, 0.9756, 0.9761, 0.9767,\n        /* 2.0 */\n        0.9772, 0.9778, 0.9783, 0.9788, 0.9793, 0.9798, 0.9803, 0.9808, 0.9812, 0.9817,\n        /* 2.1 */\n        0.9821, 0.9826, 0.9830, 0.9834, 0.9838, 0.9842, 0.9846, 0.9850, 0.9854, 0.9857,\n        /* 2.2 */\n        0.9861, 0.9864, 0.9868, 0.9871, 0.9875, 0.9878, 0.9881, 0.9884, 0.9887, 0.9890,\n        /* 2.3 */\n        0.9893, 0.9896, 0.9898, 0.9901, 0.9904, 0.9906, 0.9909, 0.9911, 0.9913, 0.9916,\n        /* 2.4 */\n        0.9918, 0.9920, 0.9922, 0.9925, 0.9927, 0.9929, 0.9931, 0.9932, 0.9934, 0.9936,\n        /* 2.5 */\n        0.9938, 0.9940, 0.9941, 0.9943, 0.9945, 0.9946, 0.9948, 0.9949, 0.9951, 0.9952,\n        /* 2.6 */\n        0.9953, 0.9955, 0.9956, 0.9957, 0.9959, 0.9960, 0.9961, 0.9962, 0.9963, 0.9964,\n        /* 2.7 */\n        0.9965, 0.9966, 0.9967, 0.9968, 0.9969, 0.9970, 0.9971, 0.9972, 0.9973, 0.9974,\n        /* 2.8 */\n        0.9974, 0.9975, 0.9976, 0.9977, 0.9977, 0.9978, 0.9979, 0.9979, 0.9980, 0.9981,\n        /* 2.9 */\n        0.9981, 0.9982, 0.9982, 0.9983, 0.9984, 0.9984, 0.9985, 0.9985, 0.9986, 0.9986,\n        /* 3.0 */\n        0.9987, 0.9987, 0.9987, 0.9988, 0.9988, 0.9989, 0.9989, 0.9989, 0.9990, 0.9990\n    ];\n\n    // # [Cumulative Standard Normal Probability](http://en.wikipedia.org/wiki/Standard_normal_table)\n    //\n    // Since probability tables cannot be\n    // printed for every normal distribution, as there are an infinite variety\n    // of normal distributions, it is common practice to convert a normal to a\n    // standard normal and then use the standard normal table to find probabilities\n    function cumulative_std_normal_probability(z) {\n\n        // Calculate the position of this value.\n        var absZ = Math.abs(z),\n            // Each row begins with a different\n            // significant digit: 0.5, 0.6, 0.7, and so on. So the row is simply\n            // this value's significant digit: 0.567 will be in row 0, so row=0,\n            // 0.643 will be in row 1, so row=10.\n            row = Math.floor(absZ * 10),\n            column = 10 * (Math.floor(absZ * 100) / 10 - Math.floor(absZ * 100 / 10)),\n            index = Math.min((row * 10) + column, standard_normal_table.length - 1);\n\n        // The index we calculate must be in the table as a positive value,\n        // but we still pay attention to whether the input is positive\n        // or negative, and flip the output value as a last step.\n        if (z >= 0) {\n            return standard_normal_table[index];\n        } else {\n            // due to floating-point arithmetic, values in the table with\n            // 4 significant figures can nevertheless end up as repeating\n            // fractions when they're computed here.\n            return +(1 - standard_normal_table[index]).toFixed(4);\n        }\n    }\n\n    // # [Z-Score, or Standard Score](http://en.wikipedia.org/wiki/Standard_score)\n    //\n    // The standard score is the number of standard deviations an observation\n    // or datum is above or below the mean. Thus, a positive standard score\n    // represents a datum above the mean, while a negative standard score\n    // represents a datum below the mean. It is a dimensionless quantity\n    // obtained by subtracting the population mean from an individual raw\n    // score and then dividing the difference by the population standard\n    // deviation.\n    //\n    // The z-score is only defined if one knows the population parameters;\n    // if one only has a sample set, then the analogous computation with\n    // sample mean and sample standard deviation yields the\n    // Student's t-statistic.\n    function z_score(x, mean, standard_deviation) {\n        return (x - mean) / standard_deviation;\n    }\n\n    // We use `ε`, epsilon, as a stopping criterion when we want to iterate\n    // until we're \"close enough\".\n    var epsilon = 0.0001;\n\n    // # [Factorial](https://en.wikipedia.org/wiki/Factorial)\n    //\n    // A factorial, usually written n!, is the product of all positive\n    // integers less than or equal to n. Often factorial is implemented\n    // recursively, but this iterative approach is significantly faster\n    // and simpler.\n    function factorial(n) {\n\n        // factorial is mathematically undefined for negative numbers\n        if (n < 0 ) { return null; }\n\n        // typically you'll expand the factorial function going down, like\n        // 5! = 5 * 4 * 3 * 2 * 1. This is going in the opposite direction,\n        // counting from 2 up to the number in question, and since anything\n        // multiplied by 1 is itself, the loop only needs to start at 2.\n        var accumulator = 1;\n        for (var i = 2; i <= n; i++) {\n            // for each number up to and including the number `n`, multiply\n            // the accumulator my that number.\n            accumulator *= i;\n        }\n        return accumulator;\n    }\n\n    // # Bernoulli Distribution\n    //\n    // The [Bernoulli distribution](http://en.wikipedia.org/wiki/Bernoulli_distribution)\n    // is the probability discrete\n    // distribution of a random variable which takes value 1 with success\n    // probability `p` and value 0 with failure\n    // probability `q` = 1 - `p`. It can be used, for example, to represent the\n    // toss of a coin, where \"1\" is defined to mean \"heads\" and \"0\" is defined\n    // to mean \"tails\" (or vice versa). It is\n    // a special case of a Binomial Distribution\n    // where `n` = 1.\n    function bernoulli_distribution(p) {\n        // Check that `p` is a valid probability (0 ≤ p ≤ 1)\n        if (p < 0 || p > 1 ) { return null; }\n\n        return binomial_distribution(1, p);\n    }\n\n    // # Binomial Distribution\n    //\n    // The [Binomial Distribution](http://en.wikipedia.org/wiki/Binomial_distribution) is the discrete probability\n    // distribution of the number of successes in a sequence of n independent yes/no experiments, each of which yields\n    // success with probability `probability`. Such a success/failure experiment is also called a Bernoulli experiment or\n    // Bernoulli trial; when trials = 1, the Binomial Distribution is a Bernoulli Distribution.\n    function binomial_distribution(trials, probability) {\n        // Check that `p` is a valid probability (0 ≤ p ≤ 1),\n        // that `n` is an integer, strictly positive.\n        if (probability < 0 || probability > 1 ||\n            trials <= 0 || trials % 1 !== 0) {\n            return null;\n        }\n\n        // a [probability mass function](https://en.wikipedia.org/wiki/Probability_mass_function)\n        function probability_mass(x, trials, probability) {\n            return factorial(trials) /\n                (factorial(x) * factorial(trials - x)) *\n                (Math.pow(probability, x) * Math.pow(1 - probability, trials - x));\n        }\n\n        // We initialize `x`, the random variable, and `accumulator`, an accumulator\n        // for the cumulative distribution function to 0. `distribution_functions`\n        // is the object we'll return with the `probability_of_x` and the\n        // `cumulative_probability_of_x`, as well as the calculated mean &\n        // variance. We iterate until the `cumulative_probability_of_x` is\n        // within `epsilon` of 1.0.\n        var x = 0,\n            cumulative_probability = 0,\n            cells = {};\n\n        // This algorithm iterates through each potential outcome,\n        // until the `cumulative_probability` is very close to 1, at\n        // which point we've defined the vast majority of outcomes\n        do {\n            cells[x] = probability_mass(x, trials, probability);\n            cumulative_probability += cells[x];\n            x++;\n        // when the cumulative_probability is nearly 1, we've calculated\n        // the useful range of this distribution\n        } while (cumulative_probability < 1 - epsilon);\n\n        return cells;\n    }\n\n    // # Poisson Distribution\n    //\n    // The [Poisson Distribution](http://en.wikipedia.org/wiki/Poisson_distribution)\n    // is a discrete probability distribution that expresses the probability\n    // of a given number of events occurring in a fixed interval of time\n    // and/or space if these events occur with a known average rate and\n    // independently of the time since the last event.\n    //\n    // The Poisson Distribution is characterized by the strictly positive\n    // mean arrival or occurrence rate, `λ`.\n    function poisson_distribution(lambda) {\n        // Check that lambda is strictly positive\n        if (lambda <= 0) { return null; }\n\n        // our current place in the distribution\n        var x = 0,\n            // and we keep track of the current cumulative probability, in\n            // order to know when to stop calculating chances.\n            cumulative_probability = 0,\n            // the calculated cells to be returned\n            cells = {};\n\n        // a [probability mass function](https://en.wikipedia.org/wiki/Probability_mass_function)\n        function probability_mass(x, lambda) {\n            return (Math.pow(Math.E, -lambda) * Math.pow(lambda, x)) /\n                factorial(x);\n        }\n\n        // This algorithm iterates through each potential outcome,\n        // until the `cumulative_probability` is very close to 1, at\n        // which point we've defined the vast majority of outcomes\n        do {\n            cells[x] = probability_mass(x, lambda);\n            cumulative_probability += cells[x];\n            x++;\n        // when the cumulative_probability is nearly 1, we've calculated\n        // the useful range of this distribution\n        } while (cumulative_probability < 1 - epsilon);\n\n        return cells;\n    }\n\n    // # Percentage Points of the χ2 (Chi-Squared) Distribution\n    // The [χ2 (Chi-Squared) Distribution](http://en.wikipedia.org/wiki/Chi-squared_distribution) is used in the common\n    // chi-squared tests for goodness of fit of an observed distribution to a theoretical one, the independence of two\n    // criteria of classification of qualitative data, and in confidence interval estimation for a population standard\n    // deviation of a normal distribution from a sample standard deviation.\n    //\n    // Values from Appendix 1, Table III of William W. Hines & Douglas C. Montgomery, \"Probability and Statistics in\n    // Engineering and Management Science\", Wiley (1980).\n    var chi_squared_distribution_table = {\n        1: { 0.995:  0.00, 0.99:  0.00, 0.975:  0.00, 0.95:  0.00, 0.9:  0.02, 0.5:  0.45, 0.1:  2.71, 0.05:  3.84, 0.025:  5.02, 0.01:  6.63, 0.005:  7.88 },\n        2: { 0.995:  0.01, 0.99:  0.02, 0.975:  0.05, 0.95:  0.10, 0.9:  0.21, 0.5:  1.39, 0.1:  4.61, 0.05:  5.99, 0.025:  7.38, 0.01:  9.21, 0.005: 10.60 },\n        3: { 0.995:  0.07, 0.99:  0.11, 0.975:  0.22, 0.95:  0.35, 0.9:  0.58, 0.5:  2.37, 0.1:  6.25, 0.05:  7.81, 0.025:  9.35, 0.01: 11.34, 0.005: 12.84 },\n        4: { 0.995:  0.21, 0.99:  0.30, 0.975:  0.48, 0.95:  0.71, 0.9:  1.06, 0.5:  3.36, 0.1:  7.78, 0.05:  9.49, 0.025: 11.14, 0.01: 13.28, 0.005: 14.86 },\n        5: { 0.995:  0.41, 0.99:  0.55, 0.975:  0.83, 0.95:  1.15, 0.9:  1.61, 0.5:  4.35, 0.1:  9.24, 0.05: 11.07, 0.025: 12.83, 0.01: 15.09, 0.005: 16.75 },\n        6: { 0.995:  0.68, 0.99:  0.87, 0.975:  1.24, 0.95:  1.64, 0.9:  2.20, 0.5:  5.35, 0.1: 10.65, 0.05: 12.59, 0.025: 14.45, 0.01: 16.81, 0.005: 18.55 },\n        7: { 0.995:  0.99, 0.99:  1.25, 0.975:  1.69, 0.95:  2.17, 0.9:  2.83, 0.5:  6.35, 0.1: 12.02, 0.05: 14.07, 0.025: 16.01, 0.01: 18.48, 0.005: 20.28 },\n        8: { 0.995:  1.34, 0.99:  1.65, 0.975:  2.18, 0.95:  2.73, 0.9:  3.49, 0.5:  7.34, 0.1: 13.36, 0.05: 15.51, 0.025: 17.53, 0.01: 20.09, 0.005: 21.96 },\n        9: { 0.995:  1.73, 0.99:  2.09, 0.975:  2.70, 0.95:  3.33, 0.9:  4.17, 0.5:  8.34, 0.1: 14.68, 0.05: 16.92, 0.025: 19.02, 0.01: 21.67, 0.005: 23.59 },\n        10: { 0.995:  2.16, 0.99:  2.56, 0.975:  3.25, 0.95:  3.94, 0.9:  4.87, 0.5:  9.34, 0.1: 15.99, 0.05: 18.31, 0.025: 20.48, 0.01: 23.21, 0.005: 25.19 },\n        11: { 0.995:  2.60, 0.99:  3.05, 0.975:  3.82, 0.95:  4.57, 0.9:  5.58, 0.5: 10.34, 0.1: 17.28, 0.05: 19.68, 0.025: 21.92, 0.01: 24.72, 0.005: 26.76 },\n        12: { 0.995:  3.07, 0.99:  3.57, 0.975:  4.40, 0.95:  5.23, 0.9:  6.30, 0.5: 11.34, 0.1: 18.55, 0.05: 21.03, 0.025: 23.34, 0.01: 26.22, 0.005: 28.30 },\n        13: { 0.995:  3.57, 0.99:  4.11, 0.975:  5.01, 0.95:  5.89, 0.9:  7.04, 0.5: 12.34, 0.1: 19.81, 0.05: 22.36, 0.025: 24.74, 0.01: 27.69, 0.005: 29.82 },\n        14: { 0.995:  4.07, 0.99:  4.66, 0.975:  5.63, 0.95:  6.57, 0.9:  7.79, 0.5: 13.34, 0.1: 21.06, 0.05: 23.68, 0.025: 26.12, 0.01: 29.14, 0.005: 31.32 },\n        15: { 0.995:  4.60, 0.99:  5.23, 0.975:  6.27, 0.95:  7.26, 0.9:  8.55, 0.5: 14.34, 0.1: 22.31, 0.05: 25.00, 0.025: 27.49, 0.01: 30.58, 0.005: 32.80 },\n        16: { 0.995:  5.14, 0.99:  5.81, 0.975:  6.91, 0.95:  7.96, 0.9:  9.31, 0.5: 15.34, 0.1: 23.54, 0.05: 26.30, 0.025: 28.85, 0.01: 32.00, 0.005: 34.27 },\n        17: { 0.995:  5.70, 0.99:  6.41, 0.975:  7.56, 0.95:  8.67, 0.9: 10.09, 0.5: 16.34, 0.1: 24.77, 0.05: 27.59, 0.025: 30.19, 0.01: 33.41, 0.005: 35.72 },\n        18: { 0.995:  6.26, 0.99:  7.01, 0.975:  8.23, 0.95:  9.39, 0.9: 10.87, 0.5: 17.34, 0.1: 25.99, 0.05: 28.87, 0.025: 31.53, 0.01: 34.81, 0.005: 37.16 },\n        19: { 0.995:  6.84, 0.99:  7.63, 0.975:  8.91, 0.95: 10.12, 0.9: 11.65, 0.5: 18.34, 0.1: 27.20, 0.05: 30.14, 0.025: 32.85, 0.01: 36.19, 0.005: 38.58 },\n        20: { 0.995:  7.43, 0.99:  8.26, 0.975:  9.59, 0.95: 10.85, 0.9: 12.44, 0.5: 19.34, 0.1: 28.41, 0.05: 31.41, 0.025: 34.17, 0.01: 37.57, 0.005: 40.00 },\n        21: { 0.995:  8.03, 0.99:  8.90, 0.975: 10.28, 0.95: 11.59, 0.9: 13.24, 0.5: 20.34, 0.1: 29.62, 0.05: 32.67, 0.025: 35.48, 0.01: 38.93, 0.005: 41.40 },\n        22: { 0.995:  8.64, 0.99:  9.54, 0.975: 10.98, 0.95: 12.34, 0.9: 14.04, 0.5: 21.34, 0.1: 30.81, 0.05: 33.92, 0.025: 36.78, 0.01: 40.29, 0.005: 42.80 },\n        23: { 0.995:  9.26, 0.99: 10.20, 0.975: 11.69, 0.95: 13.09, 0.9: 14.85, 0.5: 22.34, 0.1: 32.01, 0.05: 35.17, 0.025: 38.08, 0.01: 41.64, 0.005: 44.18 },\n        24: { 0.995:  9.89, 0.99: 10.86, 0.975: 12.40, 0.95: 13.85, 0.9: 15.66, 0.5: 23.34, 0.1: 33.20, 0.05: 36.42, 0.025: 39.36, 0.01: 42.98, 0.005: 45.56 },\n        25: { 0.995: 10.52, 0.99: 11.52, 0.975: 13.12, 0.95: 14.61, 0.9: 16.47, 0.5: 24.34, 0.1: 34.28, 0.05: 37.65, 0.025: 40.65, 0.01: 44.31, 0.005: 46.93 },\n        26: { 0.995: 11.16, 0.99: 12.20, 0.975: 13.84, 0.95: 15.38, 0.9: 17.29, 0.5: 25.34, 0.1: 35.56, 0.05: 38.89, 0.025: 41.92, 0.01: 45.64, 0.005: 48.29 },\n        27: { 0.995: 11.81, 0.99: 12.88, 0.975: 14.57, 0.95: 16.15, 0.9: 18.11, 0.5: 26.34, 0.1: 36.74, 0.05: 40.11, 0.025: 43.19, 0.01: 46.96, 0.005: 49.65 },\n        28: { 0.995: 12.46, 0.99: 13.57, 0.975: 15.31, 0.95: 16.93, 0.9: 18.94, 0.5: 27.34, 0.1: 37.92, 0.05: 41.34, 0.025: 44.46, 0.01: 48.28, 0.005: 50.99 },\n        29: { 0.995: 13.12, 0.99: 14.26, 0.975: 16.05, 0.95: 17.71, 0.9: 19.77, 0.5: 28.34, 0.1: 39.09, 0.05: 42.56, 0.025: 45.72, 0.01: 49.59, 0.005: 52.34 },\n        30: { 0.995: 13.79, 0.99: 14.95, 0.975: 16.79, 0.95: 18.49, 0.9: 20.60, 0.5: 29.34, 0.1: 40.26, 0.05: 43.77, 0.025: 46.98, 0.01: 50.89, 0.005: 53.67 },\n        40: { 0.995: 20.71, 0.99: 22.16, 0.975: 24.43, 0.95: 26.51, 0.9: 29.05, 0.5: 39.34, 0.1: 51.81, 0.05: 55.76, 0.025: 59.34, 0.01: 63.69, 0.005: 66.77 },\n        50: { 0.995: 27.99, 0.99: 29.71, 0.975: 32.36, 0.95: 34.76, 0.9: 37.69, 0.5: 49.33, 0.1: 63.17, 0.05: 67.50, 0.025: 71.42, 0.01: 76.15, 0.005: 79.49 },\n        60: { 0.995: 35.53, 0.99: 37.48, 0.975: 40.48, 0.95: 43.19, 0.9: 46.46, 0.5: 59.33, 0.1: 74.40, 0.05: 79.08, 0.025: 83.30, 0.01: 88.38, 0.005: 91.95 },\n        70: { 0.995: 43.28, 0.99: 45.44, 0.975: 48.76, 0.95: 51.74, 0.9: 55.33, 0.5: 69.33, 0.1: 85.53, 0.05: 90.53, 0.025: 95.02, 0.01: 100.42, 0.005: 104.22 },\n        80: { 0.995: 51.17, 0.99: 53.54, 0.975: 57.15, 0.95: 60.39, 0.9: 64.28, 0.5: 79.33, 0.1: 96.58, 0.05: 101.88, 0.025: 106.63, 0.01: 112.33, 0.005: 116.32 },\n        90: { 0.995: 59.20, 0.99: 61.75, 0.975: 65.65, 0.95: 69.13, 0.9: 73.29, 0.5: 89.33, 0.1: 107.57, 0.05: 113.14, 0.025: 118.14, 0.01: 124.12, 0.005: 128.30 },\n        100: { 0.995: 67.33, 0.99: 70.06, 0.975: 74.22, 0.95: 77.93, 0.9: 82.36, 0.5: 99.33, 0.1: 118.50, 0.05: 124.34, 0.025: 129.56, 0.01: 135.81, 0.005: 140.17 }\n    };\n\n    // # χ2 (Chi-Squared) Goodness-of-Fit Test\n    //\n    // The [χ2 (Chi-Squared) Goodness-of-Fit Test](http://en.wikipedia.org/wiki/Goodness_of_fit#Pearson.27s_chi-squared_test)\n    // uses a measure of goodness of fit which is the sum of differences between observed and expected outcome frequencies\n    // (that is, counts of observations), each squared and divided by the number of observations expected given the\n    // hypothesized distribution. The resulting χ2 statistic, `chi_squared`, can be compared to the chi-squared distribution\n    // to determine the goodness of fit. In order to determine the degrees of freedom of the chi-squared distribution, one\n    // takes the total number of observed frequencies and subtracts the number of estimated parameters. The test statistic\n    // follows, approximately, a chi-square distribution with (k − c) degrees of freedom where `k` is the number of non-empty\n    // cells and `c` is the number of estimated parameters for the distribution.\n    function chi_squared_goodness_of_fit(data, distribution_type, significance) {\n        // Estimate from the sample data, a weighted mean.\n        var input_mean = mean(data),\n            // Calculated value of the χ2 statistic.\n            chi_squared = 0,\n            // Degrees of freedom, calculated as (number of class intervals -\n            // number of hypothesized distribution parameters estimated - 1)\n            degrees_of_freedom,\n            // Number of hypothesized distribution parameters estimated, expected to be supplied in the distribution test.\n            // Lose one degree of freedom for estimating `lambda` from the sample data.\n            c = 1,\n            // The hypothesized distribution.\n            // Generate the hypothesized distribution.\n            hypothesized_distribution = distribution_type(input_mean),\n            observed_frequencies = [],\n            expected_frequencies = [],\n            k;\n\n        // Create an array holding a histogram from the sample data, of\n        // the form `{ value: numberOfOcurrences }`\n        for (var i = 0; i < data.length; i++) {\n            if (observed_frequencies[data[i]] === undefined) {\n                observed_frequencies[data[i]] = 0;\n            }\n            observed_frequencies[data[i]]++;\n        }\n\n        // The histogram we created might be sparse - there might be gaps\n        // between values. So we iterate through the histogram, making\n        // sure that instead of undefined, gaps have 0 values.\n        for (i = 0; i < observed_frequencies.length; i++) {\n            if (observed_frequencies[i] === undefined) {\n                observed_frequencies[i] = 0;\n            }\n        }\n\n        // Create an array holding a histogram of expected data given the\n        // sample size and hypothesized distribution.\n        for (k in hypothesized_distribution) {\n            if (k in observed_frequencies) {\n                expected_frequencies[k] = hypothesized_distribution[k] * data.length;\n            }\n        }\n\n        // Working backward through the expected frequencies, collapse classes\n        // if less than three observations are expected for a class.\n        // This transformation is applied to the observed frequencies as well.\n        for (k = expected_frequencies.length - 1; k >= 0; k--) {\n            if (expected_frequencies[k] < 3) {\n                expected_frequencies[k - 1] += expected_frequencies[k];\n                expected_frequencies.pop();\n\n                observed_frequencies[k - 1] += observed_frequencies[k];\n                observed_frequencies.pop();\n            }\n        }\n\n        // Iterate through the squared differences between observed & expected\n        // frequencies, accumulating the `chi_squared` statistic.\n        for (k = 0; k < observed_frequencies.length; k++) {\n            chi_squared += Math.pow(\n                observed_frequencies[k] - expected_frequencies[k], 2) /\n                expected_frequencies[k];\n        }\n\n        // Calculate degrees of freedom for this test and look it up in the\n        // `chi_squared_distribution_table` in order to\n        // accept or reject the goodness-of-fit of the hypothesized distribution.\n        degrees_of_freedom = observed_frequencies.length - c - 1;\n        return chi_squared_distribution_table[degrees_of_freedom][significance] < chi_squared;\n    }\n\n    // # Mixin\n    //\n    // Mixin simple_statistics to a single Array instance if provided\n    // or the Array native object if not. This is an optional\n    // feature that lets you treat simple_statistics as a native feature\n    // of Javascript.\n    function mixin(array) {\n        var support = !!(Object.defineProperty && Object.defineProperties);\n        if (!support) throw new Error('without defineProperty, simple-statistics cannot be mixed in');\n\n        // only methods which work on basic arrays in a single step\n        // are supported\n        var arrayMethods = ['median', 'standard_deviation', 'sum',\n            'sample_skewness',\n            'mean', 'min', 'max', 'quantile', 'geometric_mean',\n            'harmonic_mean'];\n\n        // create a closure with a method name so that a reference\n        // like `arrayMethods[i]` doesn't follow the loop increment\n        function wrap(method) {\n            return function() {\n                // cast any arguments into an array, since they're\n                // natively objects\n                var args = Array.prototype.slice.apply(arguments);\n                // make the first argument the array itself\n                args.unshift(this);\n                // return the result of the ss method\n                return ss[method].apply(ss, args);\n            };\n        }\n\n        // select object to extend\n        var extending;\n        if (array) {\n            // create a shallow copy of the array so that our internal\n            // operations do not change it by reference\n            extending = array.slice();\n        } else {\n            extending = Array.prototype;\n        }\n\n        // for each array function, define a function that gets\n        // the array as the first argument.\n        // We use [defineProperty](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/defineProperty)\n        // because it allows these properties to be non-enumerable:\n        // `for (var in x)` loops will not run into problems with this\n        // implementation.\n        for (var i = 0; i < arrayMethods.length; i++) {\n            Object.defineProperty(extending, arrayMethods[i], {\n                value: wrap(arrayMethods[i]),\n                configurable: true,\n                enumerable: false,\n                writable: true\n            });\n        }\n\n        return extending;\n    }\n\n    ss.linear_regression = linear_regression;\n    ss.standard_deviation = standard_deviation;\n    ss.r_squared = r_squared;\n    ss.median = median;\n    ss.mean = mean;\n    ss.mode = mode;\n    ss.min = min;\n    ss.max = max;\n    ss.sum = sum;\n    ss.quantile = quantile;\n    ss.quantile_sorted = quantile_sorted;\n    ss.iqr = iqr;\n    ss.mad = mad;\n\n    ss.sample_covariance = sample_covariance;\n    ss.sample_correlation = sample_correlation;\n    ss.sample_variance = sample_variance;\n    ss.sample_standard_deviation = sample_standard_deviation;\n    ss.sample_skewness = sample_skewness;\n\n    ss.geometric_mean = geometric_mean;\n    ss.harmonic_mean = harmonic_mean;\n    ss.variance = variance;\n    ss.t_test = t_test;\n    ss.t_test_two_sample = t_test_two_sample;\n\n    // jenks\n    ss.jenksMatrices = jenksMatrices;\n    ss.jenksBreaks = jenksBreaks;\n    ss.jenks = jenks;\n\n    ss.bayesian = bayesian;\n\n    // Distribution-related methods\n    ss.epsilon = epsilon; // We make ε available to the test suite.\n    ss.factorial = factorial;\n    ss.bernoulli_distribution = bernoulli_distribution;\n    ss.binomial_distribution = binomial_distribution;\n    ss.poisson_distribution = poisson_distribution;\n    ss.chi_squared_goodness_of_fit = chi_squared_goodness_of_fit;\n\n    // Normal distribution\n    ss.z_score = z_score;\n    ss.cumulative_std_normal_probability = cumulative_std_normal_probability;\n    ss.standard_normal_table = standard_normal_table;\n\n    // Alias this into its common name\n    ss.average = mean;\n    ss.interquartile_range = iqr;\n    ss.mixin = mixin;\n    ss.median_absolute_deviation = mad;\n\n})(this);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./bower_components/simple-statistics/src/simple_statistics.js\n ** module id = 5\n ** module chunks = 0\n **/","'use strict';\n\n// Generated by CoffeeScript 1.6.2\n/**\n * @license\n *\n * chroma.js - JavaScript library for color conversions\n * \n * Copyright (c) 2011-2013, Gregor Aisch\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * \n * 1. Redistributions of source code must retain the above copyright notice, this\n * list of conditions and the following disclaimer.\n * \n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n * \n * 3. The name Gregor Aisch may not be used to endorse or promote products\n * derived from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\n(function() {\n  var Color, K, PITHIRD, TWOPI, X, Y, Z, bezier, brewer, chroma, clip_rgb, colors, cos, css2rgb, hex2rgb, hsi2rgb, hsl2rgb, hsv2rgb, lab2lch, lab2rgb, lab_xyz, lch2lab, lch2rgb, limit, luminance, luminance_x, rgb2hex, rgb2hsi, rgb2hsl, rgb2hsv, rgb2lab, rgb2lch, rgb_xyz, root, type, unpack, xyz_lab, xyz_rgb, _ref;\n\n  chroma = function(x, y, z, m) {\n    return new Color(x, y, z, m);\n  };\n\n  if ((typeof module !== \"undefined\" && module !== null) && (module.exports != null)) {\n    module.exports = chroma;\n  }\n\n  if (typeof define === 'function' && define.amd) {\n    define([], function() {\n      return chroma;\n    });\n  } else {\n    root = typeof exports !== \"undefined\" && exports !== null ? exports : this;\n    root.chroma = chroma;\n  }\n\n  chroma.color = function(x, y, z, m) {\n    return new Color(x, y, z, m);\n  };\n\n  chroma.hsl = function(h, s, l, a) {\n    return new Color(h, s, l, a, 'hsl');\n  };\n\n  chroma.hsv = function(h, s, v, a) {\n    return new Color(h, s, v, a, 'hsv');\n  };\n\n  chroma.rgb = function(r, g, b, a) {\n    return new Color(r, g, b, a, 'rgb');\n  };\n\n  chroma.hex = function(x) {\n    return new Color(x);\n  };\n\n  chroma.css = function(x) {\n    return new Color(x);\n  };\n\n  chroma.lab = function(l, a, b) {\n    return new Color(l, a, b, 'lab');\n  };\n\n  chroma.lch = function(l, c, h) {\n    return new Color(l, c, h, 'lch');\n  };\n\n  chroma.hsi = function(h, s, i) {\n    return new Color(h, s, i, 'hsi');\n  };\n\n  chroma.gl = function(r, g, b, a) {\n    return new Color(r * 255, g * 255, b * 255, a, 'gl');\n  };\n\n  chroma.interpolate = function(a, b, f, m) {\n    if ((a == null) || (b == null)) {\n      return '#000';\n    }\n    if (type(a) === 'string') {\n      a = new Color(a);\n    }\n    if (type(b) === 'string') {\n      b = new Color(b);\n    }\n    return a.interpolate(f, b, m);\n  };\n\n  chroma.mix = chroma.interpolate;\n\n  chroma.contrast = function(a, b) {\n    var l1, l2;\n\n    if (type(a) === 'string') {\n      a = new Color(a);\n    }\n    if (type(b) === 'string') {\n      b = new Color(b);\n    }\n    l1 = a.luminance();\n    l2 = b.luminance();\n    if (l1 > l2) {\n      return (l1 + 0.05) / (l2 + 0.05);\n    } else {\n      return (l2 + 0.05) / (l1 + 0.05);\n    }\n  };\n\n  chroma.luminance = function(color) {\n    return chroma(color).luminance();\n  };\n\n  chroma._Color = Color;\n\n  /**\n      chroma.js\n  \n      Copyright (c) 2011-2013, Gregor Aisch\n      All rights reserved.\n  \n      Redistribution and use in source and binary forms, with or without\n      modification, are permitted provided that the following conditions are met:\n  \n      * Redistributions of source code must retain the above copyright notice, this\n        list of conditions and the following disclaimer.\n  \n      * Redistributions in binary form must reproduce the above copyright notice,\n        this list of conditions and the following disclaimer in the documentation\n        and/or other materials provided with the distribution.\n  \n      * The name Gregor Aisch may not be used to endorse or promote products\n        derived from this software without specific prior written permission.\n  \n      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n      DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n      INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n      BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n      DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n      OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n      NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n      EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n  \n      @source: https://github.com/gka/chroma.js\n  */\n\n\n  Color = (function() {\n    function Color() {\n      var a, arg, args, m, me, me_rgb, x, y, z, _i, _len, _ref, _ref1, _ref2, _ref3;\n\n      me = this;\n      args = [];\n      for (_i = 0, _len = arguments.length; _i < _len; _i++) {\n        arg = arguments[_i];\n        if (arg != null) {\n          args.push(arg);\n        }\n      }\n      if (args.length === 0) {\n        _ref = [255, 0, 255, 1, 'rgb'], x = _ref[0], y = _ref[1], z = _ref[2], a = _ref[3], m = _ref[4];\n      } else if (type(args[0]) === \"array\") {\n        if (args[0].length === 3) {\n          _ref1 = args[0], x = _ref1[0], y = _ref1[1], z = _ref1[2];\n          a = 1;\n        } else if (args[0].length === 4) {\n          _ref2 = args[0], x = _ref2[0], y = _ref2[1], z = _ref2[2], a = _ref2[3];\n        } else {\n          throw 'unknown input argument';\n        }\n        m = args[1];\n      } else if (type(args[0]) === \"string\") {\n        x = args[0];\n        m = 'hex';\n      } else if (type(args[0]) === \"object\") {\n        _ref3 = args[0]._rgb, x = _ref3[0], y = _ref3[1], z = _ref3[2], a = _ref3[3];\n        m = 'rgb';\n      } else if (args.length >= 3) {\n        x = args[0];\n        y = args[1];\n        z = args[2];\n      }\n      if (args.length === 3) {\n        m = 'rgb';\n        a = 1;\n      } else if (args.length === 4) {\n        if (type(args[3]) === \"string\") {\n          m = args[3];\n          a = 1;\n        } else if (type(args[3]) === \"number\") {\n          m = 'rgb';\n          a = args[3];\n        }\n      } else if (args.length === 5) {\n        a = args[3];\n        m = args[4];\n      }\n      if (a == null) {\n        a = 1;\n      }\n      if (m === 'rgb') {\n        me._rgb = [x, y, z, a];\n      } else if (m === 'gl') {\n        me._rgb = [x * 255, y * 255, z * 255, a];\n      } else if (m === 'hsl') {\n        me._rgb = hsl2rgb(x, y, z);\n        me._rgb[3] = a;\n      } else if (m === 'hsv') {\n        me._rgb = hsv2rgb(x, y, z);\n        me._rgb[3] = a;\n      } else if (m === 'hex') {\n        me._rgb = hex2rgb(x);\n      } else if (m === 'lab') {\n        me._rgb = lab2rgb(x, y, z);\n        me._rgb[3] = a;\n      } else if (m === 'lch') {\n        me._rgb = lch2rgb(x, y, z);\n        me._rgb[3] = a;\n      } else if (m === 'hsi') {\n        me._rgb = hsi2rgb(x, y, z);\n        me._rgb[3] = a;\n      }\n      me_rgb = clip_rgb(me._rgb);\n    }\n\n    Color.prototype.rgb = function() {\n      return this._rgb.slice(0, 3);\n    };\n\n    Color.prototype.rgba = function() {\n      return this._rgb;\n    };\n\n    Color.prototype.hex = function() {\n      return rgb2hex(this._rgb);\n    };\n\n    Color.prototype.toString = function() {\n      return this.name();\n    };\n\n    Color.prototype.hsl = function() {\n      return rgb2hsl(this._rgb);\n    };\n\n    Color.prototype.hsv = function() {\n      return rgb2hsv(this._rgb);\n    };\n\n    Color.prototype.lab = function() {\n      return rgb2lab(this._rgb);\n    };\n\n    Color.prototype.lch = function() {\n      return rgb2lch(this._rgb);\n    };\n\n    Color.prototype.hsi = function() {\n      return rgb2hsi(this._rgb);\n    };\n\n    Color.prototype.gl = function() {\n      return [this._rgb[0] / 255, this._rgb[1] / 255, this._rgb[2] / 255, this._rgb[3]];\n    };\n\n    Color.prototype.luminance = function() {\n      return luminance(this._rgb);\n    };\n\n    Color.prototype.name = function() {\n      var h, k;\n\n      h = this.hex();\n      for (k in chroma.colors) {\n        if (h === chroma.colors[k]) {\n          return k;\n        }\n      }\n      return h;\n    };\n\n    Color.prototype.alpha = function(alpha) {\n      if (arguments.length) {\n        this._rgb[3] = alpha;\n        return this;\n      }\n      return this._rgb[3];\n    };\n\n    Color.prototype.css = function(mode) {\n      var hsl, me, rgb, rnd;\n\n      if (mode == null) {\n        mode = 'rgb';\n      }\n      me = this;\n      rgb = me._rgb;\n      if (mode.length === 3 && rgb[3] < 1) {\n        mode += 'a';\n      }\n      if (mode === 'rgb') {\n        return mode + '(' + rgb.slice(0, 3).join(',') + ')';\n      } else if (mode === 'rgba') {\n        return mode + '(' + rgb.join(',') + ')';\n      } else if (mode === 'hsl' || mode === 'hsla') {\n        hsl = me.hsl();\n        rnd = function(a) {\n          return Math.round(a * 100) / 100;\n        };\n        hsl[0] = rnd(hsl[0]);\n        hsl[1] = rnd(hsl[1] * 100) + '%';\n        hsl[2] = rnd(hsl[2] * 100) + '%';\n        if (mode.length === 4) {\n          hsl[3] = rgb[3];\n        }\n        return mode + '(' + hsl.join(',') + ')';\n      }\n    };\n\n    Color.prototype.interpolate = function(f, col, m) {\n      /*\n      interpolates between colors\n      f = 0 --> me\n      f = 1 --> col\n      */\n\n      var dh, hue, hue0, hue1, lbv, lbv0, lbv1, me, res, sat, sat0, sat1, xyz0, xyz1;\n\n      me = this;\n      if (m == null) {\n        m = 'rgb';\n      }\n      if (type(col) === \"string\") {\n        col = new Color(col);\n      }\n      if (m === 'hsl' || m === 'hsv' || m === 'lch' || m === 'hsi') {\n        if (m === 'hsl') {\n          xyz0 = me.hsl();\n          xyz1 = col.hsl();\n        } else if (m === 'hsv') {\n          xyz0 = me.hsv();\n          xyz1 = col.hsv();\n        } else if (m === 'hsi') {\n          xyz0 = me.hsi();\n          xyz1 = col.hsi();\n        } else if (m === 'lch') {\n          xyz0 = me.lch();\n          xyz1 = col.lch();\n        }\n        if (m.substr(0, 1) === 'h') {\n          hue0 = xyz0[0], sat0 = xyz0[1], lbv0 = xyz0[2];\n          hue1 = xyz1[0], sat1 = xyz1[1], lbv1 = xyz1[2];\n        } else {\n          lbv0 = xyz0[0], sat0 = xyz0[1], hue0 = xyz0[2];\n          lbv1 = xyz1[0], sat1 = xyz1[1], hue1 = xyz1[2];\n        }\n        if (!isNaN(hue0) && !isNaN(hue1)) {\n          if (hue1 > hue0 && hue1 - hue0 > 180) {\n            dh = hue1 - (hue0 + 360);\n          } else if (hue1 < hue0 && hue0 - hue1 > 180) {\n            dh = hue1 + 360 - hue0;\n          } else {\n            dh = hue1 - hue0;\n          }\n          hue = hue0 + f * dh;\n        } else if (!isNaN(hue0)) {\n          hue = hue0;\n          if (lbv1 === 1 || lbv1 === 0) {\n            sat = sat0;\n          }\n        } else if (!isNaN(hue1)) {\n          hue = hue1;\n          if (lbv0 === 1 || lbv0 === 0) {\n            sat = sat1;\n          }\n        } else {\n          hue = Number.NaN;\n        }\n        if (sat == null) {\n          sat = sat0 + f * (sat1 - sat0);\n        }\n        lbv = lbv0 + f * (lbv1 - lbv0);\n        if (m.substr(0, 1) === 'h') {\n          res = new Color(hue, sat, lbv, m);\n        } else {\n          res = new Color(lbv, sat, hue, m);\n        }\n      } else if (m === 'rgb') {\n        xyz0 = me._rgb;\n        xyz1 = col._rgb;\n        res = new Color(xyz0[0] + f * (xyz1[0] - xyz0[0]), xyz0[1] + f * (xyz1[1] - xyz0[1]), xyz0[2] + f * (xyz1[2] - xyz0[2]), m);\n      } else if (m === 'lab') {\n        xyz0 = me.lab();\n        xyz1 = col.lab();\n        res = new Color(xyz0[0] + f * (xyz1[0] - xyz0[0]), xyz0[1] + f * (xyz1[1] - xyz0[1]), xyz0[2] + f * (xyz1[2] - xyz0[2]), m);\n      } else {\n        throw \"color mode \" + m + \" is not supported\";\n      }\n      res.alpha(me.alpha() + f * (col.alpha() - me.alpha()));\n      return res;\n    };\n\n    Color.prototype.premultiply = function() {\n      var a, rgb;\n\n      rgb = this.rgb();\n      a = this.alpha();\n      return chroma(rgb[0] * a, rgb[1] * a, rgb[2] * a, a);\n    };\n\n    Color.prototype.darken = function(amount) {\n      var lch, me;\n\n      if (amount == null) {\n        amount = 20;\n      }\n      me = this;\n      lch = me.lch();\n      lch[0] -= amount;\n      return chroma.lch(lch).alpha(me.alpha());\n    };\n\n    Color.prototype.darker = function(amount) {\n      return this.darken(amount);\n    };\n\n    Color.prototype.brighten = function(amount) {\n      if (amount == null) {\n        amount = 20;\n      }\n      return this.darken(-amount);\n    };\n\n    Color.prototype.brighter = function(amount) {\n      return this.brighten(amount);\n    };\n\n    Color.prototype.saturate = function(amount) {\n      var lch, me;\n\n      if (amount == null) {\n        amount = 20;\n      }\n      me = this;\n      lch = me.lch();\n      lch[1] += amount;\n      return chroma.lch(lch).alpha(me.alpha());\n    };\n\n    Color.prototype.desaturate = function(amount) {\n      if (amount == null) {\n        amount = 20;\n      }\n      return this.saturate(-amount);\n    };\n\n    return Color;\n\n  })();\n\n  clip_rgb = function(rgb) {\n    var i;\n\n    for (i in rgb) {\n      if (i < 3) {\n        if (rgb[i] < 0) {\n          rgb[i] = 0;\n        }\n        if (rgb[i] > 255) {\n          rgb[i] = 255;\n        }\n      } else if (i === 3) {\n        if (rgb[i] < 0) {\n          rgb[i] = 0;\n        }\n        if (rgb[i] > 1) {\n          rgb[i] = 1;\n        }\n      }\n    }\n    return rgb;\n  };\n\n  css2rgb = function(css) {\n    var hsl, i, m, rgb, _i, _j, _k, _l;\n\n    if ((chroma.colors != null) && chroma.colors[css]) {\n      return hex2rgb(chroma.colors[css]);\n    }\n    if (m = css.match(/rgb\\(\\s*(\\-?\\d+),\\s*(\\-?\\d+)\\s*,\\s*(\\-?\\d+)\\s*\\)/)) {\n      rgb = m.slice(1, 4);\n      for (i = _i = 0; _i <= 2; i = ++_i) {\n        rgb[i] = +rgb[i];\n      }\n      rgb[3] = 1;\n    } else if (m = css.match(/rgba\\(\\s*(\\-?\\d+),\\s*(\\-?\\d+)\\s*,\\s*(\\-?\\d+)\\s*,\\s*([01]|[01]?\\.\\d+)\\)/)) {\n      rgb = m.slice(1, 5);\n      for (i = _j = 0; _j <= 3; i = ++_j) {\n        rgb[i] = +rgb[i];\n      }\n    } else if (m = css.match(/rgb\\(\\s*(\\-?\\d+(?:\\.\\d+)?)%,\\s*(\\-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(\\-?\\d+(?:\\.\\d+)?)%\\s*\\)/)) {\n      rgb = m.slice(1, 4);\n      for (i = _k = 0; _k <= 2; i = ++_k) {\n        rgb[i] = Math.round(rgb[i] * 2.55);\n      }\n      rgb[3] = 1;\n    } else if (m = css.match(/rgba\\(\\s*(\\-?\\d+(?:\\.\\d+)?)%,\\s*(\\-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(\\-?\\d+(?:\\.\\d+)?)%\\s*,\\s*([01]|[01]?\\.\\d+)\\)/)) {\n      rgb = m.slice(1, 5);\n      for (i = _l = 0; _l <= 2; i = ++_l) {\n        rgb[i] = Math.round(rgb[i] * 2.55);\n      }\n      rgb[3] = +rgb[3];\n    } else if (m = css.match(/hsl\\(\\s*(\\-?\\d+(?:\\.\\d+)?),\\s*(\\-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(\\-?\\d+(?:\\.\\d+)?)%\\s*\\)/)) {\n      hsl = m.slice(1, 4);\n      hsl[1] *= 0.01;\n      hsl[2] *= 0.01;\n      rgb = hsl2rgb(hsl);\n      rgb[3] = 1;\n    } else if (m = css.match(/hsla\\(\\s*(\\-?\\d+(?:\\.\\d+)?),\\s*(\\-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(\\-?\\d+(?:\\.\\d+)?)%\\s*,\\s*([01]|[01]?\\.\\d+)\\)/)) {\n      hsl = m.slice(1, 4);\n      hsl[1] *= 0.01;\n      hsl[2] *= 0.01;\n      rgb = hsl2rgb(hsl);\n      rgb[3] = +m[4];\n    }\n    return rgb;\n  };\n\n  hex2rgb = function(hex) {\n    var a, b, g, r, rgb, u;\n\n    if (hex.match(/^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/)) {\n      if (hex.length === 4 || hex.length === 7) {\n        hex = hex.substr(1);\n      }\n      if (hex.length === 3) {\n        hex = hex.split(\"\");\n        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];\n      }\n      u = parseInt(hex, 16);\n      r = u >> 16;\n      g = u >> 8 & 0xFF;\n      b = u & 0xFF;\n      return [r, g, b, 1];\n    }\n    if (hex.match(/^#?([A-Fa-f0-9]{8})$/)) {\n      if (hex.length === 9) {\n        hex = hex.substr(1);\n      }\n      u = parseInt(hex, 16);\n      r = u >> 24 & 0xFF;\n      g = u >> 16 & 0xFF;\n      b = u >> 8 & 0xFF;\n      a = u & 0xFF;\n      return [r, g, b, a];\n    }\n    if (rgb = css2rgb(hex)) {\n      return rgb;\n    }\n    throw \"unknown color: \" + hex;\n  };\n\n  hsi2rgb = function(h, s, i) {\n    /*\n    borrowed from here:\n    http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/hsi2rgb.cpp\n    */\n\n    var b, g, r, _ref;\n\n    _ref = unpack(arguments), h = _ref[0], s = _ref[1], i = _ref[2];\n    h /= 360;\n    if (h < 1 / 3) {\n      b = (1 - s) / 3;\n      r = (1 + s * cos(TWOPI * h) / cos(PITHIRD - TWOPI * h)) / 3;\n      g = 1 - (b + r);\n    } else if (h < 2 / 3) {\n      h -= 1 / 3;\n      r = (1 - s) / 3;\n      g = (1 + s * cos(TWOPI * h) / cos(PITHIRD - TWOPI * h)) / 3;\n      b = 1 - (r + g);\n    } else {\n      h -= 2 / 3;\n      g = (1 - s) / 3;\n      b = (1 + s * cos(TWOPI * h) / cos(PITHIRD - TWOPI * h)) / 3;\n      r = 1 - (g + b);\n    }\n    r = limit(i * r * 3);\n    g = limit(i * g * 3);\n    b = limit(i * b * 3);\n    return [r * 255, g * 255, b * 255];\n  };\n\n  hsl2rgb = function() {\n    var b, c, g, h, i, l, r, s, t1, t2, t3, _i, _ref, _ref1;\n\n    _ref = unpack(arguments), h = _ref[0], s = _ref[1], l = _ref[2];\n    if (s === 0) {\n      r = g = b = l * 255;\n    } else {\n      t3 = [0, 0, 0];\n      c = [0, 0, 0];\n      t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;\n      t1 = 2 * l - t2;\n      h /= 360;\n      t3[0] = h + 1 / 3;\n      t3[1] = h;\n      t3[2] = h - 1 / 3;\n      for (i = _i = 0; _i <= 2; i = ++_i) {\n        if (t3[i] < 0) {\n          t3[i] += 1;\n        }\n        if (t3[i] > 1) {\n          t3[i] -= 1;\n        }\n        if (6 * t3[i] < 1) {\n          c[i] = t1 + (t2 - t1) * 6 * t3[i];\n        } else if (2 * t3[i] < 1) {\n          c[i] = t2;\n        } else if (3 * t3[i] < 2) {\n          c[i] = t1 + (t2 - t1) * ((2 / 3) - t3[i]) * 6;\n        } else {\n          c[i] = t1;\n        }\n      }\n      _ref1 = [Math.round(c[0] * 255), Math.round(c[1] * 255), Math.round(c[2] * 255)], r = _ref1[0], g = _ref1[1], b = _ref1[2];\n    }\n    return [r, g, b];\n  };\n\n  hsv2rgb = function() {\n    var b, f, g, h, i, p, q, r, s, t, v, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;\n\n    _ref = unpack(arguments), h = _ref[0], s = _ref[1], v = _ref[2];\n    v *= 255;\n    if (s === 0) {\n      r = g = b = v;\n    } else {\n      if (h === 360) {\n        h = 0;\n      }\n      if (h > 360) {\n        h -= 360;\n      }\n      if (h < 0) {\n        h += 360;\n      }\n      h /= 60;\n      i = Math.floor(h);\n      f = h - i;\n      p = v * (1 - s);\n      q = v * (1 - s * f);\n      t = v * (1 - s * (1 - f));\n      switch (i) {\n        case 0:\n          _ref1 = [v, t, p], r = _ref1[0], g = _ref1[1], b = _ref1[2];\n          break;\n        case 1:\n          _ref2 = [q, v, p], r = _ref2[0], g = _ref2[1], b = _ref2[2];\n          break;\n        case 2:\n          _ref3 = [p, v, t], r = _ref3[0], g = _ref3[1], b = _ref3[2];\n          break;\n        case 3:\n          _ref4 = [p, q, v], r = _ref4[0], g = _ref4[1], b = _ref4[2];\n          break;\n        case 4:\n          _ref5 = [t, p, v], r = _ref5[0], g = _ref5[1], b = _ref5[2];\n          break;\n        case 5:\n          _ref6 = [v, p, q], r = _ref6[0], g = _ref6[1], b = _ref6[2];\n      }\n    }\n    r = Math.round(r);\n    g = Math.round(g);\n    b = Math.round(b);\n    return [r, g, b];\n  };\n\n  K = 18;\n\n  X = 0.950470;\n\n  Y = 1;\n\n  Z = 1.088830;\n\n  lab2lch = function() {\n    var a, b, c, h, l, _ref;\n\n    _ref = unpack(arguments), l = _ref[0], a = _ref[1], b = _ref[2];\n    c = Math.sqrt(a * a + b * b);\n    h = Math.atan2(b, a) / Math.PI * 180;\n    return [l, c, h];\n  };\n\n  lab2rgb = function(l, a, b) {\n    /*\n    adapted to match d3 implementation\n    */\n\n    var g, r, x, y, z, _ref, _ref1;\n\n    if (l !== void 0 && l.length === 3) {\n      _ref = l, l = _ref[0], a = _ref[1], b = _ref[2];\n    }\n    if (l !== void 0 && l.length === 3) {\n      _ref1 = l, l = _ref1[0], a = _ref1[1], b = _ref1[2];\n    }\n    y = (l + 16) / 116;\n    x = y + a / 500;\n    z = y - b / 200;\n    x = lab_xyz(x) * X;\n    y = lab_xyz(y) * Y;\n    z = lab_xyz(z) * Z;\n    r = xyz_rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z);\n    g = xyz_rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z);\n    b = xyz_rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z);\n    return [limit(r, 0, 255), limit(g, 0, 255), limit(b, 0, 255), 1];\n  };\n\n  lab_xyz = function(x) {\n    if (x > 0.206893034) {\n      return x * x * x;\n    } else {\n      return (x - 4 / 29) / 7.787037;\n    }\n  };\n\n  xyz_rgb = function(r) {\n    return Math.round(255 * (r <= 0.00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - 0.055));\n  };\n\n  lch2lab = function() {\n    /*\n    Convert from a qualitative parameter h and a quantitative parameter l to a 24-bit pixel. These formulas were invented by David Dalrymple to obtain maximum contrast without going out of gamut if the parameters are in the range 0-1.\n    A saturation multiplier was added by Gregor Aisch\n    */\n\n    var c, h, l, _ref;\n\n    _ref = unpack(arguments), l = _ref[0], c = _ref[1], h = _ref[2];\n    h = h * Math.PI / 180;\n    return [l, Math.cos(h) * c, Math.sin(h) * c];\n  };\n\n  lch2rgb = function(l, c, h) {\n    var L, a, b, g, r, _ref, _ref1;\n\n    _ref = lch2lab(l, c, h), L = _ref[0], a = _ref[1], b = _ref[2];\n    _ref1 = lab2rgb(L, a, b), r = _ref1[0], g = _ref1[1], b = _ref1[2];\n    return [limit(r, 0, 255), limit(g, 0, 255), limit(b, 0, 255)];\n  };\n\n  luminance = function(r, g, b) {\n    var _ref;\n\n    _ref = unpack(arguments), r = _ref[0], g = _ref[1], b = _ref[2];\n    r = luminance_x(r);\n    g = luminance_x(g);\n    b = luminance_x(b);\n    return 0.2126 * r + 0.7152 * g + 0.0722 * b;\n  };\n\n  luminance_x = function(x) {\n    x /= 255;\n    if (x <= 0.03928) {\n      return x / 12.92;\n    } else {\n      return Math.pow((x + 0.055) / 1.055, 2.4);\n    }\n  };\n\n  rgb2hex = function() {\n    var b, g, r, str, u, _ref;\n\n    _ref = unpack(arguments), r = _ref[0], g = _ref[1], b = _ref[2];\n    u = r << 16 | g << 8 | b;\n    str = \"000000\" + u.toString(16);\n    return \"#\" + str.substr(str.length - 6);\n  };\n\n  rgb2hsi = function() {\n    /*\n    borrowed from here:\n    http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/rgb2hsi.cpp\n    */\n\n    var TWOPI, b, g, h, i, min, r, s, _ref;\n\n    _ref = unpack(arguments), r = _ref[0], g = _ref[1], b = _ref[2];\n    TWOPI = Math.PI * 2;\n    r /= 255;\n    g /= 255;\n    b /= 255;\n    min = Math.min(r, g, b);\n    i = (r + g + b) / 3;\n    s = 1 - min / i;\n    if (s === 0) {\n      h = 0;\n    } else {\n      h = ((r - g) + (r - b)) / 2;\n      h /= Math.sqrt((r - g) * (r - g) + (r - b) * (g - b));\n      h = Math.acos(h);\n      if (b > g) {\n        h = TWOPI - h;\n      }\n      h /= TWOPI;\n    }\n    return [h * 360, s, i];\n  };\n\n  rgb2hsl = function(r, g, b) {\n    var h, l, max, min, s, _ref;\n\n    if (r !== void 0 && r.length >= 3) {\n      _ref = r, r = _ref[0], g = _ref[1], b = _ref[2];\n    }\n    r /= 255;\n    g /= 255;\n    b /= 255;\n    min = Math.min(r, g, b);\n    max = Math.max(r, g, b);\n    l = (max + min) / 2;\n    if (max === min) {\n      s = 0;\n      h = Number.NaN;\n    } else {\n      s = l < 0.5 ? (max - min) / (max + min) : (max - min) / (2 - max - min);\n    }\n    if (r === max) {\n      h = (g - b) / (max - min);\n    } else if (g === max) {\n      h = 2 + (b - r) / (max - min);\n    } else if (b === max) {\n      h = 4 + (r - g) / (max - min);\n    }\n    h *= 60;\n    if (h < 0) {\n      h += 360;\n    }\n    return [h, s, l];\n  };\n\n  rgb2hsv = function() {\n    var b, delta, g, h, max, min, r, s, v, _ref;\n\n    _ref = unpack(arguments), r = _ref[0], g = _ref[1], b = _ref[2];\n    min = Math.min(r, g, b);\n    max = Math.max(r, g, b);\n    delta = max - min;\n    v = max / 255.0;\n    if (max === 0) {\n      h = Number.NaN;\n      s = 0;\n    } else {\n      s = delta / max;\n      if (r === max) {\n        h = (g - b) / delta;\n      }\n      if (g === max) {\n        h = 2 + (b - r) / delta;\n      }\n      if (b === max) {\n        h = 4 + (r - g) / delta;\n      }\n      h *= 60;\n      if (h < 0) {\n        h += 360;\n      }\n    }\n    return [h, s, v];\n  };\n\n  rgb2lab = function() {\n    var b, g, r, x, y, z, _ref;\n\n    _ref = unpack(arguments), r = _ref[0], g = _ref[1], b = _ref[2];\n    r = rgb_xyz(r);\n    g = rgb_xyz(g);\n    b = rgb_xyz(b);\n    x = xyz_lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / X);\n    y = xyz_lab((0.2126729 * r + 0.7151522 * g + 0.0721750 * b) / Y);\n    z = xyz_lab((0.0193339 * r + 0.1191920 * g + 0.9503041 * b) / Z);\n    return [116 * y - 16, 500 * (x - y), 200 * (y - z)];\n  };\n\n  rgb_xyz = function(r) {\n    if ((r /= 255) <= 0.04045) {\n      return r / 12.92;\n    } else {\n      return Math.pow((r + 0.055) / 1.055, 2.4);\n    }\n  };\n\n  xyz_lab = function(x) {\n    if (x > 0.008856) {\n      return Math.pow(x, 1 / 3);\n    } else {\n      return 7.787037 * x + 4 / 29;\n    }\n  };\n\n  rgb2lch = function() {\n    var a, b, g, l, r, _ref, _ref1;\n\n    _ref = unpack(arguments), r = _ref[0], g = _ref[1], b = _ref[2];\n    _ref1 = rgb2lab(r, g, b), l = _ref1[0], a = _ref1[1], b = _ref1[2];\n    return lab2lch(l, a, b);\n  };\n\n  /*\n      chroma.js\n  \n      Copyright (c) 2011-2013, Gregor Aisch\n      All rights reserved.\n  \n      Redistribution and use in source and binary forms, with or without\n      modification, are permitted provided that the following conditions are met:\n  \n      * Redistributions of source code must retain the above copyright notice, this\n        list of conditions and the following disclaimer.\n  \n      * Redistributions in binary form must reproduce the above copyright notice,\n        this list of conditions and the following disclaimer in the documentation\n        and/or other materials provided with the distribution.\n  \n      * The name Gregor Aisch may not be used to endorse or promote products\n        derived from this software without specific prior written permission.\n  \n      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n      DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n      INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n      BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n      DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n      OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n      NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n      EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n  \n      @source: https://github.com/gka/chroma.js\n  */\n\n\n  chroma.scale = function(colors, positions) {\n    var classifyValue, f, getClass, getColor, resetCache, setColors, setDomain, tmap, _colorCache, _colors, _correctLightness, _domain, _fixed, _max, _min, _mode, _nacol, _numClasses, _out, _pos, _spread;\n\n    _mode = 'rgb';\n    _nacol = chroma('#ccc');\n    _spread = 0;\n    _fixed = false;\n    _domain = [0, 1];\n    _colors = [];\n    _out = false;\n    _pos = [];\n    _min = 0;\n    _max = 1;\n    _correctLightness = false;\n    _numClasses = 0;\n    _colorCache = {};\n    setColors = function(colors, positions) {\n      var c, col, _i, _j, _ref, _ref1, _ref2;\n\n      if (colors == null) {\n        colors = ['#ddd', '#222'];\n      }\n      if ((colors != null) && type(colors) === 'string' && (((_ref = chroma.brewer) != null ? _ref[colors] : void 0) != null)) {\n        colors = chroma.brewer[colors];\n      }\n      if (type(colors) === 'array') {\n        colors = colors.slice(0);\n        for (c = _i = 0, _ref1 = colors.length - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; c = 0 <= _ref1 ? ++_i : --_i) {\n          col = colors[c];\n          if (type(col) === \"string\") {\n            colors[c] = chroma(col);\n          }\n        }\n        if (positions != null) {\n          _pos = positions;\n        } else {\n          _pos = [];\n          for (c = _j = 0, _ref2 = colors.length - 1; 0 <= _ref2 ? _j <= _ref2 : _j >= _ref2; c = 0 <= _ref2 ? ++_j : --_j) {\n            _pos.push(c / (colors.length - 1));\n          }\n        }\n      }\n      resetCache();\n      return _colors = colors;\n    };\n    setDomain = function(domain) {\n      if (domain == null) {\n        domain = [];\n      }\n      /*\n      # use this if you want to display a limited number of data classes\n      # possible methods are \"equalinterval\", \"quantiles\", \"custom\"\n      */\n\n      _domain = domain;\n      _min = domain[0];\n      _max = domain[domain.length - 1];\n      resetCache();\n      if (domain.length === 2) {\n        return _numClasses = 0;\n      } else {\n        return _numClasses = domain.length - 1;\n      }\n    };\n    getClass = function(value) {\n      var i, n;\n\n      if (_domain != null) {\n        n = _domain.length - 1;\n        i = 0;\n        while (i < n && value >= _domain[i]) {\n          i++;\n        }\n        return i - 1;\n      }\n      return 0;\n    };\n    tmap = function(t) {\n      return t;\n    };\n    classifyValue = function(value) {\n      var i, maxc, minc, n, val;\n\n      val = value;\n      if (_domain.length > 2) {\n        n = _domain.length - 1;\n        i = getClass(value);\n        minc = _domain[0] + (_domain[1] - _domain[0]) * (0 + _spread * 0.5);\n        maxc = _domain[n - 1] + (_domain[n] - _domain[n - 1]) * (1 - _spread * 0.5);\n        val = _min + ((_domain[i] + (_domain[i + 1] - _domain[i]) * 0.5 - minc) / (maxc - minc)) * (_max - _min);\n      }\n      return val;\n    };\n    getColor = function(val, bypassMap) {\n      var c, col, f0, i, k, p, t, _i, _ref;\n\n      if (bypassMap == null) {\n        bypassMap = false;\n      }\n      if (isNaN(val)) {\n        return _nacol;\n      }\n      if (!bypassMap) {\n        if (_domain.length > 2) {\n          c = getClass(val);\n          t = c / (_numClasses - 1);\n        } else {\n          t = f0 = (val - _min) / (_max - _min);\n          t = Math.min(1, Math.max(0, t));\n        }\n      } else {\n        t = val;\n      }\n      if (!bypassMap) {\n        t = tmap(t);\n      }\n      k = Math.floor(t * 10000);\n      if (_colorCache[k]) {\n        col = _colorCache[k];\n      } else {\n        if (type(_colors) === 'array') {\n          for (i = _i = 0, _ref = _pos.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {\n            p = _pos[i];\n            if (t <= p) {\n              col = _colors[i];\n              break;\n            }\n            if (t >= p && i === _pos.length - 1) {\n              col = _colors[i];\n              break;\n            }\n            if (t > p && t < _pos[i + 1]) {\n              t = (t - p) / (_pos[i + 1] - p);\n              col = chroma.interpolate(_colors[i], _colors[i + 1], t, _mode);\n              break;\n            }\n          }\n        } else if (type(_colors) === 'function') {\n          col = _colors(t);\n        }\n        _colorCache[k] = col;\n      }\n      return col;\n    };\n    resetCache = function() {\n      return _colorCache = {};\n    };\n    setColors(colors, positions);\n    f = function(v) {\n      var c;\n\n      c = getColor(v);\n      if (_out && c[_out]) {\n        return c[_out]();\n      } else {\n        return c;\n      }\n    };\n    f.domain = function(domain, classes, mode, key) {\n      var d;\n\n      if (mode == null) {\n        mode = 'e';\n      }\n      if (!arguments.length) {\n        return _domain;\n      }\n      if (classes != null) {\n        d = chroma.analyze(domain, key);\n        if (classes === 0) {\n          domain = [d.min, d.max];\n        } else {\n          domain = chroma.limits(d, mode, classes);\n        }\n      }\n      setDomain(domain);\n      return f;\n    };\n    f.mode = function(_m) {\n      if (!arguments.length) {\n        return _mode;\n      }\n      _mode = _m;\n      resetCache();\n      return f;\n    };\n    f.range = function(colors, _pos) {\n      setColors(colors, _pos);\n      return f;\n    };\n    f.out = function(_o) {\n      _out = _o;\n      return f;\n    };\n    f.spread = function(val) {\n      if (!arguments.length) {\n        return _spread;\n      }\n      _spread = val;\n      return f;\n    };\n    f.correctLightness = function(v) {\n      if (!arguments.length) {\n        return _correctLightness;\n      }\n      _correctLightness = v;\n      resetCache();\n      if (_correctLightness) {\n        tmap = function(t) {\n          var L0, L1, L_actual, L_diff, L_ideal, max_iter, pol, t0, t1;\n\n          L0 = getColor(0, true).lab()[0];\n          L1 = getColor(1, true).lab()[0];\n          pol = L0 > L1;\n          L_actual = getColor(t, true).lab()[0];\n          L_ideal = L0 + (L1 - L0) * t;\n          L_diff = L_actual - L_ideal;\n          t0 = 0;\n          t1 = 1;\n          max_iter = 20;\n          while (Math.abs(L_diff) > 1e-2 && max_iter-- > 0) {\n            (function() {\n              if (pol) {\n                L_diff *= -1;\n              }\n              if (L_diff < 0) {\n                t0 = t;\n                t += (t1 - t) * 0.5;\n              } else {\n                t1 = t;\n                t += (t0 - t) * 0.5;\n              }\n              L_actual = getColor(t, true).lab()[0];\n              return L_diff = L_actual - L_ideal;\n            })();\n          }\n          return t;\n        };\n      } else {\n        tmap = function(t) {\n          return t;\n        };\n      }\n      return f;\n    };\n    f.colors = function(out) {\n      var i, samples, _i, _j, _len, _ref;\n\n      if (out == null) {\n        out = 'hex';\n      }\n      colors = [];\n      samples = [];\n      if (_domain.length > 2) {\n        for (i = _i = 1, _ref = _domain.length; 1 <= _ref ? _i < _ref : _i > _ref; i = 1 <= _ref ? ++_i : --_i) {\n          samples.push((_domain[i - 1] + _domain[i]) * 0.5);\n        }\n      } else {\n        samples = _domain;\n      }\n      for (_j = 0, _len = samples.length; _j < _len; _j++) {\n        i = samples[_j];\n        colors.push(f(i)[out]());\n      }\n      return colors;\n    };\n    return f;\n  };\n\n  if ((_ref = chroma.scales) == null) {\n    chroma.scales = {};\n  }\n\n  chroma.scales.cool = function() {\n    return chroma.scale([chroma.hsl(180, 1, .9), chroma.hsl(250, .7, .4)]);\n  };\n\n  chroma.scales.hot = function() {\n    return chroma.scale(['#000', '#f00', '#ff0', '#fff'], [0, .25, .75, 1]).mode('rgb');\n  };\n\n  /*\n      chroma.js\n  \n      Copyright (c) 2011-2013, Gregor Aisch\n      All rights reserved.\n  \n      Redistribution and use in source and binary forms, with or without\n      modification, are permitted provided that the following conditions are met:\n  \n      * Redistributions of source code must retain the above copyright notice, this\n        list of conditions and the following disclaimer.\n  \n      * Redistributions in binary form must reproduce the above copyright notice,\n        this list of conditions and the following disclaimer in the documentation\n        and/or other materials provided with the distribution.\n  \n      * The name Gregor Aisch may not be used to endorse or promote products\n        derived from this software without specific prior written permission.\n  \n      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n      DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n      INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n      BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n      DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n      OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n      NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n      EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n  \n      @source: https://github.com/gka/chroma.js\n  */\n\n\n  chroma.analyze = function(data, key, filter) {\n    var add, k, r, val, visit, _i, _len;\n\n    r = {\n      min: Number.MAX_VALUE,\n      max: Number.MAX_VALUE * -1,\n      sum: 0,\n      values: [],\n      count: 0\n    };\n    if (filter == null) {\n      filter = function() {\n        return true;\n      };\n    }\n    add = function(val) {\n      if ((val != null) && !isNaN(val)) {\n        r.values.push(val);\n        r.sum += val;\n        if (val < r.min) {\n          r.min = val;\n        }\n        if (val > r.max) {\n          r.max = val;\n        }\n        r.count += 1;\n      }\n    };\n    visit = function(val, k) {\n      if (filter(val, k)) {\n        if ((key != null) && type(key) === 'function') {\n          return add(key(val));\n        } else if ((key != null) && type(key) === 'string' || type(key) === 'number') {\n          return add(val[key]);\n        } else {\n          return add(val);\n        }\n      }\n    };\n    if (type(data) === 'array') {\n      for (_i = 0, _len = data.length; _i < _len; _i++) {\n        val = data[_i];\n        visit(val);\n      }\n    } else {\n      for (k in data) {\n        val = data[k];\n        visit(val, k);\n      }\n    }\n    r.domain = [r.min, r.max];\n    r.limits = function(mode, num) {\n      return chroma.limits(r, mode, num);\n    };\n    return r;\n  };\n\n  chroma.limits = function(data, mode, num) {\n    var assignments, best, centroids, cluster, clusterSizes, dist, i, j, kClusters, limits, max, max_log, min, min_log, mindist, n, nb_iters, newCentroids, p, pb, pr, repeat, sum, tmpKMeansBreaks, value, values, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9, _s, _t, _u, _v, _w;\n\n    if (mode == null) {\n      mode = 'equal';\n    }\n    if (num == null) {\n      num = 7;\n    }\n    if (data.values == null) {\n      data = chroma.analyze(data);\n    }\n    min = data.min;\n    max = data.max;\n    sum = data.sum;\n    values = data.values.sort(function(a, b) {\n      return a - b;\n    });\n    limits = [];\n    if (mode.substr(0, 1) === 'c') {\n      limits.push(min);\n      limits.push(max);\n    }\n    if (mode.substr(0, 1) === 'e') {\n      limits.push(min);\n      for (i = _i = 1, _ref1 = num - 1; 1 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 1 <= _ref1 ? ++_i : --_i) {\n        limits.push(min + (i / num) * (max - min));\n      }\n      limits.push(max);\n    } else if (mode.substr(0, 1) === 'l') {\n      if (min <= 0) {\n        throw 'Logarithmic scales are only possible for values > 0';\n      }\n      min_log = Math.LOG10E * Math.log(min);\n      max_log = Math.LOG10E * Math.log(max);\n      limits.push(min);\n      for (i = _j = 1, _ref2 = num - 1; 1 <= _ref2 ? _j <= _ref2 : _j >= _ref2; i = 1 <= _ref2 ? ++_j : --_j) {\n        limits.push(Math.pow(10, min_log + (i / num) * (max_log - min_log)));\n      }\n      limits.push(max);\n    } else if (mode.substr(0, 1) === 'q') {\n      limits.push(min);\n      for (i = _k = 1, _ref3 = num - 1; 1 <= _ref3 ? _k <= _ref3 : _k >= _ref3; i = 1 <= _ref3 ? ++_k : --_k) {\n        p = values.length * i / num;\n        pb = Math.floor(p);\n        if (pb === p) {\n          limits.push(values[pb]);\n        } else {\n          pr = p - pb;\n          limits.push(values[pb] * pr + values[pb + 1] * (1 - pr));\n        }\n      }\n      limits.push(max);\n    } else if (mode.substr(0, 1) === 'k') {\n      /*\n      implementation based on\n      http://code.google.com/p/figue/source/browse/trunk/figue.js#336\n      simplified for 1-d input values\n      */\n\n      n = values.length;\n      assignments = new Array(n);\n      clusterSizes = new Array(num);\n      repeat = true;\n      nb_iters = 0;\n      centroids = null;\n      centroids = [];\n      centroids.push(min);\n      for (i = _l = 1, _ref4 = num - 1; 1 <= _ref4 ? _l <= _ref4 : _l >= _ref4; i = 1 <= _ref4 ? ++_l : --_l) {\n        centroids.push(min + (i / num) * (max - min));\n      }\n      centroids.push(max);\n      while (repeat) {\n        for (j = _m = 0, _ref5 = num - 1; 0 <= _ref5 ? _m <= _ref5 : _m >= _ref5; j = 0 <= _ref5 ? ++_m : --_m) {\n          clusterSizes[j] = 0;\n        }\n        for (i = _n = 0, _ref6 = n - 1; 0 <= _ref6 ? _n <= _ref6 : _n >= _ref6; i = 0 <= _ref6 ? ++_n : --_n) {\n          value = values[i];\n          mindist = Number.MAX_VALUE;\n          for (j = _o = 0, _ref7 = num - 1; 0 <= _ref7 ? _o <= _ref7 : _o >= _ref7; j = 0 <= _ref7 ? ++_o : --_o) {\n            dist = Math.abs(centroids[j] - value);\n            if (dist < mindist) {\n              mindist = dist;\n              best = j;\n            }\n          }\n          clusterSizes[best]++;\n          assignments[i] = best;\n        }\n        newCentroids = new Array(num);\n        for (j = _p = 0, _ref8 = num - 1; 0 <= _ref8 ? _p <= _ref8 : _p >= _ref8; j = 0 <= _ref8 ? ++_p : --_p) {\n          newCentroids[j] = null;\n        }\n        for (i = _q = 0, _ref9 = n - 1; 0 <= _ref9 ? _q <= _ref9 : _q >= _ref9; i = 0 <= _ref9 ? ++_q : --_q) {\n          cluster = assignments[i];\n          if (newCentroids[cluster] === null) {\n            newCentroids[cluster] = values[i];\n          } else {\n            newCentroids[cluster] += values[i];\n          }\n        }\n        for (j = _r = 0, _ref10 = num - 1; 0 <= _ref10 ? _r <= _ref10 : _r >= _ref10; j = 0 <= _ref10 ? ++_r : --_r) {\n          newCentroids[j] *= 1 / clusterSizes[j];\n        }\n        repeat = false;\n        for (j = _s = 0, _ref11 = num - 1; 0 <= _ref11 ? _s <= _ref11 : _s >= _ref11; j = 0 <= _ref11 ? ++_s : --_s) {\n          if (newCentroids[j] !== centroids[i]) {\n            repeat = true;\n            break;\n          }\n        }\n        centroids = newCentroids;\n        nb_iters++;\n        if (nb_iters > 200) {\n          repeat = false;\n        }\n      }\n      kClusters = {};\n      for (j = _t = 0, _ref12 = num - 1; 0 <= _ref12 ? _t <= _ref12 : _t >= _ref12; j = 0 <= _ref12 ? ++_t : --_t) {\n        kClusters[j] = [];\n      }\n      for (i = _u = 0, _ref13 = n - 1; 0 <= _ref13 ? _u <= _ref13 : _u >= _ref13; i = 0 <= _ref13 ? ++_u : --_u) {\n        cluster = assignments[i];\n        kClusters[cluster].push(values[i]);\n      }\n      tmpKMeansBreaks = [];\n      for (j = _v = 0, _ref14 = num - 1; 0 <= _ref14 ? _v <= _ref14 : _v >= _ref14; j = 0 <= _ref14 ? ++_v : --_v) {\n        tmpKMeansBreaks.push(kClusters[j][0]);\n        tmpKMeansBreaks.push(kClusters[j][kClusters[j].length - 1]);\n      }\n      tmpKMeansBreaks = tmpKMeansBreaks.sort(function(a, b) {\n        return a - b;\n      });\n      limits.push(tmpKMeansBreaks[0]);\n      for (i = _w = 1, _ref15 = tmpKMeansBreaks.length - 1; _w <= _ref15; i = _w += 2) {\n        if (!isNaN(tmpKMeansBreaks[i])) {\n          limits.push(tmpKMeansBreaks[i]);\n        }\n      }\n    }\n    return limits;\n  };\n\n  /**\n  \tColorBrewer colors for chroma.js\n  \n  \tCopyright (c) 2002 Cynthia Brewer, Mark Harrower, and The \n  \tPennsylvania State University.\n  \n  \tLicensed under the Apache License, Version 2.0 (the \"License\"); \n  \tyou may not use this file except in compliance with the License.\n  \tYou may obtain a copy of the License at\t\n  \thttp://www.apache.org/licenses/LICENSE-2.0\n  \n  \tUnless required by applicable law or agreed to in writing, software distributed\n  \tunder the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n  \tCONDITIONS OF ANY KIND, either express or implied. See the License for the\n  \tspecific language governing permissions and limitations under the License.\n  \n      @preserve\n  */\n\n\n  chroma.brewer = brewer = {\n    OrRd: ['#fff7ec', '#fee8c8', '#fdd49e', '#fdbb84', '#fc8d59', '#ef6548', '#d7301f', '#b30000', '#7f0000'],\n    PuBu: ['#fff7fb', '#ece7f2', '#d0d1e6', '#a6bddb', '#74a9cf', '#3690c0', '#0570b0', '#045a8d', '#023858'],\n    BuPu: ['#f7fcfd', '#e0ecf4', '#bfd3e6', '#9ebcda', '#8c96c6', '#8c6bb1', '#88419d', '#810f7c', '#4d004b'],\n    Oranges: ['#fff5eb', '#fee6ce', '#fdd0a2', '#fdae6b', '#fd8d3c', '#f16913', '#d94801', '#a63603', '#7f2704'],\n    BuGn: ['#f7fcfd', '#e5f5f9', '#ccece6', '#99d8c9', '#66c2a4', '#41ae76', '#238b45', '#006d2c', '#00441b'],\n    YlOrBr: ['#ffffe5', '#fff7bc', '#fee391', '#fec44f', '#fe9929', '#ec7014', '#cc4c02', '#993404', '#662506'],\n    YlGn: ['#ffffe5', '#f7fcb9', '#d9f0a3', '#addd8e', '#78c679', '#41ab5d', '#238443', '#006837', '#004529'],\n    Reds: ['#fff5f0', '#fee0d2', '#fcbba1', '#fc9272', '#fb6a4a', '#ef3b2c', '#cb181d', '#a50f15', '#67000d'],\n    RdPu: ['#fff7f3', '#fde0dd', '#fcc5c0', '#fa9fb5', '#f768a1', '#dd3497', '#ae017e', '#7a0177', '#49006a'],\n    Greens: ['#f7fcf5', '#e5f5e0', '#c7e9c0', '#a1d99b', '#74c476', '#41ab5d', '#238b45', '#006d2c', '#00441b'],\n    YlGnBu: ['#ffffd9', '#edf8b1', '#c7e9b4', '#7fcdbb', '#41b6c4', '#1d91c0', '#225ea8', '#253494', '#081d58'],\n    Purples: ['#fcfbfd', '#efedf5', '#dadaeb', '#bcbddc', '#9e9ac8', '#807dba', '#6a51a3', '#54278f', '#3f007d'],\n    GnBu: ['#f7fcf0', '#e0f3db', '#ccebc5', '#a8ddb5', '#7bccc4', '#4eb3d3', '#2b8cbe', '#0868ac', '#084081'],\n    Greys: ['#ffffff', '#f0f0f0', '#d9d9d9', '#bdbdbd', '#969696', '#737373', '#525252', '#252525', '#000000'],\n    YlOrRd: ['#ffffcc', '#ffeda0', '#fed976', '#feb24c', '#fd8d3c', '#fc4e2a', '#e31a1c', '#bd0026', '#800026'],\n    PuRd: ['#f7f4f9', '#e7e1ef', '#d4b9da', '#c994c7', '#df65b0', '#e7298a', '#ce1256', '#980043', '#67001f'],\n    Blues: ['#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#6baed6', '#4292c6', '#2171b5', '#08519c', '#08306b'],\n    PuBuGn: ['#fff7fb', '#ece2f0', '#d0d1e6', '#a6bddb', '#67a9cf', '#3690c0', '#02818a', '#016c59', '#014636'],\n    Spectral: ['#9e0142', '#d53e4f', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#e6f598', '#abdda4', '#66c2a5', '#3288bd', '#5e4fa2'],\n    RdYlGn: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#d9ef8b', '#a6d96a', '#66bd63', '#1a9850', '#006837'],\n    RdBu: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#f7f7f7', '#d1e5f0', '#92c5de', '#4393c3', '#2166ac', '#053061'],\n    PiYG: ['#8e0152', '#c51b7d', '#de77ae', '#f1b6da', '#fde0ef', '#f7f7f7', '#e6f5d0', '#b8e186', '#7fbc41', '#4d9221', '#276419'],\n    PRGn: ['#40004b', '#762a83', '#9970ab', '#c2a5cf', '#e7d4e8', '#f7f7f7', '#d9f0d3', '#a6dba0', '#5aae61', '#1b7837', '#00441b'],\n    RdYlBu: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee090', '#ffffbf', '#e0f3f8', '#abd9e9', '#74add1', '#4575b4', '#313695'],\n    BrBG: ['#543005', '#8c510a', '#bf812d', '#dfc27d', '#f6e8c3', '#f5f5f5', '#c7eae5', '#80cdc1', '#35978f', '#01665e', '#003c30'],\n    RdGy: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#ffffff', '#e0e0e0', '#bababa', '#878787', '#4d4d4d', '#1a1a1a'],\n    PuOr: ['#7f3b08', '#b35806', '#e08214', '#fdb863', '#fee0b6', '#f7f7f7', '#d8daeb', '#b2abd2', '#8073ac', '#542788', '#2d004b'],\n    Set2: ['#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f', '#e5c494', '#b3b3b3'],\n    Accent: ['#7fc97f', '#beaed4', '#fdc086', '#ffff99', '#386cb0', '#f0027f', '#bf5b17', '#666666'],\n    Set1: ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999'],\n    Set3: ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9', '#bc80bd', '#ccebc5', '#ffed6f'],\n    Dark2: ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02', '#a6761d', '#666666'],\n    Paired: ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a', '#ffff99', '#b15928'],\n    Pastel2: ['#b3e2cd', '#fdcdac', '#cbd5e8', '#f4cae4', '#e6f5c9', '#fff2ae', '#f1e2cc', '#cccccc'],\n    Pastel1: ['#fbb4ae', '#b3cde3', '#ccebc5', '#decbe4', '#fed9a6', '#ffffcc', '#e5d8bd', '#fddaec', '#f2f2f2']\n  };\n\n  /**\n  \tX11 color names\n  \n  \thttp://www.w3.org/TR/css3-color/#svg-color\n  */\n\n\n  chroma.colors = colors = {\n    indigo: \"#4b0082\",\n    gold: \"#ffd700\",\n    hotpink: \"#ff69b4\",\n    firebrick: \"#b22222\",\n    indianred: \"#cd5c5c\",\n    yellow: \"#ffff00\",\n    mistyrose: \"#ffe4e1\",\n    darkolivegreen: \"#556b2f\",\n    olive: \"#808000\",\n    darkseagreen: \"#8fbc8f\",\n    pink: \"#ffc0cb\",\n    tomato: \"#ff6347\",\n    lightcoral: \"#f08080\",\n    orangered: \"#ff4500\",\n    navajowhite: \"#ffdead\",\n    lime: \"#00ff00\",\n    palegreen: \"#98fb98\",\n    darkslategrey: \"#2f4f4f\",\n    greenyellow: \"#adff2f\",\n    burlywood: \"#deb887\",\n    seashell: \"#fff5ee\",\n    mediumspringgreen: \"#00fa9a\",\n    fuchsia: \"#ff00ff\",\n    papayawhip: \"#ffefd5\",\n    blanchedalmond: \"#ffebcd\",\n    chartreuse: \"#7fff00\",\n    dimgray: \"#696969\",\n    black: \"#000000\",\n    peachpuff: \"#ffdab9\",\n    springgreen: \"#00ff7f\",\n    aquamarine: \"#7fffd4\",\n    white: \"#ffffff\",\n    orange: \"#ffa500\",\n    lightsalmon: \"#ffa07a\",\n    darkslategray: \"#2f4f4f\",\n    brown: \"#a52a2a\",\n    ivory: \"#fffff0\",\n    dodgerblue: \"#1e90ff\",\n    peru: \"#cd853f\",\n    lawngreen: \"#7cfc00\",\n    chocolate: \"#d2691e\",\n    crimson: \"#dc143c\",\n    forestgreen: \"#228b22\",\n    darkgrey: \"#a9a9a9\",\n    lightseagreen: \"#20b2aa\",\n    cyan: \"#00ffff\",\n    mintcream: \"#f5fffa\",\n    silver: \"#c0c0c0\",\n    antiquewhite: \"#faebd7\",\n    mediumorchid: \"#ba55d3\",\n    skyblue: \"#87ceeb\",\n    gray: \"#808080\",\n    darkturquoise: \"#00ced1\",\n    goldenrod: \"#daa520\",\n    darkgreen: \"#006400\",\n    floralwhite: \"#fffaf0\",\n    darkviolet: \"#9400d3\",\n    darkgray: \"#a9a9a9\",\n    moccasin: \"#ffe4b5\",\n    saddlebrown: \"#8b4513\",\n    grey: \"#808080\",\n    darkslateblue: \"#483d8b\",\n    lightskyblue: \"#87cefa\",\n    lightpink: \"#ffb6c1\",\n    mediumvioletred: \"#c71585\",\n    slategrey: \"#708090\",\n    red: \"#ff0000\",\n    deeppink: \"#ff1493\",\n    limegreen: \"#32cd32\",\n    darkmagenta: \"#8b008b\",\n    palegoldenrod: \"#eee8aa\",\n    plum: \"#dda0dd\",\n    turquoise: \"#40e0d0\",\n    lightgrey: \"#d3d3d3\",\n    lightgoldenrodyellow: \"#fafad2\",\n    darkgoldenrod: \"#b8860b\",\n    lavender: \"#e6e6fa\",\n    maroon: \"#800000\",\n    yellowgreen: \"#9acd32\",\n    sandybrown: \"#f4a460\",\n    thistle: \"#d8bfd8\",\n    violet: \"#ee82ee\",\n    navy: \"#000080\",\n    magenta: \"#ff00ff\",\n    dimgrey: \"#696969\",\n    tan: \"#d2b48c\",\n    rosybrown: \"#bc8f8f\",\n    olivedrab: \"#6b8e23\",\n    blue: \"#0000ff\",\n    lightblue: \"#add8e6\",\n    ghostwhite: \"#f8f8ff\",\n    honeydew: \"#f0fff0\",\n    cornflowerblue: \"#6495ed\",\n    slateblue: \"#6a5acd\",\n    linen: \"#faf0e6\",\n    darkblue: \"#00008b\",\n    powderblue: \"#b0e0e6\",\n    seagreen: \"#2e8b57\",\n    darkkhaki: \"#bdb76b\",\n    snow: \"#fffafa\",\n    sienna: \"#a0522d\",\n    mediumblue: \"#0000cd\",\n    royalblue: \"#4169e1\",\n    lightcyan: \"#e0ffff\",\n    green: \"#008000\",\n    mediumpurple: \"#9370db\",\n    midnightblue: \"#191970\",\n    cornsilk: \"#fff8dc\",\n    paleturquoise: \"#afeeee\",\n    bisque: \"#ffe4c4\",\n    slategray: \"#708090\",\n    darkcyan: \"#008b8b\",\n    khaki: \"#f0e68c\",\n    wheat: \"#f5deb3\",\n    teal: \"#008080\",\n    darkorchid: \"#9932cc\",\n    deepskyblue: \"#00bfff\",\n    salmon: \"#fa8072\",\n    darkred: \"#8b0000\",\n    steelblue: \"#4682b4\",\n    palevioletred: \"#db7093\",\n    lightslategray: \"#778899\",\n    aliceblue: \"#f0f8ff\",\n    lightslategrey: \"#778899\",\n    lightgreen: \"#90ee90\",\n    orchid: \"#da70d6\",\n    gainsboro: \"#dcdcdc\",\n    mediumseagreen: \"#3cb371\",\n    lightgray: \"#d3d3d3\",\n    mediumturquoise: \"#48d1cc\",\n    lemonchiffon: \"#fffacd\",\n    cadetblue: \"#5f9ea0\",\n    lightyellow: \"#ffffe0\",\n    lavenderblush: \"#fff0f5\",\n    coral: \"#ff7f50\",\n    purple: \"#800080\",\n    aqua: \"#00ffff\",\n    whitesmoke: \"#f5f5f5\",\n    mediumslateblue: \"#7b68ee\",\n    darkorange: \"#ff8c00\",\n    mediumaquamarine: \"#66cdaa\",\n    darksalmon: \"#e9967a\",\n    beige: \"#f5f5dc\",\n    blueviolet: \"#8a2be2\",\n    azure: \"#f0ffff\",\n    lightsteelblue: \"#b0c4de\",\n    oldlace: \"#fdf5e6\"\n  };\n\n  /*\n      chroma.js\n  \n      Copyright (c) 2011-2013, Gregor Aisch\n      All rights reserved.\n  \n      Redistribution and use in source and binary forms, with or without\n      modification, are permitted provided that the following conditions are met:\n  \n      * Redistributions of source code must retain the above copyright notice, this\n        list of conditions and the following disclaimer.\n  \n      * Redistributions in binary form must reproduce the above copyright notice,\n        this list of conditions and the following disclaimer in the documentation\n        and/or other materials provided with the distribution.\n  \n      * The name Gregor Aisch may not be used to endorse or promote products\n        derived from this software without specific prior written permission.\n  \n      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n      DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n      INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n      BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n      DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n      OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n      NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n      EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n  \n      @source: https://github.com/gka/chroma.js\n  */\n\n\n  type = (function() {\n    /*\n    for browser-safe type checking+\n    ported from jQuery's $.type\n    */\n\n    var classToType, name, _i, _len, _ref1;\n\n    classToType = {};\n    _ref1 = \"Boolean Number String Function Array Date RegExp Undefined Null\".split(\" \");\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      name = _ref1[_i];\n      classToType[\"[object \" + name + \"]\"] = name.toLowerCase();\n    }\n    return function(obj) {\n      var strType;\n\n      strType = Object.prototype.toString.call(obj);\n      return classToType[strType] || \"object\";\n    };\n  })();\n\n  limit = function(x, min, max) {\n    if (min == null) {\n      min = 0;\n    }\n    if (max == null) {\n      max = 1;\n    }\n    if (x < min) {\n      x = min;\n    }\n    if (x > max) {\n      x = max;\n    }\n    return x;\n  };\n\n  unpack = function(args) {\n    if (args.length >= 3) {\n      return args;\n    } else {\n      return args[0];\n    }\n  };\n\n  TWOPI = Math.PI * 2;\n\n  PITHIRD = Math.PI / 3;\n\n  cos = Math.cos;\n\n  /*\n  interpolates between a set of colors uzing a bezier spline\n  */\n\n\n  bezier = function(colors) {\n    var I, I0, I1, c, lab0, lab1, lab2, lab3, _ref1, _ref2, _ref3;\n\n    colors = (function() {\n      var _i, _len, _results;\n\n      _results = [];\n      for (_i = 0, _len = colors.length; _i < _len; _i++) {\n        c = colors[_i];\n        _results.push(chroma(c));\n      }\n      return _results;\n    })();\n    if (colors.length === 2) {\n      _ref1 = (function() {\n        var _i, _len, _results;\n\n        _results = [];\n        for (_i = 0, _len = colors.length; _i < _len; _i++) {\n          c = colors[_i];\n          _results.push(c.lab());\n        }\n        return _results;\n      })(), lab0 = _ref1[0], lab1 = _ref1[1];\n      I = function(t) {\n        var i, lab;\n\n        lab = (function() {\n          var _i, _results;\n\n          _results = [];\n          for (i = _i = 0; _i <= 2; i = ++_i) {\n            _results.push(lab0[i] + t * (lab1[i] - lab0[i]));\n          }\n          return _results;\n        })();\n        return chroma.lab.apply(chroma, lab);\n      };\n    } else if (colors.length === 3) {\n      _ref2 = (function() {\n        var _i, _len, _results;\n\n        _results = [];\n        for (_i = 0, _len = colors.length; _i < _len; _i++) {\n          c = colors[_i];\n          _results.push(c.lab());\n        }\n        return _results;\n      })(), lab0 = _ref2[0], lab1 = _ref2[1], lab2 = _ref2[2];\n      I = function(t) {\n        var i, lab;\n\n        lab = (function() {\n          var _i, _results;\n\n          _results = [];\n          for (i = _i = 0; _i <= 2; i = ++_i) {\n            _results.push((1 - t) * (1 - t) * lab0[i] + 2 * (1 - t) * t * lab1[i] + t * t * lab2[i]);\n          }\n          return _results;\n        })();\n        return chroma.lab.apply(chroma, lab);\n      };\n    } else if (colors.length === 4) {\n      _ref3 = (function() {\n        var _i, _len, _results;\n\n        _results = [];\n        for (_i = 0, _len = colors.length; _i < _len; _i++) {\n          c = colors[_i];\n          _results.push(c.lab());\n        }\n        return _results;\n      })(), lab0 = _ref3[0], lab1 = _ref3[1], lab2 = _ref3[2], lab3 = _ref3[3];\n      I = function(t) {\n        var i, lab;\n\n        lab = (function() {\n          var _i, _results;\n\n          _results = [];\n          for (i = _i = 0; _i <= 2; i = ++_i) {\n            _results.push((1 - t) * (1 - t) * (1 - t) * lab0[i] + 3 * (1 - t) * (1 - t) * t * lab1[i] + 3 * (1 - t) * t * t * lab2[i] + t * t * t * lab3[i]);\n          }\n          return _results;\n        })();\n        return chroma.lab.apply(chroma, lab);\n      };\n    } else if (colors.length === 5) {\n      I0 = bezier(colors.slice(0, 3));\n      I1 = bezier(colors.slice(2, 5));\n      I = function(t) {\n        if (t < 0.5) {\n          return I0(t * 2);\n        } else {\n          return I1((t - 0.5) * 2);\n        }\n      };\n    }\n    return I;\n  };\n\n  chroma.interpolate.bezier = bezier;\n\n}).call(this);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./bower_components/chroma-js/chroma.js\n ** module id = 6\n ** module chunks = 0\n **/","'use strict';\n\nmodule.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/module.js\n ** module id = 7\n ** module chunks = 0\n **/","'use strict';\n\nvar utils = require('socrata-utils');\nvar $ = require('jquery');\nvar _ = require('lodash');\n\nfunction Visualization(element, vif) {\n\n  var _defaultVIF = {\n    configuration: {\n      axisLabels: {\n        top: false,\n        right: false,\n        bottom: false,\n        left: false\n      },\n      localization: {},\n      interactive: true\n    }\n  };\n  var _vif = _.merge(_defaultVIF, vif);\n\n  utils.assertInstanceOf(element, jQuery);\n  utils.assertIsOneOfTypes(_vif.configuration.axisLabels.top, 'boolean', 'string');\n  utils.assertIsOneOfTypes(_vif.configuration.axisLabels.right, 'boolean', 'string');\n  utils.assertIsOneOfTypes(_vif.configuration.axisLabels.bottom, 'boolean', 'string');\n  utils.assertIsOneOfTypes(_vif.configuration.axisLabels.left, 'boolean', 'string');\n\n  this.element = element;\n\n  if (_vif.configuration.interactive) {\n    element.addClass('filterable');\n  }\n\n  /**\n   * Public methods\n   */\n\n  this.renderAxisLabels = function(container) {\n\n    var axisLabels = _vif.configuration.axisLabels;\n\n    var topAxisLabel = $(\n      '<div>',\n      {\n        'class': 'top-axis-label'\n      }\n    );\n\n    var rightAxisLabel = $(\n      '<div>',\n      {\n        'class': 'right-axis-label'\n      }\n    );\n\n    var bottomAxisLabel = $(\n      '<div>',\n      {\n        'class': 'bottom-axis-label'\n      }\n    );\n\n    var leftAxisLabel = $(\n      '<div>',\n      {\n        'class': 'left-axis-label'\n      }\n    );\n\n    if (axisLabels.top) {\n\n      topAxisLabel.\n        text(axisLabels.top);\n\n      container.\n        addClass('top-axis-label').\n        append(topAxisLabel);\n    }\n\n    if (axisLabels.right) {\n\n      rightAxisLabel.\n        text(axisLabels.right);\n\n      container.\n        addClass('right-axis-label').\n        append(rightAxisLabel);\n    }\n\n    if (axisLabels.bottom) {\n\n      bottomAxisLabel.\n        text(axisLabels.bottom);\n\n      container.\n        addClass('bottom-axis-label').\n        append(bottomAxisLabel);\n    }\n\n    if (axisLabels.left) {\n\n      leftAxisLabel.\n        text(axisLabels.left);\n\n      container.\n        addClass('left-axis-label').\n        append(leftAxisLabel);\n    }\n\n  };\n\n  this.getLocalization = function(key) {\n\n    var localizedString = '';\n\n    if (_.has(_vif.configuration.localization, key)) {\n      localizedString = _vif.configuration.localization[key];\n    } else {\n      _logWarning('No localized string found for key `{0}`.'.format(key));\n    }\n\n    return localizedString;\n  };\n\n  this.emitEvent = function(name, payload) {\n    this.element[0].dispatchEvent(\n      new window.CustomEvent(\n        name,\n        { detail: payload, bubbles: true }\n      )\n    );\n  };\n\n  /**\n   * Private methods\n   */\n\n  function _logWarning(message) {\n    if (window.console && window.console.warn) {\n      window.console.warn(message);\n    }\n  }\n}\n\nmodule.exports = Visualization;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/views/Visualization.js\n ** module id = 10\n ** module chunks = 0\n **/","'use strict';\n\nvar $ = require('jquery');\nvar _ = require('lodash');\nvar utils = require('socrata-utils');\nvar ss = require('simple-statistics');\nvar chroma = require('chroma-js');\n\n/**\n * Dynamic choropleth styles based on the individual dataset.\n */\nfunction ChoroplethMapUtils(constants) {\n\n  this.constants = constants;\n\n  // Default colors.\n  this.nullColor = '#ddd';\n  this.defaultSingleColor = 'teal';\n  this.defaultStrokeColor = 'white';\n  this.defaultHighlightColor = '#debb1e';\n\n  // Color classes.\n  this.negativeColorRange = ['#c6663d', '#e4eef0'];\n  this.positiveColorRange = ['#e4eef0', '#408499'];\n  this.divergingColors = ['brown', 'lightyellow', 'teal'];\n  this.qualitativeColors = ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9', '#bc80bd', '#ccebc5', '#ffed6f'];\n  this.defaultColorRange = this.positiveColorRange;\n}\n\n$.extend(ChoroplethMapUtils.prototype, {\n\n  // Data calculation\n\n  calculateDataClassBreaks: function(geojsonAggregateData, propertyName) {\n\n    var geojsonValues = this.getGeojsonValues(geojsonAggregateData, propertyName);\n    var uniqueGeojsonValues = _.uniq(geojsonValues);\n    var numberOfPossibleBreaks = uniqueGeojsonValues.length - 1;\n    var classBreaksArgs = {};\n\n    // For very small values, 'jenks' does not make sense (produces\n    // duplicate values).  Thus, use 'equalInterval' in this cases.\n    if (numberOfPossibleBreaks <= this.constants.MAXIMUM_NUMBER_OF_CLASS_BREAKS_ALLOWED) {\n      classBreaksArgs.method = 'equalInterval';\n      classBreaksArgs.numberOfClasses = uniqueGeojsonValues.length;\n    } else {\n      classBreaksArgs.method = 'jenks';\n      classBreaksArgs.numberOfClasses = this.numberOfClasses(geojsonValues);\n    }\n\n    return this.createClassBreaks({\n      method: classBreaksArgs.method,\n      data: geojsonValues,\n      numberOfClasses: classBreaksArgs.numberOfClasses\n    });\n  },\n\n  getGeojsonValues: function(geojson, attr) {\n\n    return _.reduce(geojson.features, function(data, feature) {\n\n      if (_.get(feature, 'properties', false)) {\n\n        var val = feature.properties[attr];\n\n        if (_hasValue(val)) {\n          data.push(feature.properties[attr]);\n        }\n      }\n\n      return data;\n    }, []);\n  },\n\n  oddNumbered: function(num) {\n    if (num % 2 === 0) {\n      return num - 1;\n    } else {\n      return num;\n    }\n  },\n\n  numberOfClasses: function(values) {\n\n    // Handles numberOfClasses in Jenks (implemented for _.uniq(values).length > 6)\n    var possibleBreaks = _.uniq(values).length;\n\n    if (possibleBreaks <= this.constants.MAXIMUM_NUMBER_OF_CLASS_BREAKS_ALLOWED) {\n      throw new Error('[Choropleth] Why are you calling numberOfClasses when # unique values <= {0}?'.format(this.constants.MAXIMUM_NUMBER_OF_CLASS_BREAKS_ALLOWED));\n    }\n\n    var evenPossibleBreaks = possibleBreaks - (possibleBreaks % 2);\n    var maxNumClasses = evenPossibleBreaks / 2;\n    return _.min([this.oddNumbered(maxNumClasses), 7]);\n  },\n\n  createClassBreaks: function(options) {\n    var classBreaks;\n\n    switch (options.method || 'jenks') {\n      case 'jenks':\n        options.methodParam = options.numberOfClasses || 4;\n        classBreaks = ss.jenks(options.data, options.methodParam);\n        break;\n      case 'quantile':\n        options.methodParam = options.p;\n        classBreaks = ss.quantile(options.data, options.methodParam);\n        break;\n      case 'equalInterval':\n        var minVal = _.min(options.data);\n        var maxVal = _.max(options.data);\n\n        if (minVal === maxVal) {\n          classBreaks = [minVal];\n        } else {\n          var scale = d3.scale.linear().domain([minVal, maxVal]);\n          classBreaks = scale.nice().ticks(_.min([options.numberOfClasses, 4]));\n\n          // Make sure min and max are in the classBreak ticks that d3 gives us.\n          if (classBreaks[0] > minVal) {\n            classBreaks.unshift(minVal);\n          }\n\n          if (_.last(classBreaks) < maxVal) {\n            classBreaks.push(maxVal);\n          }\n        }\n        break;\n      default:\n        throw new Error('Invalid/non-supported class breaks method {0}'.format(options.method));\n    }\n    return _.uniq(classBreaks);\n  },\n\n\n  // Style calculation\n\n  /**\n   * @param {String[]|String} colorRange A string, or an array of color strings defining the range\n   * of colors the scale should span. There are several predefined values you can use:\n   * this.divergingColors, this.qualitativeColors, this.positiveColorRange.\n   */\n  calculateColoringScale: function(colorRange, classBreaks) {\n\n    if (!_.isArray(classBreaks)) {\n      throw new Error('Cannot calculate coloring parameters with nvalid class breaks.');\n    }\n\n    if (this.qualitativeColors === colorRange) {\n      if (classBreaks.length > colorRange.length) {\n        throw new Error('Cannot calculate qualitative coloring parameters for more than {0} class breaks.'.format(this.qualitativeColors.length));\n      }\n      colorRange = this.qualitativeColors.slice(0, classBreaks.length);\n    }\n\n    if (colorRange.length === 2) {\n      colorRange = chroma.interpolate.bezier(colorRange);\n    }\n\n    return chroma.\n      scale(colorRange).\n      domain(classBreaks).\n\n      // For linear color ranges, make sure the lightness varies linearly\n      correctLightness(colorRange.length === 2).\n\n      // use LAB color space to approximate perceptual brightness\n      // See more: https://vis4.net/blog/posts/mastering-multi-hued-color-scales/\n      mode('lab');\n  },\n\n  fillColor: function(colorScale, feature) {\n\n    var unfilteredValue = _.get(feature, 'properties.{0}'.format(this.constants.UNFILTERED_GEOJSON_PROPERTY_NAME));\n    var filteredValue = _.get(feature, 'properties.{0}'.format(this.constants.FILTERED_GEOJSON_PROPERTY_NAME));\n\n    if (_.isFinite(filteredValue) && _.isFinite(unfilteredValue)) {\n      if (colorScale) {\n        return String(colorScale(filteredValue));\n      } else {\n        return 'transparent';\n      }\n    } else {\n      return this.nullColor;\n    }\n  },\n\n  strokeColor: function(colorScale, feature, highlighted) {\n\n    if (!_.has(feature, 'geometry.type')) {\n      throw new Error('Cannot calculate stroke color for undefined feature geometry type.');\n    }\n\n    if (!_.contains(['LineString', 'MultiLineString'], feature.geometry.type)) {\n      return highlighted ? this.defaultHighlightColor : this.defaultStrokeColor;\n    }\n\n    if (!_hasValue(_.get(feature, 'properties.{0}'.format(this.constants.FILTERED_GEOJSON_PROPERTY_NAME), undefined)) ||\n        !_.isFinite(feature.properties[this.constants.UNFILTERED_GEOJSON_PROPERTY_NAME])) {\n      return this.nullColor;\n    }\n\n    if (highlighted) {\n      return this.defaultHighlightColor;\n    } else if (colorScale) {\n      return this.fillColor(colorScale, feature, false);\n    } else {\n      return this.defaultStrokeColor;\n    }\n  },\n\n  strokeWidth: function(feature, highlighted) {\n\n    if (!_.has(feature, 'geometry.type')) {\n      throw new Error('Cannot calculate stroke width for undefined feature geometry type.');\n    }\n\n    switch (feature.geometry.type) {\n      case 'LineString':\n      case 'MultiLineString':\n        return 3;\n      default:\n        return (highlighted) ? 3 : 1;\n    }\n  },\n\n  getStyleFn: function(colorScale) {\n\n    var visualization = this;\n    var selectedPropertyName = this.constants.SELECTED_GEOJSON_PROPERTY_NAME;\n\n    return function(feature) {\n      var highlighted = false;\n      var opacity = colorScale ? 0.8 : 1;\n\n      if (_hasValue(_.get(feature, 'properties.{0}'.format(selectedPropertyName), undefined))) {\n        highlighted = feature.properties[selectedPropertyName];\n      }\n\n      return {\n        fillColor: visualization.fillColor(colorScale, feature, highlighted),\n        color: visualization.strokeColor(colorScale, feature, highlighted),\n        weight: visualization.strokeWidth(feature, highlighted),\n        opacity: opacity,\n        dashArray: 0,\n        fillOpacity: opacity\n      };\n    };\n  },\n\n  bigNumTickFormatter: function(val) {\n\n    // Used if ss.standard_deviation(classBreaks) > 10\n    // val = a * 10^b (a: coefficient, b: exponent);\n    if (val === 0) {\n      return 0;\n    }\n\n    var exponent = Math.floor(Math.log(Math.abs(val)) / Math.LN10);\n    var coefficient = val / Math.pow(10, exponent);\n    var isMultipleOf10 = coefficient % 10 === 0;\n    var numNonzeroDigits;\n    var formattedNum;\n\n    if (isMultipleOf10) {\n      numNonzeroDigits = coefficient.toString().length;\n      formattedNum = utils.formatNumber(val, {\n        precision: 0,\n        maxLength: _.min([numNonzeroDigits, 3])\n      });\n    } else {\n      numNonzeroDigits = coefficient.toString().length - 1;\n      formattedNum = utils.formatNumber(val, {\n        maxLength: _.min([numNonzeroDigits, 3])\n      });\n    }\n\n    return formattedNum;\n  },\n\n  /**\n   * If the values straddle 0, we want to add a break at 0\n   *\n   * @return {Number} the index at which we added 0, or -1 if we didn't.\n   * @protected\n   */\n  addZeroIfNecessary: function(classBreaks) {\n\n    var indexOfZero = _.sortedIndex(classBreaks, 0);\n\n    // Do not need to add break if it already exists.\n    if (_.inRange(indexOfZero, 1, classBreaks.length) &&\n      (classBreaks[indexOfZero] !== 0) &&\n      (classBreaks[indexOfZero - 1] !== 0)) {\n      classBreaks.splice(indexOfZero, 0, 0);\n      return indexOfZero;\n    }\n\n    return -1;\n  }\n});\n\n/**\n * A function originally from `lodash-mixins.js`\n */\nfunction _hasValue(value) {\n  return value !== null && value !== undefined;\n}\n\nmodule.exports = ChoroplethMapUtils;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/views/ChoroplethMapUtils.js\n ** module id = 11\n ** module chunks = 0\n **/","'use strict';\n\nvar $ = require('jquery');\nvar utils = require('socrata-utils');\nvar Visualization = require('./Visualization.js');\nvar _ = require('lodash');\nvar d3 = require('d3');\n\n// TODO: Figure out how to do this better (and probably not through jQuery).\n$.relativeToPx = function(rems) {\n  var $div = $(document.createElement('div')).css('width', rems).appendTo(document.body);\n  var width = $div.width();\n\n  $div.remove();\n\n  return width;\n};\n\nfunction ColumnChart(element, vif) {\n\n  _.extend(this, new Visualization(element, vif));\n\n  var self = this;\n\n  var _chartElement;\n  var _chartWrapper;\n  var _chartScroll;\n  var _chartLabels;\n\n  var _truncationMarker;\n  var _lastRenderData;\n  var _lastRenderOptions;\n\n  var _interactive = vif.configuration.interactive === true;\n\n  var _truncationMarkerSelector = '.truncation-marker';\n  var _barGroupAndLabelsSelector = '.bar-group, .labels .label .contents span, .labels .label .callout';\n  var _nonDefaultSelectedLabelSelector = '.labels .label.selected.non-default';\n\n  // TODO: Validate columns\n  var NAME_INDEX = vif.configuration.columns.name;\n  var UNFILTERED_INDEX = vif.configuration.columns.unfilteredValue;\n  var FILTERED_INDEX = vif.configuration.columns.filteredValue;\n  var SELECTED_INDEX = vif.configuration.columns.selected;\n\n  _renderTemplate(this.element);\n  _attachEvents(this.element);\n\n  /**\n   * Public methods\n   */\n\n  this.render = function(data, options) {\n    _lastRenderData = data;\n    _lastRenderOptions = options;\n    // Eventually we may only want to pass in the VIF instead of other render\n    // options as well as the VIF, but for the time being we will just treat it\n    // as another property on `options`.\n    _renderData(_chartElement, data, options);\n  };\n\n  this.renderError = function() {\n    // TODO: Some helpful error message.\n  };\n\n  this.invalidateSize = function() {\n    if (_lastRenderData && _lastRenderOptions) {\n      _renderData(_chartElement, _lastRenderData, _lastRenderOptions);\n    }\n  };\n\n  this.destroy = function() {\n    _detachEvents(this.element);\n    this.element.find('.column-chart-container').remove();\n  };\n\n  /**\n   * Private methods\n   */\n\n  function _renderTemplate(el) {\n\n    var truncationMarker = $(\n      '<div>',\n      {\n        'class': 'truncation-marker'\n      }\n    ).html('&raquo;');\n\n    var chartWrapper = $(\n      '<div>',\n      {\n        'class': 'column-chart-wrapper'\n      }\n    ).append(truncationMarker);\n\n    var chartLabels = $(\n      '<div>',\n      {\n        'class': 'labels'\n      }\n    );\n\n    var chartScroll = $(\n      '<div>',\n      {\n        'class': 'chart-scroll'\n      }\n    ).append([\n      chartWrapper,\n      chartLabels\n    ]);\n\n    var chartElement = $(\n      '<div>',\n      {\n        'class': 'column-chart'\n      }\n    ).append(chartScroll);\n\n    var chartContainer = $(\n      '<div>',\n      {\n        'class': 'column-chart-container'\n      }\n    ).append(\n      chartElement\n    );\n\n    self.renderAxisLabels(chartContainer);\n\n    // Cache element selections\n    _chartElement = chartElement;\n    _chartWrapper = chartWrapper;\n    _chartScroll = chartScroll;\n    _chartLabels = chartLabels;\n    _truncationMarker = truncationMarker;\n\n    el.append(chartContainer);\n  }\n\n  function _attachEvents(el) {\n\n    el.on(\n      'mouseenter, mousemove',\n      _barGroupAndLabelsSelector,\n      showFlyout\n    );\n\n    el.on(\n      'mouseleave',\n      _barGroupAndLabelsSelector,\n      hideFlyout\n    );\n\n    el.on(\n      'mouseenter',\n      _barGroupAndLabelsSelector,\n      addHoverClassToBarGroup\n    );\n\n    el.on(\n      'mouseleave',\n      _barGroupAndLabelsSelector,\n      removeHoverClassFromBarGroup\n    );\n\n    _chartElement.on(\n      'mouseleave',\n      removeHoverClassFromBarGroup\n    );\n\n    if (_interactive) {\n\n      el.on(\n        'click',\n        _barGroupAndLabelsSelector,\n        selectDatum\n      );\n\n      el.on(\n        'click',\n        _truncationMarkerSelector,\n        expandVisualization\n      );\n\n      // We respond to mouseup in this case because if the user clicks to\n      // clear a selection with a non-default label (i.e. not one of the first\n      // three when not expanded), then we should dismiss the highlight.\n      // (The 'non-default' class is applied to labels that wouldn't normally\n      // be drawn unless a datum is selected)\n      el.on(\n        'mouseup',\n        _nonDefaultSelectedLabelSelector,\n        removeHoverClassFromBarGroup\n      );\n    }\n  }\n\n  function _detachEvents(el) {\n\n    el.off(\n      'mouseenter, mousemove',\n      _barGroupAndLabelsSelector,\n      showFlyout\n    );\n\n    el.off(\n      'mouseleave',\n      _barGroupAndLabelsSelector,\n      hideFlyout\n    );\n\n    el.off(\n      'mouseenter',\n      _barGroupAndLabelsSelector,\n      addHoverClassToBarGroup\n    );\n\n    el.off(\n      'mouseleave',\n      _barGroupAndLabelsSelector,\n      removeHoverClassFromBarGroup\n    );\n\n    _chartElement.off(\n      'mouseleave',\n      removeHoverClassFromBarGroup\n    );\n\n    if (_interactive) {\n\n      el.off(\n        'click',\n        _barGroupAndLabelsSelector,\n        selectDatum\n      );\n\n      el.off(\n        'click',\n        _truncationMarkerSelector,\n        expandVisualization\n      );\n\n      el.off(\n        'mouseup',\n        _nonDefaultSelectedLabelSelector,\n        removeHoverClassFromBarGroup\n      );\n    }\n  }\n\n  function selectDatum(event) {\n    self.emitEvent(\n      'SOCRATA_VISUALIZATION_COLUMN_SELECTION',\n      {\n        name: d3.select(event.currentTarget).datum()[NAME_INDEX]\n      }\n    );\n  }\n\n  function expandVisualization() {\n    self.emitEvent(\n      'SOCRATA_VISUALIZATION_COLUMN_EXPANSION',\n      {\n        expanded: true\n      }\n    );\n  }\n\n  function showFlyout(event) {\n    var datum = d3.select(event.currentTarget).datum();\n    var barGroupName = _toEscapedString(datum[NAME_INDEX]);\n    var barGroupElement = _chartWrapper.\n      find('.bar-group').\n      filter(function(index, el) { return el.getAttribute('data-bar-name') === barGroupName; }).\n      find('.unfiltered').\n      get(0);\n    var unfilteredValueUnit;\n    var filteredValueUnit;\n\n    if (datum[UNFILTERED_INDEX] === 1) {\n\n      unfilteredValueUnit = (_.has(_lastRenderOptions, 'unit.one')) ?\n        _lastRenderOptions.unit.one :\n        vif.unit.one;\n\n    } else {\n\n      unfilteredValueUnit = (_.has(_lastRenderOptions, 'unit.other')) ?\n        _lastRenderOptions.unit.other :\n        vif.unit.other;\n\n    }\n\n    if (datum[FILTERED_INDEX] === 1) {\n\n      filteredValueUnit = (_.has(_lastRenderOptions, 'unit.one')) ?\n        _lastRenderOptions.unit.one :\n        vif.unit.one;\n\n    } else {\n\n      filteredValueUnit = (_.has(_lastRenderOptions, 'unit.other')) ?\n        _lastRenderOptions.unit.other :\n        vif.unit.other;\n\n    }\n\n    var payload = {\n      element: barGroupElement,\n      title: _labelValueOrPlaceholder(datum[NAME_INDEX]),\n      unfilteredValueLabel: self.getLocalization('FLYOUT_UNFILTERED_AMOUNT_LABEL'),\n      unfilteredValue: '{0} {1}'.format(\n        utils.formatNumber(datum[UNFILTERED_INDEX]),\n        unfilteredValueUnit\n      ),\n      selectedNotice: self.getLocalization('FLYOUT_SELECTED_NOTICE'),\n      selected: datum[SELECTED_INDEX]\n    };\n\n    if (_lastRenderOptions.showFiltered) {\n\n      payload.filteredValueLabel = self.getLocalization('FLYOUT_FILTERED_AMOUNT_LABEL');\n      payload.filteredValue = '{0} {1}'.format(\n        utils.formatNumber(datum[FILTERED_INDEX]),\n        filteredValueUnit\n      );\n    }\n\n    self.emitEvent(\n      'SOCRATA_VISUALIZATION_COLUMN_FLYOUT',\n      payload\n    );\n  }\n\n  function hideFlyout() {\n    self.emitEvent(\n      'SOCRATA_VISUALIZATION_COLUMN_FLYOUT',\n      null\n    );\n  }\n\n  function addHoverClassToBarGroup(event) {\n    var datum = d3.select(event.currentTarget).datum();\n    var barName = _toEscapedString(datum[NAME_INDEX]);\n\n    _chartWrapper.\n      find('.bar-group').\n      filter(function(index, el) { return el.getAttribute('data-bar-name') === barName; }).\n      addClass('highlight');\n  }\n\n  function removeHoverClassFromBarGroup() {\n    _chartWrapper.find('.bar-group').removeClass('highlight');\n  }\n\n  /**\n   * Visualization renderer and helper functions\n   */\n\n  function _renderData(el, data, options) {\n\n    // Cache dimensions and options\n    var chartWidth = el.width();\n    var chartHeight = el.height();\n    var showAllLabels = options.showAllLabels;\n    var showFiltered = options.showFiltered;\n\n    if (chartWidth <= 0 || chartHeight <= 0) {\n      if (window.console && window.console.warn) {\n        console.warn('Aborted rendering column chart: chart width or height is zero.');\n      }\n      return;\n    }\n\n    if (showAllLabels) {\n      _chartElement.addClass('show-all-labels');\n    } else {\n      _chartElement.removeClass('show-all-labels');\n    }\n\n    if (showFiltered) {\n      _chartWrapper.addClass('filtered');\n    } else {\n      _chartWrapper.removeClass('filtered');\n    }\n\n    /**\n     * Implementation begins here\n     */\n\n    var topMargin = 0; // Set to zero so .card-text could control padding b/t text & visualization\n    var bottomMargin; // Calculated based on label text length\n    var horizontalScrollbarHeight = 15; // used to keep horizontal scrollbar within .card-visualization\n    var numberOfDefaultLabels = showAllLabels ? data.length : 3;\n    var maximumBottomMargin = 140;\n    var d3Selection = d3.select(_chartWrapper.get(0));\n    // The `_.property(NAME_INDEX)` below is equivalent to `function(d) { return d[NAME_INDEX]; }`\n    var barGroupSelection = d3Selection.selectAll('.bar-group').data(data, _.property(NAME_INDEX));\n    var labelSelection = d3.select(_chartLabels[0]).selectAll('.label');\n    var chartTruncated = false;\n    var truncationMarkerWidth = _truncationMarker.width();\n    var fixedLabelWidth = 15.5;\n\n    var horizontalScaleDetails = _computeHorizontalScale(chartWidth, data, showAllLabels);\n    var horizontalScale = horizontalScaleDetails.scale;\n    chartTruncated = horizontalScaleDetails.truncated;\n    var rangeBand = Math.ceil(horizontalScale.rangeBand());\n    var chartScrollTop = _chartScroll.offset().top - el.offset().top;\n\n    // Compute chart margins\n    if (showAllLabels) {\n\n      var maxLength = _.max(data.map(function(item) {\n        // The size passed to visualLength() below relates to the width of the div.text in the updateLabels().\n        return _labelValueOrPlaceholder(item[NAME_INDEX]).visualLength('1rem');\n      }));\n      bottomMargin = Math.floor(Math.min(\n        maxLength + $.relativeToPx('1rem'),\n        $.relativeToPx(fixedLabelWidth + 1 + 'rem')\n      ) / Math.sqrt(2));\n\n      chartTruncated = false;\n\n    } else {\n\n      bottomMargin = $.relativeToPx(numberOfDefaultLabels + 1 + 'rem');\n\n      // Do not compensate for chart scrollbar if only showing 3 labels (scrollbar would not exist)\n      horizontalScrollbarHeight = 0;\n    }\n\n    // Clamp the bottom margin to a reasonable maximum since long labels are ellipsified.\n    bottomMargin = bottomMargin > maximumBottomMargin ? maximumBottomMargin : bottomMargin;\n\n    var innerHeight = Math.max(0, chartHeight - topMargin - bottomMargin - horizontalScrollbarHeight);\n\n    // If not all labels are visible, limit our vert scale computation to what's actually\n    // visible. We still render the bars outside the viewport to speed up horizontal resizes.\n    var chartDataRelevantForVerticalScale = showAllLabels ?\n      data : _.take(data, Math.ceil(chartWidth / rangeBand) + 1);\n    var verticalScale = _computeVerticalScale(innerHeight, chartDataRelevantForVerticalScale, showFiltered);\n\n    var chartLeftOffset = horizontalScale.range()[0];\n    var chartRightEdge = chartWidth - chartLeftOffset;\n\n    _chartWrapper.css('height', innerHeight + topMargin + 1);\n    _chartScroll.css({\n      'padding-top': 0,\n      'padding-bottom': bottomMargin,\n      'top': 'initial',\n      'width': chartWidth,\n      'height': innerHeight + topMargin + horizontalScrollbarHeight\n    });\n\n    var _renderTicks = function() {\n      // The `+ 3` term accounts for the border-width.\n      var tickHeight = parseInt(el.css('font-size'), 10) + 3;\n      var numberOfTicks = 3;\n      // We need to ensure that there is always a '0' tick mark, so we concat\n      // the calculated ticks with '0' and then take the unique values. This\n      // could potentially give us 4 overall tick marks, since the way that d3\n      // decides which ticks to draw is a little opaque.\n      var uniqueTickMarks = _.uniq(\n        [0].concat(verticalScale.ticks(numberOfTicks))\n      ).sort(\n        function(a, b) {\n          return a >= b;\n        }\n      );\n\n      var tickMarks = uniqueTickMarks.map(\n        function(tickValue, index) {\n\n          var tick = $('<div>', {\n            'class': tickValue === 0 ? 'tick origin' : 'tick',\n            text: utils.formatNumber(tickValue)\n          });\n          var tickTopOffset = innerHeight - verticalScale(tickValue);\n\n          // If this is the 'top' tick (which will be the last one since they\n          // are sorted ascendingly, then we want to draw the label beneath the\n          // tick instead of above it. This is mainly to match the behavior of\n          // the timeline chart, which is a little less flexible in how it\n          // chooses and renders y-scale ticks.\n          if (index === uniqueTickMarks.length - 1) {\n            tickTopOffset += tickHeight;\n            tick.addClass('below');\n          }\n\n          tick.attr('style', 'top: {0}px'.format(tickTopOffset));\n\n          return tick;\n        }\n      );\n      var ticksStyle = 'top: {0}px; width: {1}px; height: {2}px;'.format(\n        chartScrollTop + topMargin,\n        chartWidth,\n        innerHeight + topMargin\n      );\n\n      return $('<div>', {\n        'class': 'ticks',\n        style: ticksStyle\n      }).append(tickMarks);\n    };\n\n    var updateLabels = function(label) {\n\n      /**\n       * Labels come in two sets of column names:\n       *\n       * - Default labels. If showAllLabels is true, this consists of one\n       *   label per bar. Otherwise, only 3 labels are shown.\n       *\n       * - Selected labels. Contains the names of columns which are selected.\n       */\n      var defaultLabelData = _.take(data, numberOfDefaultLabels);\n      var selectedLabelData = data.filter(\n        function(datum) {\n          return datum[SELECTED_INDEX] === true;\n        }\n      );\n      var labelData = _.union(defaultLabelData, selectedLabelData);\n      var labelOrientationsByIndex = [];\n\n      if (selectedLabelData.length > 1) {\n        throw new Error('Multiple selected labels not supported yet in column chart');\n      }\n\n      function isOnlyInSelected(datum, index) {\n        return datum[SELECTED_INDEX] && index >= numberOfDefaultLabels;\n      }\n\n      function preComputeLabelOrientation(datum, index) {\n\n        var leftHanded = false;\n\n        if (!showAllLabels) {\n\n          var labelWidth = $(this).find('.contents').width();\n          var proposedLeftOfText = horizontalScale(datum[NAME_INDEX]);\n\n          var rangeMagnitude = (chartRightEdge - chartLeftOffset);\n\n          var spaceAvailableOnLeft = (proposedLeftOfText - chartLeftOffset);\n\n          var spaceAvailableOnRight = rangeMagnitude -\n            proposedLeftOfText -\n            chartLeftOffset;\n\n          var spaceRemainingOnRight = (spaceAvailableOnRight - labelWidth);\n\n          leftHanded = (spaceRemainingOnRight <= 10) &&\n            (spaceAvailableOnLeft > spaceAvailableOnRight);\n        }\n\n        labelOrientationsByIndex[index] = leftHanded;\n\n      }\n\n      function labelOrientationLeft(datum, index) {\n        return labelOrientationsByIndex[index];\n      }\n\n      function labelOrientationRight(datum, index) {\n        return !labelOrientationsByIndex[index];\n      }\n\n      var centering = chartLeftOffset - rangeBand / 2;\n      var verticalPositionOfSelectedLabelRem = 2;\n      var labelMargin = showAllLabels ? 0 : 0.75;\n      var selectedLabelMargin = -0.4;\n      // The `_.property(NAME_INDEX)` below is equivalent to `function(d) { return d[NAME_INDEX]; }`\n      var labelDivSelection = label.data(labelData, _.property(NAME_INDEX));\n\n      var labelDivSelectionEnter = labelDivSelection.\n        enter().\n        append('div').\n        classed('label', true).\n        classed('non-default', isOnlyInSelected).\n        attr('data-bar-name', function(d) {\n          return _toEscapedString(_labelValueOrPlaceholder(d[NAME_INDEX]));\n        });\n\n      // For new labels, add a contents div containing a span for the filter icon,\n      // a span for the label text, and a span for the clear filter icon.\n      // The filter icon and close icon are toggled via CSS classes.\n      var labelText = labelDivSelectionEnter.append('div').classed('contents', true);\n      labelText.append('span').classed('icon-filter', true);\n      labelText.append('span').classed('text', true);\n      labelText.append('span').classed('icon-close', true);\n\n      labelDivSelectionEnter.append('div').classed('callout', true);\n\n      // Bind data to child spans\n      labelDivSelection.each(function(d) {\n        d3.select(this).selectAll('span').datum(d);\n      });\n\n      labelDivSelection.\n        select('.contents').\n          style('top', function(d, i) {\n            var topOffset;\n\n            if (showAllLabels) {\n              topOffset = 0;\n            } else if (isOnlyInSelected(d, i)) {\n              topOffset = verticalPositionOfSelectedLabelRem;\n            } else {\n              topOffset = defaultLabelData.length - 0.5 - Math.min(i, numberOfDefaultLabels - 1);\n            }\n\n            return '{0}rem'.format(topOffset);\n          }).\n          classed('undefined', function(d) {\n            return _labelValueOrPlaceholder(d[NAME_INDEX]) === self.getLocalization('NO_VALUE');\n          }).\n          select('.text').\n            text(function(d) {\n              return _labelValueOrPlaceholder(d[NAME_INDEX]);\n            });\n\n      labelDivSelection.\n        select('.callout').\n          style('height', function(d, i) {\n\n            // Slanted labels have auto height.\n            if (showAllLabels) {\n              return '';\n            } else {\n              if (isOnlyInSelected(d, i)) {\n                return verticalPositionOfSelectedLabelRem + 'rem';\n              } else {\n                return (defaultLabelData.length - i - (d[SELECTED_INDEX] ? 0.75 : 0)) + 'rem';\n              }\n            }\n          }).\n\n          // Hide the '.callout' if there is no room for it\n          style('display', function(d) {\n            var scaleOffset = horizontalScale(d[NAME_INDEX]) - centering - 1;\n\n            if (scaleOffset >= chartWidth) {\n              return 'none';\n            }\n          });\n\n      // For each label, re-compute their orientations and set all left and\n      // right offsets.\n      labelDivSelection.\n        classed('orientation-left', false).\n        classed('orientation-right', false).\n        each(preComputeLabelOrientation).\n        classed('orientation-left', labelOrientationLeft).\n        classed('orientation-right', labelOrientationRight).\n        classed('dim', function(d) {\n          return selectedLabelData.length > 0 && !d[SELECTED_INDEX];\n        }).\n        classed('selected', function(d) { return d[SELECTED_INDEX]; }).\n        each(function(d) {\n\n          var $this = $(this);\n\n          // Save references to all d3 selections.\n          var labelSel = d3.select(this);\n          var labelContentSelection = labelSel.select('.contents');\n          var labelTextSelection = labelContentSelection.select('.text');\n\n          var labelLeftOffset = 0;\n          var labelRightOffset = 0;\n          var labelContentLeftOffset;\n          var labelContentRightOffset;\n          var isSelected = d[SELECTED_INDEX];\n          var scaleOffset = horizontalScale(d[NAME_INDEX]) - centering - 1;\n          var noRoomForCallout = scaleOffset >= chartWidth && isSelected && !showAllLabels;\n          var leftOriented = $this.hasClass('orientation-left');\n          var labelIconPadding = 30;\n          var halfWidthOfCloseIcon;\n          var textMaxWidth;\n          var labelSelectionStyle;\n          var desiredLabelContentLeft = '';\n          var desiredLabelContentRight = '';\n          var labelTextSelectionStyle;\n\n          // Logic for setting label and content offsets and text max widths.\n          if (showAllLabels || !isSelected) {\n            labelLeftOffset = scaleOffset;\n            labelContentLeftOffset = labelMargin;\n          } else if (leftOriented) {\n            halfWidthOfCloseIcon = ($this.find('.icon-close').width() / 2) - 1;\n            labelRightOffset = chartRightEdge - scaleOffset;\n            labelContentRightOffset = -halfWidthOfCloseIcon;\n            textMaxWidth = scaleOffset - labelIconPadding;\n          } else {\n            labelLeftOffset = scaleOffset;\n            labelContentLeftOffset = selectedLabelMargin;\n            textMaxWidth = chartWidth - scaleOffset - labelIconPadding;\n          }\n\n          if (!isSelected && !showAllLabels) {\n            textMaxWidth = chartWidth - scaleOffset - labelIconPadding;\n          }\n\n          if (noRoomForCallout) {\n            labelRightOffset = 0;\n            labelContentLeftOffset = 0;\n            labelContentRightOffset = 0;\n            textMaxWidth = chartWidth - labelIconPadding;\n          }\n\n          // Apply styles\n          labelSelectionStyle = 'left: {0}px; right: {1}px;'.format(labelLeftOffset, labelRightOffset);\n          if (labelSel.attr('style') !== labelSelectionStyle) {\n            labelSel.attr('style', labelSelectionStyle);\n          }\n\n          if (!_.isUndefined(labelContentLeftOffset)) {\n            desiredLabelContentLeft = '{0}rem'.format(labelContentLeftOffset);\n          }\n\n          if (!_.isUndefined(labelContentRightOffset)) {\n            desiredLabelContentRight = '{0}px'.format(labelContentRightOffset);\n          }\n\n          // Calls to .style() in this section were costing about 150ms per render,\n          // even if nothing changed about the style.\n          // We need to avoid even calling .style() if nothing changed. We accomplish\n          // this by storing details of the last-rendered style in data attributes,\n          // which are fast to read.\n          if (labelContentSelection.attr('data-left') !== desiredLabelContentLeft) {\n            labelContentSelection.style('left', desiredLabelContentLeft);\n            labelContentSelection.attr('data-left', desiredLabelContentLeft);\n          }\n          if (labelContentSelection.attr('data-right') !== desiredLabelContentRight) {\n            labelContentSelection.style('right', desiredLabelContentRight);\n            labelContentSelection.attr('data-right', desiredLabelContentRight);\n          }\n\n          labelTextSelectionStyle = 'max-width: {0}px;'.format(textMaxWidth);\n\n          if (labelTextSelection.attr('style') !== labelTextSelectionStyle) {\n            labelTextSelection.attr('style', labelTextSelectionStyle);\n          }\n        });\n\n      labelDivSelection.exit().remove();\n    };\n\n    var horizontalBarPosition = function(d) {\n      return horizontalScale(d[NAME_INDEX]) - chartLeftOffset;\n    };\n\n    var updateBars = function(selection) {\n      // Bars are composed of a bar group and two bars (total and filtered).\n\n      // ENTER PROCESSING\n\n      // Create bar groups.\n      selection.enter().\n        append('div').\n          classed('bar-group', true);\n\n      // Create 2 bars, total and filtered. Filtered bars default to 0 height if there is no data for them.\n      // The smaller bar needs to go on top of the other. However, if the bar on top is also the total (can\n      // happen for aggregations other than count), the top bar needs to be semitransparent.\n      // This function transforms each piece of data (containing filtered and total amounts) into\n      // an ordered pair of objects representing a bar. The order is significant and ultimately determines the\n      // order of the bars in the dom.\n      // Each object in the pair looks like:\n      // {\n      //    isTotal: [boolean, is this bar representing the total value?],\n      //    value: [number, the numerical value this bar should represent]\n      // }\n      function makeBarData(d) {\n        // If we're not showing the filtered value, just render it zero height.\n        var filtered = showFiltered ? d[FILTERED_INDEX] : 0;\n\n        // Figure out if the totals bar is on top. This controls styling.\n        var totalIsOnTop;\n        if (d[UNFILTERED_INDEX] * filtered < 0) {\n          // Opposite signs. Setting total on top by convention (makes styles easier).\n          totalIsOnTop = true;\n        } else {\n          // Same sign.\n          totalIsOnTop = Math.abs(d[UNFILTERED_INDEX]) >= Math.abs(filtered);\n        }\n\n        if (totalIsOnTop) {\n\n          return [\n            {\n              isTotal: true,\n              value: d[UNFILTERED_INDEX]\n            },\n            {\n              isTotal: false,\n              value: filtered\n            }\n          ];\n\n        } else {\n\n          return [\n            {\n              isTotal: false,\n              value: filtered\n            },\n            {\n              isTotal: true,\n              value: d[UNFILTERED_INDEX]\n            }\n          ];\n\n        }\n      }\n      var bars = selection.selectAll('.bar').data(makeBarData);\n\n      // Bars are just a div.\n      bars.enter().\n        append('div');\n\n      // UPDATE PROCESSING\n      // Update the position of the groups.\n      selection.\n        attr('data-bar-name', function(d) {\n          return _toEscapedString(_labelValueOrPlaceholder(d[NAME_INDEX]));\n        }).\n        style('left', function(d) { return horizontalBarPosition(d) + 'px'; }).\n        style('width', rangeBand + 'px').\n        style('height', function() { return innerHeight + 'px'; }).\n        classed('unfiltered-on-top', function(d) {\n          // This is really confusing. In CSS, we refer to the total bar as the unfiltered bar.\n          // If total bar is last in the dom, then apply this class.\n          return makeBarData(d)[1].isTotal;\n        }).\n        classed('selected', function(d) { return d[SELECTED_INDEX]; }).\n        classed('active', function(d) { return showAllLabels || horizontalBarPosition(d) < chartWidth - truncationMarkerWidth; });\n\n      // Update the position of the individual bars.\n      bars.\n        style('width', rangeBand + 'px').\n        style('height', function(d) {\n\n          if (_.isNaN(d.value)) {\n            return 0;\n          }\n\n          return Math.max(\n            d.value === 0 ? 0 : 1,  // Always show at least one pixel for non-zero-valued bars.\n            Math.abs(verticalScale(d.value) - verticalScale(0))\n          ) + 'px';\n        }).\n        style('bottom', function(d) {\n\n          if (_.isNaN(d.value)) {\n            return 0;\n          }\n\n          return verticalScale(Math.min(0, d.value)) + 'px';\n        }).\n        classed('bar', true).\n        classed('unfiltered', _.property('isTotal')).\n        classed('filtered', function(d) { return !d.isTotal; });\n\n      // EXIT PROCESSING\n      bars.exit().remove();\n      selection.exit().remove();\n    };\n\n    barGroupSelection.call(updateBars);\n    labelSelection.call(updateLabels);\n\n    _chartElement.children('.ticks').remove();\n    _chartElement.prepend(_renderTicks());\n\n    // Set \"Click to Expand\" truncation marker + its tooltip\n    _truncationMarker.css({\n      top: innerHeight,\n      display: chartTruncated ? 'block' : 'none'\n    });\n  }\n\n  // To string and escape backslashes and quotes\n  function _toEscapedString(value) {\n    return String(value).\n      replace(/\\\\/g, '\\\\\\\\').\n      replace(/\"/g, '\\\\\\\"');\n  }\n\n  function _labelValueOrPlaceholder(value, placeholder) {\n\n    var placeholderText = placeholder || self.getLocalization('NO_VALUE');\n    var valueText;\n\n    if ($.isNumeric(value)) {\n      return value;\n    } else if (_.isNaN(value)) {\n      return placeholderText;\n    }\n\n    if (_.isBoolean(value)) {\n      valueText = value.toString();\n    }\n\n    valueText = String(value) || '';\n\n    return utils.valueIsBlank(valueText.trim().escapeSpaces()) ?\n      placeholderText :\n      valueText;\n  }\n\n  function _computeDomain(chartData, showFiltered) {\n\n    var allData = chartData.map(function(d) { return d[UNFILTERED_INDEX]; }).concat(\n      (showFiltered) ?\n        chartData.map(function(d) { return d[FILTERED_INDEX]; }) :\n        []\n    );\n\n    function _makeDomainIncludeZero(domain) {\n      var min = domain[0];\n      var max = domain[1];\n      if (min > 0) { return [ 0, max ]; }\n      if (max < 0) { return [ min, 0]; }\n      return domain;\n    }\n\n    return _makeDomainIncludeZero(d3.extent(allData));\n  }\n\n  function _computeVerticalScale(innerHeight, chartData, showFiltered) {\n    return d3.scale.linear().domain(_computeDomain(chartData, showFiltered)).range([0, innerHeight]);\n  }\n\n  function _computeHorizontalScale(chartWidth, chartData, showAllLabels) {\n\n    // Horizontal scale configuration\n    var barPadding = 0.25;\n    var minBarWidth = 0;\n    var maxBarWidth = 0;\n    var minSmallCardBarWidth = 8;\n    var maxSmallCardBarWidth = 30;\n    var minExpandedCardBarWidth = 15;\n    var maxExpandedCardBarWidth = 40;\n    // End configuration\n\n    var horizontalScale;\n    var numberOfBars = chartData.length;\n    var isChartTruncated = false;\n    var rangeBand;\n\n    if (showAllLabels) {\n      minBarWidth = minExpandedCardBarWidth;\n      maxBarWidth = maxExpandedCardBarWidth;\n    } else {\n      minBarWidth = minSmallCardBarWidth;\n      maxBarWidth = maxSmallCardBarWidth;\n    }\n\n    var _computeChartDimensionsForRangeInterval = function(rangeInterval) {\n\n      horizontalScale = d3.scale.ordinal().rangeBands(\n        [0, Math.ceil(rangeInterval)], barPadding).domain(chartData.map(function(d) { return d[NAME_INDEX]; })\n      );\n      rangeBand = Math.ceil(horizontalScale.rangeBand());\n    };\n\n    _computeChartDimensionsForRangeInterval(chartWidth);\n\n    /**\n     * According to the D3 API reference for Ordinal Scales#rangeBands\n     * (https://github.com/mbostock/d3/wiki/Ordinal-Scales#ordinal_rangeBands):\n     *\n     * For the method `ordinal.rangeBands(barWidth[, barPadding[, outerPadding]]) = rangeInterval`\n     * `barPadding` corresponds to the amount of space in the `rangeInterval` as a percentage of\n     * `rangeInterval` (width in px):\n     *\n     * => rangeInterval = barPadding * rangeInterval + numberOfBars * barWidth\n     * => (1 - barPadding) * rangeInterval = numberOfBars * barWidth\n     * => rangeInterval = (numberOfBars * barWidth) / (1 - barPadding)\n     */\n    if (rangeBand < minBarWidth) {\n      // --> desired rangeBand (bar width) is less than accepted minBarWidth\n      // use computeChartDimensionsForRangeInterval to set rangeBand = minBarWidth\n      // and update horizontalScale accordingly\n      _computeChartDimensionsForRangeInterval(minBarWidth * numberOfBars / (1 - barPadding));\n      isChartTruncated = true;\n    } else if (rangeBand > maxBarWidth) {\n      // --> desired rangeBand (bar width) is greater than accepted maxBarWidth\n      // use computeChartDimensionsForRangeInterval to set rangeBand = maxBarWidth\n      _computeChartDimensionsForRangeInterval(maxBarWidth * numberOfBars / (1 - barPadding) + maxBarWidth * barPadding);\n    }\n\n    return {\n      scale: horizontalScale,\n      truncated: isChartTruncated\n    };\n  }\n}\n\nmodule.exports = ColumnChart;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/views/ColumnChart.js\n ** module id = 12\n ** module chunks = 0\n **/","'use strict';\n\nvar $ = require('jquery');\nvar utils = require('socrata-utils');\nvar Visualization = require('./Visualization.js');\nvar _ = require('lodash');\n\nmodule.exports = function Pager(element, vif) {\n  _.extend(this, new Visualization(element, vif));\n\n  var self = this;\n  var _lastRenderOptions;\n\n  utils.assertHasProperties(vif,\n    'configuration.localization.PREVIOUS',\n    'configuration.localization.NEXT',\n    'configuration.localization.NO_ROWS',\n    'configuration.localization.ONLY_ROW',\n    'configuration.localization.MANY_ROWS',\n    'unit.one',\n    'unit.other'\n  );\n\n  _attachEvents(this.element);\n\n  /**\n   * Public Methods\n   */\n\n  this.render = function(options) {\n    if (_.isEqual(options, _lastRenderOptions)) {\n      return;\n    }\n\n    _lastRenderOptions = options;\n\n    _render(options);\n  };\n\n  this.destroy = function() {\n    _detachEvents(this.element);\n    this.element.find('.socrata-pager').remove();\n  };\n\n  /**\n   * Private Methods\n   */\n\n  function _templatePagerLabel(options) {\n    var message;\n    var endIndex = Math.min(options.datasetRowCount, options.endIndex);\n\n    if (options.datasetRowCount === 0) {\n      message = vif.configuration.localization.NO_ROWS;\n    } else if (options.endIndex === options.startIndex + 1) {\n      message = vif.configuration.localization.ONLY_ROW;\n    } else {\n      message = vif.configuration.localization.MANY_ROWS;\n    }\n\n    message = message.format({\n      unitOne: vif.unit.one,\n      unitOther: vif.unit.other,\n      firstRowOrdinal: options.datasetRowCount ? utils.commaify(options.startIndex + 1) : undefined,\n      lastRowOrdinal: options.datasetRowCount ? utils.commaify(endIndex) : undefined,\n      datasetRowCount: utils.commaify(options.datasetRowCount)\n    });\n\n    return '<span class=\"pager-label\">{0}</span>'.format(message);\n  }\n\n  function _templatePagerButtons(options) {\n    var template = [\n      '<span class=\"pager-buttons\">',\n        '<button{previousDisabled} class=\"pager-button-previous\"><span class=\"icon-arrow-left\"></span> {previous}</button>',\n        '<button{nextDisabled} class=\"pager-button-next\">{next} <span class=\"icon-arrow-right\"></span></button>',\n      '</span>'\n    ].join('\\n');\n\n    return template.format({\n      previous: vif.configuration.localization.PREVIOUS,\n      next: vif.configuration.localization.NEXT,\n      previousDisabled: (options.disabled || options.startIndex === 0) ? ' disabled' : '',\n      nextDisabled: (options.disabled || options.endIndex >= options.datasetRowCount - 1) ? ' disabled' : ''\n    });\n  }\n\n  function _templatePager(options) {\n    return [\n      '<div class=\"socrata-pager\">',\n        _templatePagerButtons(options),\n        _templatePagerLabel(options),\n      '</div>'\n    ].join('\\n');\n  }\n\n  function _render(options) {\n    var $template = $(_templatePager(options));\n    self.element.find('.socrata-pager').remove(); // Enhancement: Incremental updates (vs. rerender every time).\n    self.element.append($template);\n  }\n\n  function _attachEvents() {\n    self.element.on('click', '.pager-buttons .pager-button-previous', _handlePrevious);\n    self.element.on('click', '.pager-buttons .pager-button-next', _handleNext);\n  }\n\n  function _detachEvents() {\n    self.element.off('click', '.pager-buttons .pager-button-previous', _handlePrevious);\n    self.element.off('click', '.pager-buttons .pager-button-next', _handleNext);\n  }\n\n  function _handleNext() {\n    self.emitEvent('SOCRATA_VISUALIZATION_PAGINATION_NEXT');\n  }\n\n  function _handlePrevious() {\n    self.emitEvent('SOCRATA_VISUALIZATION_PAGINATION_PREVIOUS');\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/views/Pager.js\n ** module id = 13\n ** module chunks = 0\n **/","'use strict';\n\nvar utils = require('socrata-utils');\nvar Visualization = require('./Visualization');\nvar d3 = require('d3');\nvar _ = require('lodash');\nvar $ = require('jquery');\n\nvar Constants = {\n  TIMELINE_CHART_MARGIN: {\n    TOP: 0,\n    RIGHT: 0,\n    BOTTOM: 30,\n    LEFT: 0\n  },\n  TIMELINE_CHART_NUMBER_OF_TICKS: 3,\n  TIMELINE_CHART_TICK_SIZE: 3,\n  TIMELINE_CHART_HIGHLIGHT_TARGET_MARGIN: 50,\n  TIMELINE_CHART_GUTTER: 15,\n  TIMELINE_CHART_SELECTION_MARKER_NEGATIVE_X_OFFSET: 11,\n  TIMELINE_CHART_DRAG_HANDLE_WIDTH: 24,\n  TIMELINE_CHART_MIN_LABEL_WIDTH: 150,\n  TIMELINE_CHART_REQUIRED_LABEL_WIDTH: 50\n};\n\nvar DateHelpers = {\n  serializeFloatingTimestamp: utils.serializeFloatingTimestamp,\n  deserializeFloatingTimestamp: utils.deserializeFloatingTimestamp,\n  decrementDateByHalfInterval: function(date, interval) {\n\n    var newDate;\n\n    switch (interval.toUpperCase()) {\n      case 'DECADE':\n        newDate = moment(date).subtract(5, 'year').toDate();\n        break;\n      case 'YEAR':\n        newDate = moment(date).subtract(6, 'month').toDate();\n        break;\n      case 'MONTH':\n        newDate = moment(date).subtract(15, 'day').toDate();\n        break;\n      case 'DAY':\n        newDate = moment(date).subtract(12, 'hour').toDate();\n        break;\n      default:\n        throw new Error(\n          'Cannot decrement date by dataset precision: invalid interval \"{0}\"'.\n          format(interval)\n        );\n    }\n\n    return newDate;\n  },\n\n  incrementDateByHalfInterval: function(date, interval) {\n\n    var newDate;\n\n    switch (interval.toUpperCase()) {\n      case 'DECADE':\n        newDate = moment(date).add(5, 'year').toDate();\n        break;\n      case 'YEAR':\n        newDate = moment(date).add(6, 'month').toDate();\n        break;\n      case 'MONTH':\n        newDate = moment(date).add(15, 'day').toDate();\n        break;\n      case 'DAY':\n        newDate = moment(date).add(12, 'hour').toDate();\n        break;\n      default:\n        throw new Error(\n          'Cannot increment date by dataset precision: invalid interval \"{0}\"'.\n          format(interval)\n        );\n    }\n\n    return newDate;\n\n  }\n};\n\n/*\nKNOWN BUGS\n\n1. The heuristic by which we decide when to display only some labels is\n   pretty neat.\n\nTERMINOLOGY\n\n'selection' is the yellow region when the visualization is being filtered.\n'highlight' is the white region that follows the cursor.\n'filter' is the mechanism by which queries are altered.\n*/\n\nfunction TimelineChart(element, vif) {\n\n  _.extend(this, new Visualization(element, vif));\n\n  var self = this;\n\n  utils.assertHasProperty(vif, 'configuration');\n\n  var _chartElement;\n  var _chartWrapper;\n  var _lastRenderData;\n  var _lastRenderOptions;\n\n  var _interactive = vif.configuration.interactive === true;\n\n  _renderTemplate(this.element);\n  _attachEvents(this.element);\n\n  /**\n   * Public methods\n   */\n\n  this.render = function(data, options) {\n    _lastRenderData = data;\n    _lastRenderOptions = options;\n    // Eventually we may only want to pass in the VIF instead of other render\n    // options as well as the VIF, but for the time being we will just treat it\n    // as another property on `options`.\n    _renderData(_chartElement, data, options);\n  };\n\n  this.renderError = function() {\n    // TODO: Some helpful error message.\n  };\n\n  this.invalidateSize = function() {\n    if (_lastRenderData && _lastRenderOptions) {\n      _renderData(_chartElement, _lastRenderData, _lastRenderOptions);\n    }\n  };\n\n  this.destroy = function() {\n    _unattachEvents(this.element);\n    this.element.find('.timeline-chart-container').remove();\n  };\n\n  /**\n   * Private methods\n   */\n\n  function _renderTemplate(el) {\n\n    function divWithClass(clsName) {\n      return $(\n        '<div>',\n        {\n          'class': clsName\n        }\n      );\n    }\n\n    function $xml(namespace, nodeName, attributeMap) {\n      var xmlNode = document.createElementNS(namespace, nodeName);\n      _.each(attributeMap, function(value, key) {\n        xmlNode.setAttributeNS(null, key, value);\n      });\n      return $(xmlNode);\n    }\n\n    function $svg(nodeName, attributeMap) {\n      return $xml('http://www.w3.org/2000/svg', nodeName, attributeMap);\n    }\n\n    function svgWithClass(clsName) {\n      return $svg(\n        'svg',\n        {\n          'class': clsName\n        }\n      ).append(\n        $svg('g')\n      );\n    }\n\n    var yTicks = divWithClass('y-ticks');\n    var xTicks = divWithClass('x-ticks');\n    var datumLabel = divWithClass('datum-label');\n    var timelineUnfilteredMask = divWithClass('timeline-chart-unfiltered-mask').\n      append(svgWithClass('timeline-chart-unfiltered-visualization'));\n    var timelineFilteredMask = divWithClass('timeline-chart-filtered-mask').\n      append(svgWithClass('timeline-chart-filtered-visualization'));\n    var timelineSelectionMask = divWithClass('timeline-chart-selection-mask').\n      append(svgWithClass('timeline-chart-selection'));\n\n    var leftSelectionLine = $svg(\n      'line',\n      {\n        y1: '0',\n        y2: '100%'\n      }\n    );\n    var leftSelectionTriangle = $svg(\n      'path',\n      {\n        d: 'M0,0L-10,0L-10,8L0,16Z'\n      }\n    );\n    var leftSelectionRect = $svg(\n      'rect',\n      {\n        'class': 'selection-marker',\n        'data-selection-target': 'left',\n        'x': '-24',\n        'width': '24',\n        'height': '100%'\n      }\n    );\n\n    var leftSelectionGroup = $svg(\n      'g',\n      {\n        transform: 'translate(24, 0)'\n      }\n    ).append([\n      leftSelectionLine,\n      leftSelectionTriangle,\n      leftSelectionRect\n    ]);\n\n    var leftSelectionSvg = $svg('svg').append(leftSelectionGroup);\n    var leftSelectionMarker = divWithClass('timeline-chart-left-selection-marker').\n      append(leftSelectionSvg);\n\n    var rightSelectionLine = $svg(\n      'line',\n      {\n        y1: '0',\n        y2: '100%'\n      }\n    );\n    var rightSelectionTriangle = $svg(\n      'path',\n      {\n        d: 'M0,0L10,0L10,8L0,16Z'\n      }\n    );\n    var rightSelectionRect = $svg(\n      'rect',\n      {\n        'class': 'selection-marker',\n        'data-selection-target': 'right',\n        'x': '0',\n        'width': '24',\n        'height': '100%'\n      }\n    );\n\n    var rightSelectionGroup = $svg(\n      'g',\n      {\n        transform: 'translate(0,0)'\n      }\n    ).append([\n      rightSelectionLine,\n      rightSelectionTriangle,\n      rightSelectionRect\n    ]);\n\n    var rightSelectionSvg = $svg('svg').append(rightSelectionGroup);\n    var rightSelectionMarker = divWithClass('timeline-chart-right-selection-marker').\n      append(rightSelectionSvg);\n\n    var timelineHighlightContainer = svgWithClass('timeline-chart-highlight-container');\n    var timelineHighlightTarget = divWithClass('timeline-chart-highlight-target');\n    var timelineClearSelectionLabel = $(\n      '<span>',\n      {\n        'class': 'timeline-chart-clear-selection-label'\n      }\n    );\n\n    var chartWrapper = $(\n      '<div>',\n      {\n        'class': 'timeline-chart-wrapper'\n      }\n    ).append([\n      yTicks,\n      xTicks,\n      datumLabel,\n      timelineUnfilteredMask,\n      timelineFilteredMask,\n      timelineSelectionMask,\n      leftSelectionMarker,\n      rightSelectionMarker,\n      timelineHighlightContainer,\n      timelineHighlightTarget,\n      timelineClearSelectionLabel\n    ]);\n\n    var chartLabels = $(\n      '<div>',\n      {\n        'class': 'labels'\n      }\n    );\n\n    var chartScroll = $(\n      '<div>',\n      {\n        'class': 'chart-scroll'\n      }\n    ).append([\n      chartWrapper,\n      chartLabels\n    ]);\n\n    var chartElement = $(\n      '<div>',\n      {\n        'class': 'timeline-chart'\n      }\n    ).append(chartScroll);\n\n    var chartContainer = $(\n      '<div>',\n      {\n        'class': 'timeline-chart-container'\n      }\n    ).append(\n      chartElement\n    );\n\n    self.renderAxisLabels(chartContainer);\n\n    // Cache element selections\n    _chartElement = chartElement;\n    _chartWrapper = chartWrapper;\n\n    el.append(chartContainer);\n  }\n\n  function _attachEvents(el) {\n    el.on(\n      'mouseenter mousemove',\n      '.timeline-chart',\n      showFlyout\n    );\n\n    el.on(\n      'mouseleave',\n      '.timeline-chart',\n      mouseHasLeftChart\n    );\n\n    if (_interactive) {\n      el.on(\n        'mousedown mouseup',\n        '.timeline-chart',\n        leftMouseButtonStateHasChanged\n      );\n\n      el.on(\n        'mousedown',\n        '.timeline-chart-clear-selection-label',\n        handleClearSelectionLabelMousedownEvent\n      );\n    }\n\n    el.on(\n      'mousemove',\n      '.timeline-chart-clear-selection-label',\n      showFlyout\n    );\n  }\n\n  function _unattachEvents(el) {\n    el.off(\n      'mouseenter mousemove',\n      '.timeline-chart',\n      showFlyout\n    );\n\n    el.off(\n      'mouseleave',\n      '.timeline-chart',\n      hideFlyout\n    );\n\n    if (_interactive) {\n      el.off(\n        'mousedown mouseup',\n        '.timeline-chart',\n        leftMouseButtonStateHasChanged\n      );\n\n      el.off(\n        'mousedown',\n        '.timeline-chart-clear-selection-label',\n        handleClearSelectionLabelMousedownEvent\n      );\n    }\n\n    el.off(\n      'mousemove',\n      '.timeline-chart-clear-selection-label',\n      showFlyout\n    );\n  }\n\n  /**\n   * Visualization renderer and helper functions\n   */\n\n  function emitFlyoutEvent(payload) {\n    self.emitEvent('SOCRATA_VISUALIZATION_TIMELINE_FLYOUT', payload);\n  }\n\n  function showFlyout(event) {\n    mouseHasMoved(event, false);\n\n    if (currentlyDragging) {\n      return emitFlyoutEvent(null);\n    }\n\n    function formatValue(value) {\n      var rules = (_.has(_lastRenderOptions, 'unit')) ?\n        _lastRenderOptions.unit :\n        vif.unit;\n\n      utils.assertHasProperty(rules, 'other');\n\n      if (_.isNull(value)) {\n        return 'No value';\n      }\n\n      value = Number(value);\n      utils.assert(!_.isNaN(value));\n\n      var resolve = function(rule) {\n        return '{0} {1}'.format(utils.formatNumber(value), rule);\n      };\n\n      if (value === 1 && rules.one) {\n        return resolve(rules.one);\n      } else {\n        return resolve(rules.other);\n      }\n    }\n\n    var payload = {\n      title: null,\n      unfilteredLabel: null,\n      unfilteredValue: null,\n      filteredLabel: null,\n      filteredValue: null,\n      filteredClass: null\n    };\n\n    var $target = $(event.target);\n\n    if ($target.is('.timeline-chart-clear-selection-button')) {\n\n      payload.title = 'Clear filter range';\n      payload.element = $target.get(0);\n\n      return emitFlyoutEvent(payload);\n\n    } else if (_interactive && $target.is('.selection-marker')) {\n\n      payload.title = 'Drag to change filter range';\n      payload.element = $target.get(0);\n\n      return emitFlyoutEvent(payload);\n\n    }\n\n    var flyoutTarget = _chartElement.find('.timeline-chart-flyout-target');\n\n    if (flyoutTarget.length === 0) {\n      return emitFlyoutEvent(null);\n    }\n\n    payload.element = flyoutTarget.get(0);\n\n    var isIntervalFlyout = $target.\n      is(flyoutIntervalTopSelectors.concat([flyoutIntervalPathSelector]).join(', '));\n    var isSelectionRendered = !_.isNull(selectionStartDate) &&\n      !_.isNull(selectionEndDate) &&\n      selectionIsCurrentlyRendered;\n\n    var datumIsDefined = !(_.isUndefined(currentDatum) || _.isNull(currentDatum));\n\n    if (isIntervalFlyout) {\n      return renderIntervalFlyout();\n    } else if (datumIsDefined) {\n      return renderDatumFlyout();\n    } else {\n      return;\n    }\n\n    function renderIntervalFlyout() {\n      var unfilteredValue = $target.attr('data-aggregate-unfiltered');\n      var filteredValue = $target.attr('data-aggregate-filtered');\n\n      payload.title = $target.attr('data-flyout-label');\n      payload.unfilteredValue = formatValue(unfilteredValue);\n      payload.unfilteredLabel = self.getLocalization('FLYOUT_UNFILTERED_AMOUNT_LABEL');\n\n      var date = $target.attr('data-start');\n\n      // Using == for correct date comparison here.\n      var isWithinSelection = (date == selectionStartDate); // eslint-disable-line\n\n      if (!_.isUndefined(filteredValue) && (unfilteredValue !== filteredValue || isWithinSelection)) {\n        payload.filteredValue = formatValue(filteredValue);\n        payload.filteredLabel = self.getLocalization('FLYOUT_FILTERED_AMOUNT_LABEL');\n      }\n\n      if (isSelectionRendered) {\n        payload.filteredBySelection = isWithinSelection;\n      }\n\n      emitFlyoutEvent(payload);\n    }\n\n    function renderDatumFlyout() {\n      if (currentDatum.hasOwnProperty('flyoutLabel')) {\n        payload.title = currentDatum.flyoutLabel;\n      } else {\n        var formatStrings = {\n          DECADE: 'YYYYs',\n          YEAR: 'YYYY',\n          MONTH: 'MMMM YYYY',\n          DAY: 'D MMMM YYYY'\n        };\n\n        payload.title = moment(currentDatum.date).format(formatStrings[datasetPrecision]);\n      }\n\n      payload.unfilteredValue = formatValue(currentDatum.unfiltered);\n      payload.unfilteredLabel = self.getLocalization('FLYOUT_UNFILTERED_AMOUNT_LABEL');\n\n      var isWithinSelection = currentDatum.date >= selectionStartDate && currentDatum.date <= selectionEndDate;\n\n      if (isWithinSelection || currentDatum.unfiltered !== currentDatum.filtered) {\n        payload.filteredValue = formatValue(currentDatum.filtered);\n        payload.filteredLabel = self.getLocalization('FLYOUT_FILTERED_AMOUNT_LABEL');\n      }\n\n      if (isSelectionRendered) {\n        payload.filteredBySelection = isWithinSelection;\n      }\n\n      emitFlyoutEvent(payload);\n    }\n  }\n\n  function hideFlyout() {\n    self.emitEvent(\n      'SOCRATA_VISUALIZATION_TIMELINE_FLYOUT',\n      null\n    );\n  }\n\n  // Cache a bunch of stuff that is useful in a lot of places that don't\n  // need to be wrapped in Rx mojo.\n  var cachedChartDimensions = null;\n  var cachedChartData = null;\n\n  // Keep track of whether or not the mouse position is within this\n  // instance of a timeline chart's visualization area (the chart itself\n  // and the x-axis labels beneath it).\n  var mousePositionWithinChartElement = false;\n  var mousePositionWithinChartDisplay = false;\n  var mousePositionWithinChartLabels = true;\n\n  // These two values are in pixels.\n  var visualizedDatumWidth = 0;\n  var halfVisualizedDatumWidth = 0;\n\n  // currentDatum is used to persist information about the highlighted\n  // region between the filterChartData and flyout rendering functions.\n  var currentDatum = null;\n\n  // datasetPrecision is used in multiple places in order to test and\n  // modify dates, but we only really have a notion of it within the\n  // context of Rx reactions; for this reason it's cached globally.\n  var datasetPrecision = null;\n\n  var labelPrecision = null;\n\n  // The X and Y scales that d3 uses are global to the directive so\n  // that we can use the same ones between the renderChart and\n  // renderChartHighlight functions.\n  // They are initialized to null so that we don't accidentally try\n  // to render a highlight before a chart is rendered.\n  var d3XScale = null;\n  var d3YScale = null;\n\n  // The following cached jQuery/d3 selectors are used throughout the\n  // directive.\n  var $body = $('body');\n  var $chartElement = _chartElement.find('.timeline-chart-wrapper');\n  var $highlightTargetElement = _chartElement.find('.timeline-chart-highlight-target');\n  var $chartSelectionElement = _chartElement.find('.timeline-chart-selection');\n  var $leftSelectionMarker = _chartElement.find('.timeline-chart-left-selection-marker');\n  var $rightSelectionMarker = _chartElement.find('.timeline-chart-right-selection-marker');\n  var $clearSelectionLabel = _chartElement.find('.timeline-chart-clear-selection-label');\n  var $datumLabel = _chartElement.find('.datum-label');\n  var d3ChartElement = d3.select($chartElement[0]);\n\n  // Keep track of the start and end of the selection.\n  var selectionStartDate = null;\n  var selectionEndDate = null;\n\n  // We use these two values to 'dirty check' changes\n  // to selectionStartDate and selectionEndDate and\n  // conditionally NOOP in the selection rendering\n  // code if what would be rendered has not changed.\n  var renderedSelectionStartDate = null;\n  var renderedSelectionEndDate = null;\n\n  var selectionIsCurrentlyRendered = false;\n\n  // Keep track of whether or not this instance of a timeline chart is in\n  // the 'dragging' state so that we can selectively listen for mouseup\n  // and apply the 'goalpost' selection area.\n  var currentlyDragging = false;\n\n  var allChartLabelsShown = true;\n\n  var flyoutIntervalPathSelector = '.datum-label';\n  var flyoutIntervalTopSelectors = [\n    '.x-tick-label',\n    '.timeline-chart-clear-selection-label'\n  ];\n\n  function _renderData(el, data, options) {\n\n    _chartElement.width(options.width);\n    _chartElement.height(options.height);\n\n    // Cache dimensions and options\n    var chartWidth = el.width();\n    var chartHeight = el.height();\n    var showAllLabels = options.showAllLabels;\n    var showFiltered = options.showFiltered;\n    var precision = options.precision;\n    var unit = options.unit;\n\n    if (chartWidth <= 0 || chartHeight <= 0) {\n      if (window.console && window.console.warn) {\n        console.warn('Aborted rendering column chart: chart width or height is zero.');\n      }\n      return;\n    }\n\n    utils.assert(precision);\n\n    if (showAllLabels) {\n      _chartElement.addClass('show-all-labels');\n    } else {\n      _chartElement.removeClass('show-all-labels');\n    }\n\n    if (showFiltered) {\n      _chartWrapper.addClass('filtered');\n    } else {\n      _chartWrapper.removeClass('filtered');\n    }\n\n    /**\n     * Basically just prepares the underlying chart data and then calls\n     * special functions that render the x-axis, the y-axis, unfiltered\n     * and filtered values.\n     */\n    function renderChart() {\n\n      var margin;\n      var width;\n      var height;\n\n      if (cachedChartDimensions.width <= 0 || cachedChartDimensions.height <= 0) {\n        return;\n      }\n\n      //\n      // Prepare dimensions used in chart rendering.\n      //\n      margin = Constants.TIMELINE_CHART_MARGIN;\n\n      // width and height do not include margins so that\n      // we can use the margins to render axis ticks.\n      width = cachedChartDimensions.width - margin.LEFT - margin.RIGHT;\n      height = cachedChartDimensions.height - margin.TOP - margin.BOTTOM;\n\n      // Set up the scales and the chart-specific stack and area functions.\n      // Also create the root svg element to which the other d3 functions\n      // will append elements.\n\n      // d3XScale is global to the directive so that we can\n      // access it without having to re-render.\n      d3XScale = d3.\n        time.\n        scale().\n        domain([\n          DateHelpers.decrementDateByHalfInterval(cachedChartData.minDate, datasetPrecision),\n          DateHelpers.incrementDateByHalfInterval(cachedChartData.maxDate, datasetPrecision)\n        ]).\n        range([0, width]);\n\n      // d3YScale is global to the directive so that we can\n      // access it without having to re-render.\n      d3YScale = d3.\n        scale.\n        linear().\n        domain([cachedChartData.minValue, cachedChartData.maxValue]).\n        range([height, 0]).\n        clamp(true);\n\n      // Render the x-axis.\n      renderChartXAxis();\n\n      // Render the y-axis. Since we eschew d3's built-in y-axis for a\n      // custom implementation this calls out to a separate function.\n      renderChartYAxis(\n        width,\n        height\n      );\n\n      // Render the unfiltered and filtered values of the chart.\n      renderChartUnfilteredValues();\n      renderChartFilteredValues();\n    }\n\n    // Render the chart\n    function cacheThenRender(chartDimensions, chartData, chartPrecision) {\n\n      var filter;\n\n      if (_.isUndefined(chartData) || _.isNull(chartData) || _.isUndefined(chartPrecision)) {\n        return;\n      }\n\n      // Because we are about to divide by the number of values in the\n      // provided chart data, we need to first check to make sure we\n      // won't try to divide by zero and throw an exception instead of\n      // rendering if that's the case.\n      utils.assertHasProperty(chartData, 'values.length');\n      if (chartData.values.length === 0) {\n        console.error('Failed to render timeline chart because it was given no values.');\n        return;\n      }\n\n      // Cache the datum width and half the datum width for use elsewhere\n      // instead of repeated recomputation.\n      visualizedDatumWidth = Math.floor(chartDimensions.width / chartData.values.length);\n      halfVisualizedDatumWidth = Math.floor(visualizedDatumWidth / 2);\n\n      // Update the cached value for dataset precision.\n      // This is global to the directive, but only updated here.\n      datasetPrecision = chartPrecision;\n\n      // Cache the row display unit for use in the flyout (which\n      // necessarily is handled outside the scope of this subscribeLatest\n      // and which probably shouldn't be wrapped in its own\n      // subscribeLatest or other combinator).\n\n      cachedChartDimensions = chartDimensions;\n      cachedChartData = chartData;\n\n      renderChart();\n      clearChartHighlight();\n\n      // Make sure we also re-render the chart selection if it is visible\n      // (such as in the case of a visualization re-render triggered by\n      // the window being resized).\n      if (selectionIsCurrentlyRendered) {\n        renderedSelectionStartDate = null;\n        renderedSelectionEndDate = null;\n        renderChartSelection();\n      }\n\n      // This was the original implementation to support filtering from data\n      // lens, but now that we are consolidating this functionality, we will\n      // probably want to deprecate this method in favor of:\n      //\n      // First: getting the VIF from the render options.\n      //\n      // Eventually: receiving the VIF instead of the render options.\n      if (_.isArray(options.activeFilters) && options.activeFilters.length > 0) {\n\n        filter = _.first(options.activeFilters);\n\n        selectionStartDate = filter.start;\n        selectionEndDate = filter.end;\n        renderChartSelection();\n        enterSelectedState();\n\n      // Re: the above, this is phase one of the transition to using the VIF to\n      // describe filter state. A second PR will be made to convert the render\n      // options into a VIF on its own.\n      } else if (options.vif) {\n\n        //derive selection start and end\n        var filtersOnThisColumn = options.\n          vif.\n          filters.\n          filter(function(filterComponent) {\n            return (\n              (filterComponent.columnName === options.vif.columnName) &&\n              (filterComponent.function === 'timeRange')\n            );\n          });\n\n        if (filtersOnThisColumn.length > 0) {\n\n          filter = filtersOnThisColumn[0];\n\n          selectionStartDate = new Date(filter.arguments.start);\n          selectionEndDate = new Date(filter.arguments.end);\n          renderChartSelection();\n          enterSelectedState();\n\n        }\n\n      } else {\n        enterDefaultState();\n      }\n    }\n\n    var dimensions = { width: chartWidth, height: chartHeight };\n\n    cacheThenRender(dimensions, data, precision, unit);\n\n    // TODO: React to active filters being cleared.\n  }\n\n  // These rendering functions are generated by a helper due to their\n  // high degree of similarity. The functions are decoupled so that we\n  // can independently update and manipulate the filtered values as\n  // selections are made.\n  var renderChartUnfilteredValues = generateChartValueRenderer({\n    valueTransformer: function(values) {\n      return [transformValuesForRendering(values)];\n    },\n    ySelector: function(d) { return d3YScale(d.unfiltered); },\n    svgSelector: 'svg.timeline-chart-unfiltered-visualization',\n    areaClass: 'context',\n    lineClass: 'context-trace'\n  });\n\n  var renderChartFilteredValues = generateChartValueRenderer({\n    valueTransformer: function(values) {\n      if (selectionIsCurrentlyRendered) {\n        return [];\n      } else {\n        return [transformValuesForRendering(values)];\n      }\n    },\n    ySelector: function(d) { return d3YScale(d.filtered); },\n    svgSelector: 'svg.timeline-chart-filtered-visualization',\n    areaClass: 'shaded',\n    lineClass: 'shaded-trace'\n  });\n\n  /* Use a function generator to DRY up very similar rendering functions.\n   * The specified opts object factors out the few bits where filtered and\n   * unfiltered chart rendering are different.\n   * @param {number} chartOpts\n   *   @property {function} valueTransformer - function for obtaining values\n   *   @property {function} ySelector - function for choosing correct y value\n   *   @property {string} svgSelector - selector fo SVG element\n   *   @property {string} areaClass - CSS class for area element\n   *   @property {string} lineClass - CSS class for line element\n   */\n  function generateChartValueRenderer(chartOpts) {\n\n    return function() {\n\n      var margin;\n      var values;\n      var line;\n      var area;\n      var svgChart;\n      var selection;\n\n      margin = Constants.TIMELINE_CHART_MARGIN;\n      values = chartOpts.valueTransformer(cachedChartData.values);\n\n      line = d3.\n        svg.\n        line().\n        defined(function(d) { return !_.isNull(d.unfiltered); }).\n        x(function(d) { return d3XScale(d.date); }).\n        y(chartOpts.ySelector);\n\n      area = d3.\n        svg.\n        area().\n        defined(line.defined()).\n        x(line.x()).\n        y0(function() { return d3YScale(0); }).\n        y1(line.y());\n\n      svgChart = d3ChartElement.\n        select(chartOpts.svgSelector).\n        attr('width', cachedChartDimensions.width).\n        attr('height', cachedChartDimensions.height).\n        select('g').\n        attr('transform', 'translate({0}, {1})'.format(margin.LEFT, margin.TOP));\n\n      selection = svgChart.\n        selectAll('path').\n        data(values);\n\n      selection.\n        enter().\n        append('path');\n\n      selection.\n        exit().\n        remove();\n\n      selection.\n        attr('class', chartOpts.areaClass).\n        attr('d', area);\n\n      svgChart.\n        append('path').\n        data(values).\n        attr('class', chartOpts.lineClass).\n        attr('d', line);\n    };\n  }\n\n  /**\n   * Similar to formatDateLabel but for ranges instead of discrete dates.\n   *\n   * @param {Date} startDate\n   * @param {Date} endDate\n   * @return {String} The formatteddate.\n   */\n  function formatDateRangeLabel(startDate, endDate) {\n\n    function numberOfMonthsDifferent(date1, date2) {\n      return moment(date2).diff(moment(date1), 'months', false);\n    }\n\n    function datesAreExactlyOneMonthDifferent(date1, date2) {\n      var exactlyOneMonthDifferent = true;\n\n      if (date2.getFullYear() !== date1.getFullYear() ||\n        date2.getMonth() - 1 !== date1.getMonth() ||\n        date2.getDate() !== date1.getDate()) {\n\n        exactlyOneMonthDifferent = false;\n      }\n      return exactlyOneMonthDifferent;\n    }\n\n    // This is the expected behavior: an interval of exactly two months\n    // should read 'Jan - Feb'.\n    var adjustedEndDate = DateHelpers.decrementDateByHalfInterval(endDate, datasetPrecision);\n    var difference;\n    var dateFormatPrecision;\n    var showRange = true;\n    var formattedStartDate;\n    var formattedEndDate;\n    var label;\n\n    switch (labelPrecision) {\n\n      case 'DECADE':\n        difference = endDate.getFullYear() - startDate.getFullYear();\n        // We should not show a range if only a single year is selected.\n        // Similarly, we should show exact years if the selection does\n        // not fall on exact decade-by-decade boundaries. Otherwise, we\n        // should show a decade-specific range, e.g. '1930s - 1940s'.\n        if (difference === 10 && (startDate.getFullYear() % 10 === 0)) {\n          showRange = false;\n        } else if (startDate.getFullYear() % 10 !== 0 || endDate.getFullYear() % 10 !== 0) {\n          dateFormatPrecision = 'YEAR';\n        }\n        break;\n\n      case 'YEAR':\n        difference = numberOfMonthsDifferent(startDate, endDate);\n        // We should still show the month-to-month label even if\n        // the interval is exactly one year in the case that the\n        // start date is not January--otherwise we see a 1-year\n        // span that, e.g., starts in June 2000 and ends in June\n        // 2001 still listed as '2000'.\n        if (difference === 12 && startDate.getMonth() === 0) {\n          showRange = false;\n        } else {\n          dateFormatPrecision = 'MONTH';\n        }\n        break;\n\n      case 'MONTH':\n        if (datesAreExactlyOneMonthDifferent(startDate, endDate) && startDate.getDate() === 1) {\n          showRange = false;\n        } else {\n          dateFormatPrecision = 'DAY';\n        }\n        break;\n\n      case 'DAY':\n        difference = moment.duration(moment(endDate) - moment(startDate)).asDays();\n        if (difference <= 1) {\n          showRange = false;\n        }\n        break;\n\n      default:\n        break;\n    }\n\n    formattedStartDate = formatDateLabel(startDate, false, dateFormatPrecision);\n    formattedEndDate = formatDateLabel(adjustedEndDate, false, dateFormatPrecision);\n\n    if (showRange && (formattedStartDate !== formattedEndDate)) {\n      label = '{0} - {1}'.format(formattedStartDate, formattedEndDate);\n    } else {\n      label = formattedStartDate;\n    }\n\n    return (_interactive) ?\n      '{0} <span class=\"timeline-chart-clear-selection-button\">×</span>'.format(label) :\n      '{0}'.format(label);\n  }\n\n  /**\n   * Is probably the most complicated function in the directive\n   * simply because of all the special casing that needs to happen for\n   * sensible display of axis labels across multiple time intervals.\n   */\n  function renderChartXAxis() {\n\n    function deriveXAxisLabelPrecision() {\n\n      var domain;\n      var xAxisLabelPrecision;\n\n      domain = _.map(d3XScale.domain(), function(date) {\n        return moment(date);\n      });\n\n      xAxisLabelPrecision = 'DECADE';\n\n      // ...then use the domain to derive a timeline granularity.\n      if (moment(domain[0]).add(2, 'months').isAfter(domain[1])) {\n        xAxisLabelPrecision = 'DAY';\n      } else if (moment(domain[0]).add(2, 'years').isAfter(domain[1])) {\n        xAxisLabelPrecision = 'MONTH';\n      } else if (moment(domain[0]).add(20, 'years').isAfter(domain[1])) {\n        xAxisLabelPrecision = 'YEAR';\n      }\n\n      return xAxisLabelPrecision;\n    }\n\n    function deriveXAxisLabelDatumStep(allLabels) {\n\n      var numberOfLabels = allLabels.length;\n\n      // TIMELINE_CHART_REQUIRED_LABEL_WIDTH is the min\n      // width required for labels with month (\"Oct 15\")\n      var labelsWeHaveRoomFor = Math.floor(cachedChartDimensions.width /\n        Constants.TIMELINE_CHART_REQUIRED_LABEL_WIDTH);\n      var labelEveryN;\n\n      // TODO - write integration tests for the number of labels shown at given\n      // screen widths and ensuring that they are interactive.\n\n      // Show every label, every other label, etc...\n      if (numberOfLabels <= labelsWeHaveRoomFor) {\n        labelEveryN = 1;\n      } else if (numberOfLabels / 2 <= labelsWeHaveRoomFor) {\n        labelEveryN = 2;\n      } else if (numberOfLabels / 3 <= labelsWeHaveRoomFor) {\n        labelEveryN = 3;\n      } else if (numberOfLabels / 5 <= labelsWeHaveRoomFor) {\n        labelEveryN = 5;\n      } else {\n        labelEveryN = 7;\n      }\n\n      return labelEveryN;\n    }\n\n    // pxPerDay == pixelsPerDay\n    function recordLabel(allLabels, startDate, endDate, pxPerDay, shouldLabel) {\n      allLabels.push({\n        startDate: startDate,\n        endDate: endDate,\n        left: d3XScale(startDate) - halfVisualizedDatumWidth,\n        width: moment.duration(moment(endDate) - moment(startDate)).asDays() * pxPerDay,\n        shouldLabel: shouldLabel\n      });\n    }\n\n    var pixelsPerDay;\n    var jqueryAxisContainer;\n    var tickLocations = [];\n    var labels = [];\n    var thisDate;\n    var intervalStartDate = cachedChartData.values[0].date;\n    var intervalEndDate = null;\n    var maxDatePlusLabelPrecision;\n    var shouldLabelEveryN;\n\n    // This is half the width of each tick as defined in the accompanying CSS\n    var halfTickWidth = 2;\n    var jqueryAxisTick;\n    var dataAggregate;\n    var unfilteredAggregate;\n    var filteredAggregate;\n    var labelText;\n    var jqueryAxisTickLabel;\n    var finalEndDate;\n\n    // Note that labelPrecision is actually global to the directive, but\n    // it is set within the context of rendering the x-axis since it\n    // seems as reasonable to do so here as anywhere else.\n    labelPrecision = deriveXAxisLabelPrecision();\n\n    pixelsPerDay = cachedChartDimensions.width /\n      moment.duration(\n        moment(cachedChartData.maxDate).add(1, datasetPrecision) -\n        moment(cachedChartData.minDate)\n      ).asDays();\n\n    // Set up the container for the x-axis ticks.\n    jqueryAxisContainer = $('<div>').\n      addClass('x-ticks').\n      css({\n        width: cachedChartDimensions.width,\n        height: Constants.TIMELINE_CHART_MARGIN.BOTTOM\n      });\n\n    _.each(cachedChartData.values, function(value, i) {\n\n      if (i === 0) {\n        return;\n      }\n\n      thisDate = value.date;\n\n      switch (labelPrecision) {\n        case 'DECADE':\n          if (thisDate.getFullYear() % 10 === 0) {\n            tickLocations.push(i);\n            recordLabel(labels, intervalStartDate, thisDate, pixelsPerDay, true);\n            intervalStartDate = thisDate;\n          }\n          break;\n        case 'YEAR':\n          if (thisDate.getMonth() === 0) {\n            tickLocations.push(i);\n            recordLabel(labels, intervalStartDate, thisDate, pixelsPerDay, true);\n            intervalStartDate = thisDate;\n          }\n          break;\n        case 'MONTH':\n          if (thisDate.getDate() === 1) {\n            tickLocations.push(i);\n            recordLabel(labels, intervalStartDate, thisDate, pixelsPerDay, true);\n            intervalStartDate = thisDate;\n          }\n          break;\n        case 'DAY':\n          tickLocations.push(i);\n          recordLabel(labels, intervalStartDate, thisDate, pixelsPerDay, true);\n          intervalStartDate = thisDate;\n          break;\n      }\n    });\n\n    intervalEndDate = moment(cachedChartData.maxDate).add(1, datasetPrecision).toDate();\n\n    // If the last date is not a tick, we still need a label to extend\n    // from the last tick to the end of the visualization.\n    // Additionally, moment has no notion of decades so we need to catch\n    // that case and add 10 years instead.\n    finalEndDate = _.isEmpty(labels) ? intervalEndDate : _.last(labels).endDate;\n    if (labelPrecision === 'DECADE') {\n      maxDatePlusLabelPrecision =\n        moment(finalEndDate).add(10, 'YEAR').toDate();\n    } else {\n      maxDatePlusLabelPrecision =\n        moment(finalEndDate).add(1, labelPrecision).toDate();\n    }\n\n    labels.push({\n      startDate: intervalStartDate,\n      endDate: intervalEndDate,\n      width: cachedChartDimensions.width - d3XScale(intervalStartDate) +\n        (2 * halfTickWidth) + halfVisualizedDatumWidth,\n      left: d3XScale(intervalStartDate) - halfVisualizedDatumWidth,\n      // If the distance from the last tick to the end of the visualization is\n      // equal to one labelPrecision unit or if we have no labels, then we\n      // should label the interval.  Otherwise, we should draw it but not label it.\n      shouldLabel: (maxDatePlusLabelPrecision.getTime() === intervalEndDate.getTime()) ||\n        _.isEmpty(labels)\n    });\n\n    // Now that we know how many *labels* we can potentially draw, we\n    // decide whether or not we can draw all of them or just some.\n    shouldLabelEveryN = deriveXAxisLabelDatumStep(labels);\n\n    // Note that allChartLabelsShown is also actually global to the\n    // directive and is also set within the context of rendering the\n    // x-axis since it seems as reasonable to do so as anywhere else.\n    allChartLabelsShown = shouldLabelEveryN === 1;\n\n    // Finally, we filter the group of all labels so that we only\n    // label every Nth one.\n    labels = labels.filter(function(label, i) {\n      return (i % shouldLabelEveryN) === 0;\n    });\n\n    if (!allChartLabelsShown) {\n\n      var halfExtendedLabelWidth = (visualizedDatumWidth * Math.floor(shouldLabelEveryN / 2));\n\n      // Revisit each label and increase its width to accommodate the\n      // space that would have been consumed by the missing labels.\n      // The first one is a special case since it will only be enlarged\n      // by half the amount that the others are, since it already sits at\n      // the left edge of the labels. The last will be a special case\n      // also, but it's easier to just adjust it after the map operation.\n      labels.map(function(label) {\n        label.left -= halfExtendedLabelWidth;\n        label.width += (2 * halfExtendedLabelWidth);\n      });\n\n    }\n\n    // Now we go through and draw ticks.\n    _.each(tickLocations, function(location) {\n      jqueryAxisTick = $('<rect>').\n        addClass('x-tick').\n        css({\n          left: d3XScale(cachedChartData.values[location].date) -\n            halfVisualizedDatumWidth - halfTickWidth\n        });\n\n      jqueryAxisContainer.append(jqueryAxisTick);\n    });\n\n    // Now we to through and draw labels.\n    _.each(labels, function(label) {\n\n      // Calculate the data aggregates for this interval so we can\n      // stash them as data-attributes and not need to recalculate\n      // them whenever the mouse moves over this label.\n      dataAggregate = cachedChartData.values.\n        filter(function(datum) {\n          return datum.date.getTime() >= label.startDate.getTime() &&\n                 datum.date.getTime() < label.endDate.getTime();\n        });\n\n      unfilteredAggregate = dataAggregate.\n        reduce(function(acc, datum) {\n          return acc + datum.unfiltered;\n        }, 0);\n\n      filteredAggregate = dataAggregate.\n        reduce(function(acc, datum) {\n          return acc + datum.filtered;\n        }, 0);\n\n      labelText = label.shouldLabel ? formatDateLabel(label.startDate, false, labelPrecision) : '';\n\n      // Finally, add the label to the x-axis container.\n      jqueryAxisTickLabel = $('<span>').\n        addClass('x-tick-label').\n        attr('data-start', label.startDate).\n        attr('data-median', label.startDate).\n        attr('data-end', label.endDate).\n        attr('data-aggregate-unfiltered', unfilteredAggregate).\n        attr('data-aggregate-filtered', filteredAggregate).\n        attr('data-flyout-label', formatDateLabel(label.startDate, true)).\n        text(labelText).\n        css({\n          left: label.left,\n          width: label.width - halfTickWidth\n        });\n\n      jqueryAxisContainer.append(jqueryAxisTickLabel);\n\n    });\n\n    // Replace the existing x-axis ticks with the new ones.\n    $chartElement.children('.x-ticks').replaceWith(jqueryAxisContainer);\n\n  }\n\n  /**\n   * This function is comparatively straightforward, but operates\n   * in the same way as renderChartXAxis.\n   */\n  function renderChartYAxis(chartWidth, chartHeight) {\n\n    var jqueryAxisContainer;\n    var labels;\n    var ticks;\n    var tickElement;\n\n\n    jqueryAxisContainer = $('<div>').\n      addClass('y-ticks').\n      css({\n        width: chartWidth,\n        height: chartHeight\n      });\n\n    labels = [\n      Math.round(cachedChartData.minValue),\n      Math.round(cachedChartData.meanValue),\n      Math.round(cachedChartData.maxValue)\n    ];\n\n    ticks = [0, 0.5, 1];\n\n    // If our values straddle 0, then we need to force the middle tick to\n    // be 0, not the average of the min and the max values.\n    if (labels[0] * labels[2] < 0) {\n      labels[1] = 0;\n      ticks[1] = Math.abs(cachedChartData.minValue) /\n        (Math.abs(cachedChartData.minValue) + Math.abs(cachedChartData.maxValue));\n    }\n\n    _.each(ticks, function(tick, index) {\n\n      tickElement = $('<div>').\n        addClass('y-tick').\n        css('bottom', Math.floor(chartHeight * tick)).\n        text(utils.formatNumber(labels[index]));\n\n      if (labels[index] === 0) {\n        tickElement.addClass('origin');\n      }\n\n      if (index === ticks.length - 1) {\n        tickElement.addClass('below');\n      }\n\n      jqueryAxisContainer.append(tickElement);\n\n    });\n\n    // Remove old y-axis ticks and replace them\n    $chartElement.children('.y-ticks').replaceWith(jqueryAxisContainer);\n\n  }\n\n  /**\n   * Because we want the points representing aggregation values to fall\n   * between ticks but the highlight edges and ticks to straddle the\n   * points representing aggregation values we need to create synthetic\n   * points one-half of a <datasetPrecision> interval at the beginning\n   * and end of a series of values we plan to render.\n   *\n   * If leadingValue and/or trailingValue is falsey then this function\n   * will extend the first and/or last actual point's value to these\n   * synthetic points.\n   *\n   * Otherwise (currently only in the case of rendering the chart\n   * selection) leadingValue will be used for the value of the leading\n   * synthetic point and trailingValue will be used for the value of the\n   * trailing synthetic point. This allows the chart selection to mimic\n   * d3's interpolation between points so that the selection's contour\n   * tracks that of the unfiltered values rendered behind it rather than\n   * extending levelly from the first and last actual selection values.\n   *\n   * @param {Array} values - The array of values to transform.\n   * @param {Number} leadingValue - The optional value to use for the\n   *                                leading half-<datasetPrecision>\n   *                                point.\n   * @param {Number} trailingValue - The optional value to use for the\n   *                                 trailing half-<datasetPrecision>\n   *                                 point.\n   * @return {Array} An array containing the query response data with\n   *                 additional points one-half of a dataset precision\n   *                 unit before the first and after the last datum in\n   *                 order for the visualization to span the full\n   *                 available width while also placing individual points\n   *                 between ticks.\n   */\n  function transformValuesForRendering(\n    values,\n    leadingValue,\n    trailingValue) {\n\n    var outputValues = [];\n    var i;\n\n    for (i = 0; i < values.length; i++) {\n      var datum = _.pick(values[i], ['date', 'filtered', 'unfiltered']);\n      var prevDatum = values[i - 1];\n      var nextDatum = values[i + 1];\n      var dateNudge;\n\n      /**\n       * If this datum is the first value or if there is a discontinuity\n       * to the left of this datum, add a synthetic half-step left.\n       */\n      if (_.isUndefined(prevDatum) || _.isNull(prevDatum.unfiltered)) {\n        dateNudge = DateHelpers.decrementDateByHalfInterval(\n          datum.date,\n          datasetPrecision\n        );\n        outputValues.push(_.extend(_.clone(datum), { date: dateNudge }));\n      }\n\n      /**\n       * Always add the datum.\n       */\n      outputValues.push(datum);\n\n      /**\n       * If this datum is the last value or if there is a discontinuity\n       * to the right of this datum, add a synthetic half-step right.\n       */\n      if (_.isUndefined(nextDatum) || _.isNull(nextDatum.unfiltered)) {\n        dateNudge = DateHelpers.incrementDateByHalfInterval(\n          datum.date,\n          datasetPrecision\n        );\n        outputValues.push(_.extend(_.clone(datum), { date: dateNudge }));\n      }\n    }\n\n    /**\n     * Override the leading and trailing values if requested.\n     */\n    if (leadingValue) {\n      _.first(outputValues).filtered = leadingValue;\n      _.first(outputValues).unfiltered = leadingValue;\n    }\n\n    if (trailingValue) {\n      _.last(outputValues).filtered = trailingValue;\n      _.last(outputValues).unfiltered = trailingValue;\n    }\n\n    return outputValues;\n  }\n\n  function renderChartSelection() {\n\n    /**\n     * This function will select the data points that fall between the\n     * selection start and end dates and then create synthetic points one\n     * half of a <datasetPrecision> unit before and after the selection.\n     * This is to support the behavior that the point representing the\n     * value of each interval is drawn in the center of the interval, not\n     * on its left edge.\n     *\n     * The half <datasetPrecision> unit synthetic points must\n     * furthermore have values that are interpolated between the first/\n     * last actual data points and the points just before or after them,\n     * so that the rendered selection mirrors the unfiltered data drawn\n     * behind it.\n     *\n     * In the case that the selection starts at the beginning of the\n     * overall data the first data point's value will be used instead.\n     *\n     * In the case that the selection ends at the end of the overall data\n     * the last data point's value will be used instead.\n     */\n    function deriveSelectionValues(chartData, minimumDate, maximumDate) {\n\n      var lastChartDatum = _.last(chartData.values);\n      var prevOutOfBoundsDatum = { filtered: null };\n      var nextOutOfBoundsDatum = { filtered: null };\n      var firstSelectionDatum = null;\n      var lastSelectionDatum = null;\n      var firstSelectionValueAmount = false;\n      var lastSelectionValueAmount = false;\n      var selectionValues = [];\n\n      _.each(chartData.values, function(datum) {\n\n        if (datum.date >= minimumDate && datum.date <= maximumDate) {\n          if (_.isNull(firstSelectionDatum)) {\n            firstSelectionDatum = datum;\n          }\n          // Track the current datum as \"beyond the end of the selection\"\n          // instead of \"last in selection\" because we chop off the last\n          // value below!\n          nextOutOfBoundsDatum = datum;\n          selectionValues.push(datum);\n        } else if (datum.date < minimumDate) {\n          prevOutOfBoundsDatum = datum;\n        } else if (datum.date > maximumDate) {\n          return false;\n        }\n      });\n\n      // Drop the last selection value since they are all incremented\n      // by half of a dataset precision unit, and the last value to\n      // meet the date range criteria will actually be drawn outside\n      // the range indicated by the x-axis ticks.\n      // We could accomplish the same thing by looking ahead in the\n      // above for loop, but throwing away the last value seemed easier\n      // with regard to bounds checking and so forth.\n      selectionValues.length = selectionValues.length - 1;\n\n      // Because of the way the data is displayed, it is valid for a\n      // selection to begin on the last datum and end on the last datum\n      // + 1 <datasetPrecision> unit. Therefore we need to check to see\n      // our selection's end date is after the last date in the actual\n      // values and append a surrogate value to the filtered array with\n      // an appropriate date to show as the end of the x scale.\n      if (lastChartDatum.date < maximumDate) {\n        selectionValues.push(lastChartDatum);\n      }\n\n      // Only at this point can we define the true \"last\" datum.\n      lastSelectionDatum = _.last(selectionValues);\n\n      // If there is a non-null value immediately before the start of the\n      // selection, then force the first value to be halfway between the\n      // first selected datum and the preceding datum in order to keep the\n      // line consistent.\n      //\n      // Otherwise leave firstSelectionValueAmount false and let\n      // transformValuesForRendering choose how to extend the selection\n      // area (which it will do if firstSelectionValueAmount is falsey).\n      if (!_.isNull(prevOutOfBoundsDatum.filtered)) {\n        firstSelectionValueAmount = (\n          firstSelectionDatum.filtered + prevOutOfBoundsDatum.filtered\n        ) / 2;\n      }\n\n      // If there is a non-null value immediately after the end of the\n      // selection, then force the last value to be halfway between the\n      // last selected datum and the following datum in order to keep the\n      // line consistent.\n      //\n      // Otherwise leave lastSelectionValueAmount false and let\n      // transformValuesForRendering choose how to extend the selection\n      // area (which it will do if lastSelectionValueAmount is falsey).\n      if (!_.isNull(nextOutOfBoundsDatum.filtered)) {\n        lastSelectionValueAmount = (\n          lastSelectionDatum.filtered + nextOutOfBoundsDatum.filtered\n        ) / 2;\n      }\n\n      return transformValuesForRendering(\n        selectionValues,\n        firstSelectionValueAmount,\n        lastSelectionValueAmount\n      );\n    }\n\n    var minDate;\n    var maxDate;\n    var line;\n    var area;\n    var svgChart;\n    var selection;\n    var selectionStartPosition;\n    var selectionEndPosition;\n    var labelWidth;\n    var minLabelWidth;\n    var labelNegativeXOffset;\n    var dateRangeLabel;\n    var dateRangeFlyoutLabel;\n    var labelLeftOffset;\n    var labelRightPosition;\n    var selectionDelta;\n    var margin;\n    var values;\n    var transformedMinDate;\n    var transformedMaxDate;\n    var labelTextAlign;\n    var dataAggregate;\n    var unfilteredAggregate;\n    var filteredAggregate;\n\n    if (_.isNull(d3XScale) || _.isNull(d3YScale)) {\n      return;\n    }\n\n    if (selectionStartDate < selectionEndDate) {\n      minDate = selectionStartDate;\n      maxDate = selectionEndDate;\n    } else {\n      minDate = selectionEndDate;\n      maxDate = selectionStartDate;\n    }\n\n    if (!_.isNull(minDate) && !_.isNull(maxDate)) {\n\n      // If the effective selection will not change because the selection\n      // start and end dates have not changed, quit early.\n      if (!_.isNull(renderedSelectionStartDate) &&\n          !_.isNull(renderedSelectionEndDate) &&\n          selectionStartDate.getTime() === renderedSelectionStartDate.getTime() &&\n          selectionEndDate.getTime() === renderedSelectionEndDate.getTime()) {\n        // Note that even if we are quitting early we still may need to\n        // show the selection (since it may be possible that the same\n        // interval was previously rendered but is now just hidden).\n        $chartSelectionElement.show();\n        return;\n      }\n\n      margin = Constants.TIMELINE_CHART_MARGIN;\n\n      values = [\n        deriveSelectionValues(cachedChartData, minDate, maxDate)\n      ];\n\n      // Reset minDate and maxDate to accurately reflect the 'half-way'\n      // interpolated values created by transformValuesForRendering.\n      transformedMinDate = _.first(values[0]).date;\n      transformedMaxDate = _.last(values[0]).date;\n\n      line = d3.\n        svg.\n        line().\n        defined(function(d) { return !_.isNull(d.filtered); }).\n        x(function(d) { return d3XScale(d.date); }).\n        y(function(d) { return d3YScale(d.filtered); });\n\n      area = d3.\n        svg.\n        area().\n        defined(line.defined()).\n        x(line.x()).\n        y0(function() { return d3YScale(0); }).\n        y1(line.y());\n\n      svgChart = d3ChartElement.\n        select('svg.timeline-chart-selection').\n        attr('width', cachedChartDimensions.width).\n        attr('height', cachedChartDimensions.height).\n        select('g').\n        attr('transform', 'translate(' + margin.LEFT + ',' + margin.TOP + ')');\n\n      selection = svgChart.\n        selectAll('path').\n        data(values);\n\n      selection.\n        enter().\n        append('path');\n\n      selection.\n        exit().\n        remove();\n\n      selection.\n        attr('class', 'selection').\n        attr('d', area);\n\n      svgChart.\n        append('path').\n        data(values).\n        attr('class', 'selection-trace').\n        attr('d', line);\n\n      selectionStartPosition = Math.floor(d3XScale(transformedMinDate));\n\n      // Subtract one from the scaled and transformed maxDate in order to\n      // prevent d3 from giving us a value that is outside the actual\n      // element to which we are rendering.\n      selectionEndPosition = Math.floor(d3XScale(transformedMaxDate)) - 1;\n\n      $leftSelectionMarker.css(\n        {\n          left: selectionStartPosition -\n            Constants.TIMELINE_CHART_SELECTION_MARKER_NEGATIVE_X_OFFSET -\n            (Constants.TIMELINE_CHART_DRAG_HANDLE_WIDTH / 2),\n          height: cachedChartDimensions.height - margin.TOP - margin.BOTTOM\n        }\n      );\n\n      $rightSelectionMarker.css(\n        {\n          left: selectionEndPosition -\n            Constants.TIMELINE_CHART_SELECTION_MARKER_NEGATIVE_X_OFFSET +\n            (Constants.TIMELINE_CHART_DRAG_HANDLE_WIDTH / 2),\n          height: cachedChartDimensions.height - margin.TOP - margin.BOTTOM\n        }\n      );\n\n      labelWidth = Math.floor(d3XScale(transformedMaxDate) - d3XScale(transformedMinDate));\n      minLabelWidth = Constants.TIMELINE_CHART_MIN_LABEL_WIDTH;\n      labelNegativeXOffset = 0;\n\n      if (labelWidth < minLabelWidth) {\n        labelNegativeXOffset = (minLabelWidth - labelWidth) / 2;\n        labelWidth = minLabelWidth;\n      }\n\n      dateRangeLabel = formatDateRangeLabel(minDate, maxDate);\n\n      // Bounds-check the position of the label and keep it from\n      // overflowing the card bounds\n      labelLeftOffset = selectionStartPosition - labelNegativeXOffset;\n\n      if (labelLeftOffset < -(Constants.TIMELINE_CHART_GUTTER)) {\n        labelLeftOffset = -(Constants.TIMELINE_CHART_GUTTER);\n      }\n\n      labelRightPosition = labelLeftOffset + labelWidth;\n      if (labelRightPosition > cachedChartDimensions.width) {\n        selectionDelta = labelRightPosition - cachedChartDimensions.width;\n        labelLeftOffset = labelLeftOffset -\n          selectionDelta + Constants.TIMELINE_CHART_GUTTER;\n      }\n\n      labelTextAlign = 'center';\n\n      if (labelLeftOffset < 0) {\n\n        labelTextAlign = 'left';\n        labelWidth += labelLeftOffset;\n        labelLeftOffset = 0;\n\n      } else if ((labelLeftOffset + labelWidth) > cachedChartDimensions.width) {\n\n        labelWidth += (cachedChartDimensions.width - (labelLeftOffset + labelWidth));\n        labelLeftOffset = cachedChartDimensions.width - labelWidth;\n        labelTextAlign = 'right';\n\n      }\n\n      // Adding aggregate and label data to the label for flyout.\n      dataAggregate = cachedChartData.values.\n        filter(function(datum) {\n          return datum.date.getTime() >= selectionStartDate.getTime() &&\n                 datum.date.getTime() < selectionEndDate.getTime();\n        });\n\n      unfilteredAggregate = dataAggregate.\n        reduce(function(acc, datum) {\n          return acc + datum.unfiltered;\n        }, 0);\n\n      filteredAggregate = dataAggregate.\n        reduce(function(acc, datum) {\n          return acc + datum.filtered;\n        }, 0);\n\n      dateRangeFlyoutLabel = '{0} - {1}'.\n        format(formatDateLabel(minDate, true), formatDateLabel(maxDate, true));\n\n      $clearSelectionLabel.\n        attr('data-start', selectionStartDate).\n        attr('data-end', selectionEndDate).\n        attr('data-aggregate-unfiltered', unfilteredAggregate).\n        attr('data-aggregate-filtered', filteredAggregate).\n        attr('data-flyout-label', dateRangeFlyoutLabel).\n        html(dateRangeLabel).\n        css({\n          left: labelLeftOffset,\n          width: labelWidth,\n          // The '- 1' term accounts for the 1 pixel y-axis.\n          height: Constants.TIMELINE_CHART_MARGIN.BOTTOM - 1,\n          textAlign: labelTextAlign,\n          top: cachedChartDimensions.height -\n            Constants.TIMELINE_CHART_MARGIN.TOP -\n            Constants.TIMELINE_CHART_MARGIN.BOTTOM\n        });\n\n      $chartSelectionElement.show();\n\n      renderedSelectionStartDate = selectionStartDate;\n      renderedSelectionEndDate = selectionEndDate;\n\n    }\n\n  }\n\n  function clearChartSelection() {\n\n    selectionIsCurrentlyRendered = false;\n    selectionStartDate = null;\n    selectionEndDate = null;\n    renderedSelectionStartDate = null;\n    renderedSelectionEndDate = null;\n    $chartSelectionElement.hide();\n    $chartElement.removeClass('selected');\n\n  }\n\n  function enterDraggingState() {\n    currentlyDragging = true;\n    selectionIsCurrentlyRendered = false;\n    hideDatumLabel();\n    $chartElement.find('.timeline-chart-filtered-mask').hide();\n    $body.addClass('prevent-user-select');\n    $chartElement.removeClass('selected').addClass('selecting');\n  }\n\n  function enterSelectedState() {\n    currentlyDragging = false;\n    selectionIsCurrentlyRendered = true;\n    hideDatumLabel();\n    renderChartFilteredValues();\n    $chartElement.find('.timeline-chart-filtered-mask').show();\n    $body.removeClass('prevent-user-select');\n    $chartElement.removeClass('selecting').addClass('selected');\n  }\n\n  function enterDefaultState() {\n    currentlyDragging = false;\n    selectionIsCurrentlyRendered = false;\n    clearChartSelection();\n    hideDatumLabel();\n    if (d3XScale && d3YScale) {\n      // Check if d3 scales exist before attempting to render filtered values.\n      // This is mainly needed for the onload case when enterDefaultState is called\n      // and the chart has a width/height of zero, so the scales are still null.\n      renderChartFilteredValues();\n    }\n    $body.removeClass('prevent-user-select');\n    $chartElement.removeClass('selecting').removeClass('selected');\n  }\n\n  function requestChartFilterByCurrentSelection() {\n    self.emitEvent(\n      'SOCRATA_VISUALIZATION_TIMELINE_FILTER',\n      {\n        // Todo: Change this to emit ISO-8601 strings rather than instances of\n        // moment.\n        start: selectionStartDate,\n        end: selectionEndDate\n      }\n    );\n  }\n\n  function requestChartFilterReset() {\n    self.emitEvent('SOCRATA_VISUALIZATION_TIMELINE_FILTER', null);\n  }\n\n  /**\n   * @param {Number} offsetX - The left offset of the mosue cursor into\n   *                           the visualization, in pixels.\n   * @return {Date} The date to which the mouse position is mapped by\n   *                d3's x-scale.\n   */\n  function getDateFromMousePosition(offsetX) {\n\n    var date = d3XScale.invert(offsetX);\n\n    // Clear out unneeded precision from the date objects.\n    if (datasetPrecision === 'YEAR') {\n      date.setMonth(0);\n    } else if (datasetPrecision === 'MONTH') {\n      date.setDate(1);\n    }\n\n    date.setMilliseconds(0);\n    date.setSeconds(0);\n    date.setMinutes(0);\n    date.setHours(0);\n\n    return date;\n\n  }\n\n  /**\n   * @param {number} offsetX - The offset of the mouse pointer into the\n   *                           visualization, in pixels\n   * @param {DOM Element} target - The DOM element receiving the mouse\n   *                               event.\n   */\n  function setSelectionStartAndEndDateByMousePosition(offsetX, target) {\n\n    var candidateSelectionEndDate = null;\n\n    if (mousePositionWithinChartLabels) {\n\n      candidateSelectionEndDate = target.getAttribute('data-end');\n\n      if (candidateSelectionEndDate === null) {\n        return;\n      }\n\n      candidateSelectionEndDate = new Date(candidateSelectionEndDate);\n\n      if (candidateSelectionEndDate <= selectionStartDate) {\n        candidateSelectionEndDate = new Date(target.getAttribute('data-start'));\n      }\n\n    } else if (mousePositionWithinChartDisplay) {\n\n      candidateSelectionEndDate = getDateFromMousePosition(offsetX + visualizedDatumWidth);\n\n    } else {\n\n      candidateSelectionEndDate = selectionEndDate;\n\n    }\n\n    if (candidateSelectionEndDate !== null && selectionStartDate !== null) {\n\n      // Prevent null selections by auto-incrementing by a\n      // 'datasetPrecision' unit if the calculated start and end dates\n      // are the same.\n      if (candidateSelectionEndDate.getTime() === selectionStartDate.getTime()) {\n        candidateSelectionEndDate = getDateFromMousePosition(\n          offsetX + halfVisualizedDatumWidth + visualizedDatumWidth);\n      }\n\n      if (candidateSelectionEndDate < cachedChartData.minDate) {\n        candidateSelectionEndDate = cachedChartData.minDate;\n      }\n\n      if (candidateSelectionEndDate > cachedChartData.maxDate) {\n        candidateSelectionEndDate = moment(cachedChartData.maxDate).\n          add(1, datasetPrecision).toDate();\n      }\n\n      setCurrentDatumByDate(candidateSelectionEndDate);\n\n      selectionEndDate = candidateSelectionEndDate;\n\n      // Handle the special case wherein the start and end dates can end\n      // up identical. This can happen when the cursor is placed on the\n      // '0th' pixel of the interval. We solve it by selectively adding\n      // or subtracting one <datasetPrecision> unit to/from the end date,\n      // depending on whether or not subtracting from the end date would\n      // put us outside the x-axis scale.\n      if (selectionStartDate.getTime() === selectionEndDate.getTime()) {\n        if (selectionStartDate.getTime() === cachedChartData.minDate.getTime()) {\n          selectionEndDate = moment(selectionEndDate).\n            add(1, datasetPrecision).toDate();\n        } else {\n          selectionEndDate = moment(selectionEndDate).\n            subtract(1, datasetPrecision).toDate();\n        }\n      }\n\n    }\n\n  }\n\n  /**\n   * Interprets clicking and dragging and applies the expected state\n   * transitions before conditionally rendering the chart selection.\n   *\n   * @param {Object} mouseStatus\n   *   @property {Boolean} leftButtonPressed\n   *   @property {Object} position\n   *     @property {Number} clientX\n   *     @property {Number} clientY\n   */\n  function handleChartSelectionEvents(mouseStatus) {\n\n    function selectionIsExactlyTheSameAsHasBeenRendered(startDate, endDate) {\n\n      return !_.isNull(renderedSelectionStartDate) &&\n             !_.isNull(renderedSelectionEndDate) &&\n             startDate.getTime() === renderedSelectionStartDate.getTime() &&\n             endDate.getTime() === renderedSelectionEndDate.getTime();\n    }\n\n    var offsetX;\n    var offsetY;\n    var candidateStartDate;\n    var targetIsClearSelection =\n      $(mouseStatus.position.target).is('.timeline-chart-clear-selection-button') ||\n      $(mouseStatus.position.target).is('.timeline-chart-clear-selection-label');\n    var chartHasNotRendered =\n      _.isNull(cachedChartDimensions) ||\n      _.isNull(element.offset());\n\n\n    // Fail early if the chart hasn't rendered itself at all yet or\n    // if we are clicking the 'Clear selection' label.\n    if (chartHasNotRendered || targetIsClearSelection) {\n      return;\n    }\n\n    offsetX = mouseStatus.position.clientX - element.offset().left + halfVisualizedDatumWidth;\n    offsetY = mouseStatus.position.clientY - element.get(0).getBoundingClientRect().top;\n\n    // Mouse down while not dragging (start selecting):\n    if (mouseStatus.leftButtonPressed && !currentlyDragging) {\n\n      if (mousePositionWithinChartLabels) {\n\n        candidateStartDate = mouseStatus.position.target.getAttribute('data-start');\n        if (!_.isNull(candidateStartDate)) {\n          selectionStartDate = new Date(candidateStartDate);\n          selectionEndDate = new Date(mouseStatus.position.target.getAttribute('data-end'));\n          enterDraggingState();\n        }\n\n      } else if (mousePositionWithinChartElement) {\n\n        // The target markers on the left and right of the selection have\n        //  a 'data-selection-target' attribute value of 'left' and\n        // 'right', respectively. Attempting to get that attribute on any\n        // other element (e.g. the chart itself or, more specifically,\n        // the highlight target that sits on top of it) will return null,\n        // which will be caught by the default case and treated as a\n        // normal selection-start event.\n        switch (mouseStatus.position.target.getAttribute('data-selection-target')) {\n          case 'left':\n            selectionStartDate = selectionEndDate;\n            selectionEndDate = getDateFromMousePosition(offsetX);\n            break;\n          case 'right':\n            break;\n          default:\n\n            // If the mouse is inside the chart element and inside the\n            // chart display, then we can just do the drag selection as\n            // normal.\n            if (mousePositionWithinChartDisplay) {\n\n              selectionStartDate = getDateFromMousePosition(offsetX);\n              selectionEndDate = getDateFromMousePosition(offsetX + visualizedDatumWidth);\n\n              if (selectionStartDate.getTime() === selectionEndDate.getTime()) {\n                selectionEndDate = moment(selectionEndDate).add(1, datasetPrecision).toDate();\n              }\n\n              // If the user is clicking on the same selection again,\n              // then we deselect it.\n              if (selectionIsExactlyTheSameAsHasBeenRendered(selectionStartDate, selectionEndDate)) {\n                enterDefaultState();\n                requestChartFilterReset();\n                return;\n              }\n\n            } else {\n\n              // If the mouse is above the chart, do not enter a dragging\n              // state because this will try to filter using the topmost\n              // y-tick as a target, which will cause unexpected behavior.\n              if (offsetY < 0) {\n                return;\n              }\n\n              // If the mouse is inside the chart element but outside the\n              // chart display, then it must be in the left or right\n              // margin, in which case we want to anchor the min or max\n              // date to the chart's min or max date and make the\n              // selection 1 display unit wide.\n              if (offsetX < cachedChartDimensions.width / 2) {\n                selectionStartDate = cachedChartData.minDate;\n                selectionEndDate = moment(cachedChartData.minDate).\n                  add(1, datasetPrecision).toDate();\n              } else {\n                selectionStartDate = moment(cachedChartData.maxDate).\n                  add(1, datasetPrecision).toDate();\n                selectionEndDate = cachedChartData.maxDate;\n              }\n\n            }\n            break;\n        }\n\n        enterDraggingState();\n\n      }\n\n    }\n\n    // Mouse up while dragging (stop selecting):\n    if (currentlyDragging && !mouseStatus.leftButtonPressed) {\n\n      clearChartHighlight();\n\n      if (selectionStartDate > selectionEndDate) {\n\n        // candidateStartDate is used here as a temporary variable\n        // when swapping the two values so that the selectionStartDate\n        // always occurs before the selectionEndDate.\n        candidateStartDate = selectionStartDate;\n        selectionStartDate = selectionEndDate;\n        selectionEndDate = candidateStartDate;\n      }\n\n      if (selectionStartDate.getTime() === selectionEndDate.getTime()) {\n        selectionEndDate = moment(selectionEndDate).add(1, datasetPrecision).toDate();\n      }\n\n      enterSelectedState();\n\n      requestChartFilterByCurrentSelection();\n\n    }\n\n  }\n\n  function handleClearSelectionLabelMousedownEvent() {\n    requestChartFilterReset();\n    enterDefaultState();\n  }\n\n  /**\n   * @param {DOM Element} target - A DOM element with data attributes\n   *                               describing an interval's start date,\n   *                               end date, filtered and unfiltered\n   *                               values and the formatted flyout label.\n   */\n  function highlightChartByInterval(target) {\n    var startDate;\n    var endDate;\n    startDate = new Date(target.getAttribute('data-start'));\n    endDate = new Date(target.getAttribute('data-end'));\n    hideDatumLabel();\n    highlightChart(startDate, endDate);\n  }\n\n  /**\n   * This function renders the white highlight on the visualization.\n   * This rendering is agnostic to how the underlying data has been filtered\n   * and simply takes a subset of the full chart data and renders it in a\n   * similar fashion to how the filtered and unfiltered chart data\n   * is rendered.\n   *\n   * This function also determines flyout positioning by drawing\n   * a small line where the flyout should be positioned.\n   *\n   * @param {Object} highlightData - The output of either\n   *                                 filterChartDataByOffset\n   *                                 or filterChartDataByInterval.\n   */\n  function renderChartHighlight(highlightData) {\n\n    var highlightArea;\n    var flyoutPosition;\n    var selection;\n\n    if (_.isNull(d3XScale) || _.isNull(d3YScale)) {\n      return;\n    }\n\n    var targetMargin = Constants.TIMELINE_CHART_HIGHLIGHT_TARGET_MARGIN;\n    var gutter = Constants.TIMELINE_CHART_GUTTER;\n\n    var cardWidth = cachedChartDimensions.width;\n    var width = highlightData.width + (targetMargin * 2);\n    var leftPos = highlightData.left - targetMargin;\n    width = Math.min(width, cardWidth + gutter - leftPos);\n    // Previously, the line below read:\n    //\n    // leftPos = Math.max(leftPos, -gutter);\n    //\n    // Presumably this was to allow selection of the timeline chart to occur\n    // outside the rendered chart in Data Lens: the cards have extra margins\n    // around the periphery and it made sense to enable people to start the\n    // selection to the left of the left edge of the visualization, or to the\n    // right of the right edge (if selecting from right to left).\n    //\n    // Unfortunately, this breaks the visualization in other contexts (it leaks\n    // out of its container, potentially covering other elements in the DOM\n    // where it clearly should not) so we will need to figure out a better\n    // solution for that. In the meantime, selection behavior may be impaired.\n    leftPos = Math.max(0, Math.min(leftPos, cardWidth - width));\n\n    $highlightTargetElement.css({\n      left: leftPos,\n      width: width,\n      height: cachedChartDimensions.height - Constants.TIMELINE_CHART_MARGIN.BOTTOM\n    });\n\n    highlightArea = d3.\n      svg.\n      area().\n      x(function(d) { return d3XScale(d.date); }).\n      y0(cachedChartDimensions.height - Constants.TIMELINE_CHART_MARGIN.BOTTOM).\n      y1(d3YScale(highlightData.maxValue));\n\n    d3ChartElement.\n      select('svg.timeline-chart-highlight-container').\n      select('g').\n      remove();\n\n    selection = d3ChartElement.\n      select('svg.timeline-chart-highlight-container').\n      attr('width', highlightData.width).\n      attr('height', cachedChartDimensions.height - Constants.TIMELINE_CHART_MARGIN.BOTTOM).\n      append('g');\n\n    selection.\n      append('path').\n      datum(highlightData.data).\n      attr('class', 'timeline-chart-highlight').\n      attr('d', highlightArea);\n\n    // This function determines the vertical position of the flyout.\n    // It always positions the flyout above all timeline paths.\n    function flyoutVerticalPosition() {\n      var hoveringWithinSelection =\n        currentDatum.date >= selectionStartDate && currentDatum.date <= selectionEndDate;\n\n      return (selectionIsCurrentlyRendered && !hoveringWithinSelection) ?\n        d3YScale(_.max([currentDatum.unfiltered, 0])) :\n        d3YScale(_.max([currentDatum.unfiltered, currentDatum.filtered, 0]));\n    }\n\n    // Sets the x and y flyout position.\n    flyoutPosition = d3.\n      svg.\n      line().\n      x(function(d) { return d3XScale(d.date); }).\n      y(flyoutVerticalPosition());\n\n    // This is the actual svg element that flyouts are\n    // positioned on.\n    selection.\n      append('path').\n      datum(highlightData.data).\n      attr('class', 'timeline-chart-flyout-target').\n      attr('d', flyoutPosition);\n\n  }\n\n  function clearChartHighlight() {\n    // Since we attach event handlers before the visualization has rendered for\n    // the first time, it is possible that we have never cached the chart\n    // dimensions (cachedChartDimensions, below). As such, attempting to clear\n    // the chart highlight (which is triggered by moving the mouse over the\n    // container) will attempt to read the `.height` property of `null` and\n    // report an uncaught TypeError.\n    //\n    // To avoid this, we only actually attempt to clear the chart highlight if\n    // we have cached the chart dimensions.\n    if (cachedChartDimensions) {\n\n      element.find('.timeline-chart-highlight-container > g > path').remove();\n      element.find('.timeline-chart-highlight-container').\n        css('height', cachedChartDimensions.height - Constants.TIMELINE_CHART_MARGIN.BOTTOM);\n    }\n  }\n\n  /**\n   * @param {Date} startDate\n   * @param {Date} endDate\n   */\n  function highlightChart(startDate, endDate) {\n    var highlightData;\n    setCurrentDatumByDate(startDate);\n    highlightData = filterChartDataByInterval(\n      startDate,\n      endDate\n    );\n    renderChartHighlight(highlightData);\n  }\n\n  /**\n   * @param {Number} offsetX - The left offset of the mouse cursor into\n   *                           the visualization, in pixels.\n   */\n  function highlightChartByMouseOffset(offsetX) {\n    var highlightData;\n    if (mousePositionWithinChartDisplay || mousePositionWithinChartLabels) {\n      highlightData = filterChartDataByOffset(offsetX);\n      renderChartHighlight(highlightData);\n      hideDatumLabel();\n    }\n  }\n\n  /**\n   * @param {Number} offsetX - The left offset of the mouse cursor into\n   *                           the visualization, in pixels.\n   */\n  function highlightChartWithHiddenLabelsByMouseOffset(offsetX) {\n\n    var indexIntoChartData;\n    var startDate;\n    var endDate;\n    var currentPrecision;\n    var datumLabelOffset;\n    var datumLabelWidth;\n\n    indexIntoChartData = Math.floor(((offsetX - 1) / cachedChartDimensions.width) *\n      cachedChartData.values.length);\n\n    // Note that currentDatum is a global variable that is set when the\n    // user hovers over the visualization. The value of currentDatum is\n    // read by the flyout code.\n    currentDatum = cachedChartData.values[indexIntoChartData];\n\n    // If we are hovering within the labels and they are all shown, we should use\n    // the label precision.  Otherwise, because labels are hidden, we should use\n    // the smaller datasetPrecision.\n    currentPrecision = (mousePositionWithinChartLabels && allChartLabelsShown) ?\n      labelPrecision : datasetPrecision;\n\n    startDate = currentDatum.date;\n    endDate = new Date(moment(currentDatum.date).add(1, currentPrecision).toDate());\n\n    // Dim existing labels and add text and attribute information to the datum label.\n    $chartElement.addClass('dimmed');\n    $datumLabel.\n      text(formatDateLabel(startDate, false, currentPrecision)).\n      attr('data-start', startDate).\n      attr('data-end', endDate).\n      attr('data-aggregate-unfiltered', currentDatum.unfiltered).\n      attr('data-aggregate-filtered', currentDatum.filtered).\n      attr('data-flyout-label', formatDateLabel(startDate, true, currentPrecision));\n\n    // Now that the datum label has text (and thus a width), calculate its\n    // left offset.  Make sure it does not overflow either edge of the chart.\n    datumLabelWidth = $datumLabel.width();\n    datumLabelOffset = Math.ceil(d3XScale(startDate));\n    datumLabelOffset = (datumLabelOffset > (datumLabelWidth / 2)) ?\n       datumLabelOffset - (datumLabelWidth / 2) : 0;\n    datumLabelOffset = Math.min(\n      datumLabelOffset,\n      cachedChartDimensions.width - datumLabelWidth\n    );\n\n    // Set the left offset and show the label.\n    $datumLabel.\n      css('left', Math.floor(datumLabelOffset)).\n      show();\n\n    highlightChart(startDate, endDate);\n\n  }\n\n  /**\n   * Data can be filtered by the x-offset of the cursor from the left\n   * edge of the chart or by arbitrary intervals specified with start-\n   * and end Date objects.\n   *\n   * The two filter functions each have a SIDE-EFFECT: they both set\n   * the global 'currentDatum' variable to a synthetic value which is\n   * used by the flyout code to keep the highlighted areas and their\n   * corresponding flyout labels in sync.\n   *\n   * @param {Number} offsetX - The left offset of the mouse cursor into the\n   *                           visualization, in pixels.\n   * @return {Object}\n   *   @property {Array} highlightData - The data for the start and end\n   *                                     date including the unfiltered\n   *                                     and filtered values.\n   *   @property {Number} left - The left offset of the selection,\n   *                             in pixels.\n   *   @property {Number} width - The width of one <datum>, in pixels.\n   *   @property {Number} maxValue - the maximum unfiltered value in the\n   *                                 latest data request.\n   */\n  function filterChartDataByOffset(offsetX) {\n\n    var indexIntoChartData;\n    var transformedStartDate;\n    var transformedEndDate;\n    var highlightData;\n    var leftOffset;\n    var width = visualizedDatumWidth;\n    var maxValue = cachedChartData.maxValue;\n\n    indexIntoChartData = Math.floor(((offsetX - 1) / cachedChartDimensions.width) *\n      cachedChartData.values.length);\n\n    // Note that currentDatum is a global variable that is set when the\n    // user hovers over the visualization. The value of currentDatum is\n    // read by the flyout code.\n    currentDatum = cachedChartData.values[indexIntoChartData];\n\n    transformedStartDate = DateHelpers.decrementDateByHalfInterval(\n      currentDatum.date, datasetPrecision\n    );\n    transformedEndDate = DateHelpers.decrementDateByHalfInterval(\n      moment(currentDatum.date).add(1, datasetPrecision).toDate(), datasetPrecision\n    );\n\n    highlightData = [\n      { date: transformedStartDate },\n      { date: transformedEndDate }\n    ];\n\n    leftOffset = d3XScale(transformedStartDate);\n\n    return {\n      data: highlightData,\n      left: leftOffset,\n      width: width,\n      maxValue: maxValue\n    };\n\n  }\n\n  function hideDatumLabel() {\n    $datumLabel.hide();\n    $chartElement.removeClass('dimmed');\n  }\n\n  /**\n   * This is used to keep the flyout updated as you drag a selection\n   * marker.\n   */\n  function setCurrentDatumByDate(date) {\n    currentDatum = _.find(cachedChartData.values, function(value) {\n      return value.date >= date;\n    });\n  }\n\n  /**\n   * Converts a date and a unit into a string representation.\n   *\n   * @param {Date} labelDate - The date to format.\n   * @param {Boolean} useFullMonthNames - Whether or not the date should\n   *                                      be rendered with full month\n   *                                      names.\n   * @param {String} overriddenLabelPrecision - An optional precision\n   *                                            to use in favor of the\n   *                                            globally-defined dataset\n   *                                            precision. Must be one of\n   *                                            'decade', 'year', 'month'\n   *                                            or 'day'.\n   * @return {String} The formatted date.\n   */\n  function formatDateLabel(labelDate, useFullMonthNames, overriddenLabelPrecision) {\n\n    var labelPrecisionToUse = overriddenLabelPrecision || labelPrecision;\n    var label;\n\n    switch (labelPrecisionToUse) {\n\n      case 'DECADE':\n        label = Math.floor(labelDate.getFullYear() / 10) + '0s';\n        break;\n\n      case 'YEAR':\n        label = labelDate.getFullYear();\n        break;\n\n      case 'MONTH':\n        if (useFullMonthNames) {\n          label = '{0} {1}'.format(\n            moment(labelDate).format('MMMM'),\n            labelDate.getFullYear()\n          );\n        } else {\n          label = \"{0} '{1}\".format(\n            moment(labelDate).format('MMM'),\n            '0{0}'.format(labelDate.getFullYear() % 100).slice(-2)\n          );\n        }\n        break;\n\n      case 'DAY':\n        if (useFullMonthNames) {\n          label = '{0} {1} {2}'.format(\n            labelDate.getDate(),\n            moment(labelDate).format('MMMM'),\n            labelDate.getFullYear()\n          );\n        } else {\n          label = '{0} {1}'.format(\n            labelDate.getDate(),\n            moment(labelDate).format('MMM')\n          );\n        }\n        break;\n\n      default:\n        throw new Error(\n          'Cannot format date label for unrecognized unit \"{0}\".'.format(labelPrecisionToUse));\n\n    }\n\n    return label;\n\n  }\n\n  /**\n   * Returns a bundle of stuff about the data points occurring between\n   * two points in time.\n   *\n   * @param {Date} startDate\n   * @param {Date} endDate\n   * @return {Object}\n   *   @property {Array} highlightData - The data for the start and end\n   *                                     date including the unfiltered\n   *                                     and filtered values.\n   *   @property {Number} left - The left offset of the selection,\n   *                             in pixels.\n   *   @property {Number} width - The width of the selection, in pixels.\n   *   @property {Number} maxValue - The maximum unfiltered value in the\n   *                                 latest data request.\n   */\n  function filterChartDataByInterval(startDate, endDate) {\n\n    var transformedStartDate = DateHelpers.decrementDateByHalfInterval(\n      startDate, datasetPrecision);\n    var transformedEndDate = DateHelpers.decrementDateByHalfInterval(\n      endDate, datasetPrecision);\n    var highlightData;\n    var leftOffset = d3XScale(transformedStartDate);\n    var width = d3XScale(transformedEndDate) - leftOffset;\n    var maxValue = cachedChartData.maxValue;\n\n    highlightData = [\n      { date: transformedStartDate },\n      { date: transformedEndDate }\n    ];\n\n    return {\n      data: highlightData,\n      left: leftOffset,\n      width: width,\n      maxValue: maxValue\n    };\n\n  }\n\n  /**\n   * @param {Number} offsetX - The left offset of the mouse cursor into\n   *                           the visualization, in pixels.\n   * @param {Number} offsetY - The top offset of the mouse cursor into\n   *                           the visualization, in pixels.\n   * @return {Boolean}\n   */\n  function isMouseWithinChartDisplay(offsetX, offsetY) {\n\n    return offsetX > 0.5 &&\n      offsetX <= cachedChartDimensions.width &&\n      offsetY > 0 &&\n      offsetY <= cachedChartDimensions.height -\n        Constants.TIMELINE_CHART_MARGIN.BOTTOM;\n\n  }\n\n  /**\n   * @param {Number} offsetX - The left offset of the mouse cursor into\n   *                           the visualization, in pixels.\n   * @param {Number} offsetY - The top offset of the mouse cursor into\n   *                           the visualization, in pixels.\n   * @return {Boolean}\n   */\n  function isMouseWithinChartLabels(offsetX, offsetY) {\n    return offsetX > 0 &&\n      offsetX <= cachedChartDimensions.width &&\n      offsetY > cachedChartDimensions.height -\n        Constants.TIMELINE_CHART_MARGIN.BOTTOM &&\n      offsetY <= cachedChartDimensions.height;\n\n  }\n\n  /**\n   * @param {DOM Element} target - The DOM element belonging to this\n   *                               instance of the visualization.\n   * @return {Boolean}\n   */\n  function isMouseOverChartElement(target) {\n    return $(target).closest('.timeline-chart').get(0) === _chartElement[0];\n  }\n\n  function leftMouseButtonStateHasChanged(event) {\n    var payload = {\n      leftButtonPressed: event.type == 'mousedown',\n      position: {\n        clientX: event.clientX,\n        clientY: event.clientY,\n        target: event.target\n      }\n    };\n\n    handleChartSelectionEvents(payload);\n    mouseHasMoved(payload.position, payload.leftButtonPressed);\n  }\n\n  function mouseHasMoved(mousePosition, mouseLeftButtonNowPressed) {\n    var offsetX;\n    var offsetY;\n    var mousePositionTarget = mousePosition.target;\n\n    // Work-around for browsers with no pointer-event support.\n    //mousePositionTarget = FlyoutService.targetUnder();\n\n    var $mousePositionTarget = $(mousePositionTarget);\n    var mousePositionIsClearButton = $mousePositionTarget.\n      hasClass('timeline-chart-clear-selection-button');\n    var mousePositionIsSelectionLabel = $mousePositionTarget.\n      hasClass('timeline-chart-clear-selection-label');\n\n    // Fail early if the chart hasn't rendered itself at all yet.\n    if (_.isNull(cachedChartDimensions) || _.isNull(element.offset())) {\n      return;\n    }\n\n    offsetX = mousePosition.clientX - element.offset().left;\n\n    // The method 'getBoundingClientRect().top' must be used here\n    // because the offset of expanded cards changes as the window\n    // scrolls.\n    offsetY = mousePosition.clientY - element.get(0).getBoundingClientRect().top;\n\n    // mousePositionWithinChartElement is a global variable that is\n    // used elsewhere as well\n    mousePositionWithinChartElement = isMouseOverChartElement(mousePositionTarget);\n\n    // First figure out which region (display, labels, outside) of the\n    // visualization the mouse is currently over and cache the result\n    // for this and other functions to use.\n    //\n    // mousePositionWithinChartDisplay and\n    // mousePositionWithinChartLabels are both also global variables\n    // that are used elsewhere as well.\n    if (isMouseWithinChartDisplay(offsetX, offsetY) && mousePositionWithinChartElement) {\n      mousePositionWithinChartDisplay = true;\n      mousePositionWithinChartLabels = false;\n    } else if (isMouseWithinChartLabels(offsetX, offsetY) && mousePositionWithinChartElement) {\n      mousePositionWithinChartDisplay = false;\n      mousePositionWithinChartLabels = true;\n    } else {\n      mousePositionWithinChartDisplay = false;\n      mousePositionWithinChartLabels = false;\n    }\n\n    // If we are currently dragging, then we need to update and\n    // re-render the selected area.\n    if (currentlyDragging) {\n      setSelectionStartAndEndDateByMousePosition(offsetX, mousePositionTarget);\n      renderChartSelection();\n    // Otherwise we need to update and render an appropriate highlight\n    // (by mouse position if the mouse is within the display or by\n    // interval if the mouse is over the chart labels).\n    } else {\n      if (mousePositionWithinChartDisplay) {\n        if (!allChartLabelsShown) {\n          highlightChartWithHiddenLabelsByMouseOffset(offsetX, mousePositionTarget);\n        } else {\n          highlightChartByMouseOffset(offsetX, mousePositionTarget);\n        }\n      } else if (mousePositionWithinChartLabels && !mouseLeftButtonNowPressed) {\n        // Clear the chart highlight if the mouse is currently over the\n        // 'clear chart selection' button.\n        if (mousePositionIsClearButton) {\n          clearChartHighlight();\n          hideDatumLabel();\n        // Otherwise, render a highlight over the interval indicated by\n        // the label that is currently under the mouse.\n        } else {\n          if (!allChartLabelsShown && !mousePositionIsSelectionLabel) {\n            highlightChartWithHiddenLabelsByMouseOffset(offsetX, mousePositionTarget);\n          } else {\n            highlightChartByInterval(mousePosition.target);\n          }\n        }\n      } else {\n        $chartElement.find('.x-tick-label').removeClass('emphasis');\n        hideDatumLabel();\n        clearChartHighlight();\n      }\n    }\n  }\n\n  function mouseHasLeftChart() {\n    hideDatumLabel();\n    hideFlyout();\n    clearChartHighlight();\n  }\n}\n\nmodule.exports = TimelineChart;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/views/TimelineChart.js\n ** module id = 14\n ** module chunks = 0\n **/","'use strict';\n\nvar $ = require('jquery');\nvar utils = require('socrata-utils');\nvar Visualization = require('./Visualization.js');\nvar _ = require('lodash');\nvar DataTypeFormatter = require('./DataTypeFormatter.js');\n\nmodule.exports = function Table(element, vif) {\n  _.extend(this, new Visualization(element, vif));\n\n  var SORT_ICON_WIDTH = 32;\n\n  var self = this;\n  var _lastRenderData;\n  var _lastRenderOptions;\n  var _scrollbarHeightPx;\n\n  // If defined, this is an object that maps column name to pixel widths.\n  // See freezeColumnWidths().\n  var _columnWidths;\n\n  utils.assertHasProperties(\n    vif,\n    'configuration.localization.LATITUDE',\n    'configuration.localization.LONGITUDE',\n    'configuration.localization.NO_COLUMN_DESCRIPTION'\n  );\n\n  _attachEvents(this.element);\n\n  /**\n   * Public Methods\n   */\n\n  this.render = function(data, options) {\n    utils.assertHasProperties(data, 'rows', 'columns');\n    if (_.isEqual(_lastRenderData, data) && _.isEqual(_lastRenderOptions, options)) {\n      return;\n    }\n\n    _lastRenderData = data;\n    _lastRenderOptions = options;\n\n    _render(data, options);\n  };\n\n  /**\n   * Compute how many rows can fit into the given pixel height (taking into account header\n   * size).\n   * NOTE: This assumes each row is the same vertical height, no matter the content.\n   * Currently this is true due to how the table is styled. Caveat emptor.\n   */\n  this.howManyRowsCanFitInHeight = function(overallHeightPx) {\n    if (!_.isFinite(overallHeightPx)) {\n      return 0;\n    }\n\n    var headerHeightPx;\n    var rowHeightPx;\n    var heightLeftAfterHeaderPx;\n    var maxRowCount;\n    var numberOfRows;\n    var alreadyHasData = _lastRenderData && _lastRenderOptions && _lastRenderData.rows.length > 0;\n\n    // We need some data in the table to do the measurements.\n    // If there is none there, render a placeholder.\n    if (!alreadyHasData) {\n      // Render sample data into the table. Used for UI element measurement.\n      self.render(\n        {\n          columns: [ { fieldName: 'placeholder', renderTypeName: 'text' } ],\n          rows: [ [ 'placeholder' ] ]\n        },\n        [ {} ]\n      );\n    }\n\n    utils.assertInstanceOf(element.find('thead')[0], HTMLElement);\n    utils.assertInstanceOf(element.find('tbody tr')[0], HTMLElement);\n\n    // Measure.\n    headerHeightPx = element.find('thead').outerHeight();\n    rowHeightPx = element.find('tbody tr').outerHeight();\n\n    // Compute\n    heightLeftAfterHeaderPx = overallHeightPx - headerHeightPx - _scrollbarHeightPx;\n    numberOfRows = heightLeftAfterHeaderPx / rowHeightPx;\n\n    if (_.isFinite(numberOfRows)) {\n      maxRowCount = Math.max(0, Math.floor(numberOfRows));\n    } else {\n      maxRowCount = 0;\n    }\n\n    // If we rendered placeholder data, remove it.\n    if (!alreadyHasData) {\n      element.find('.table-container').remove();\n    }\n\n    return maxRowCount;\n  };\n\n  this.destroy = function() {\n    _detachEvents(this.element);\n    this.element.find('.socrata-table').remove();\n  };\n\n  // Causes all columns to maintain their absolute widths, regardless of any new content.\n  // If a column is added after this function is called, the new column will get a default\n  // width of 150px.\n  this.freezeColumnWidthsAndRender = function() {\n    // TODO If we implement persistent column resizing, this function\n    // should be modified to simply return columnWidths for later use\n    // as a render option.\n    var headerWidths = element.find('thead th').map(function() {\n      return this.getBoundingClientRect().width;\n    });\n\n    var columns = _.pluck(_lastRenderData.columns, 'fieldName');\n\n    _columnWidths = _.zipObject(\n      columns,\n      headerWidths\n    );\n\n    _render(_lastRenderData, _lastRenderOptions);\n  };\n\n  /**\n   * Private Methods\n   */\n\n  function _templateTableCell(column, cell) {\n    return [\n      '<td data-cell-render-type=\"{renderTypeName}\">',\n        '<div>',\n          DataTypeFormatter.renderCell(cell, column, {\n            latitude: vif.configuration.localization.LATITUDE,\n            longitude: vif.configuration.localization.LONGITUDE\n          }),\n        '</div>',\n      '</td>'\n    ].join('').format(column);\n  }\n\n  function _templateTableSortedHeader() {\n    return [\n      '<th data-column-name=\"{columnName}\" data-column-description=\"{columnDescription}\" data-column-render-type=\"{renderTypeName}\" data-sort scope=\"col\">',\n        '<div>{columnTitle}<span class=\"icon-{sortDirection}\"></span></div>',\n      '</th>'\n    ].join('');\n  }\n\n  function _templateTableUnsortableHeader() {\n    return [\n      '<th data-column-name=\"{columnName}\" data-column-description=\"{columnDescription}\" data-column-render-type=\"{renderTypeName}\" scope=\"col\">',\n        '<div>{columnTitle}</div>',\n      '</th>'\n    ].join('');\n  }\n\n  function _templateTableHeader() {\n    return [\n      '<th data-column-name=\"{columnName}\" data-column-description=\"{columnDescription}\" data-column-render-type=\"{renderTypeName}\" scope=\"col\">',\n        '<div>{columnTitle}<span class=\"icon-arrow-down\"></span></div>',\n      '</th>'\n    ].join('');\n  }\n\n  function _templateTable(data, options) {\n    var activeSort = options[0];\n\n    return _.flatten([\n      '<div class=\"socrata-table\">',\n        '<table>',\n          '<thead>',\n            '<tr>',\n              data.columns.map(function(column) {\n                var template;\n\n                if (_isGeometryType(column)) {\n                  template = _templateTableUnsortableHeader();\n                } else {\n                  template = activeSort.columnName === column.fieldName ?\n                    _templateTableSortedHeader() :\n                    _templateTableHeader();\n                }\n\n                return template.format({\n                  columnName: column.fieldName,\n                  columnTitle: (column && column.name) || column.fieldName,\n                  columnDescription: (column && column.description) || '',\n                  renderTypeName: (column && column.renderTypeName) || '',\n                  sortDirection: activeSort.ascending ? 'arrow-down' : 'arrow-up'\n                });\n              }),\n            '</tr>',\n          '</thead>',\n          '<tbody>',\n            _.map(data.rows, function(row) {\n              if (!row) {\n                return '<tr class=\"null-row\"></tr>';\n              }\n\n              return '<tr>' + data.columns.map(function(column, columnIndex) {\n                return _templateTableCell(column, row[columnIndex]);\n              }).join('\\n') + '</tr>';\n            }),\n          '</tbody>',\n        '</table>',\n      '</div>'\n    ]).join('\\n');\n  }\n\n  function _render(data, options) {\n    var $existingTable = self.element.find('.socrata-table');\n    var $template = $(_templateTable(data, options));\n    var scrollLeft = _.get($existingTable, '[0].scrollLeft') || 0;\n    var $newTable;\n\n    _applyFrozenColumns($template);\n\n    if ($existingTable.length) {\n      $existingTable.replaceWith($template);\n    } else {\n      self.element.append($template);\n    }\n\n    $newTable = self.element.find('.socrata-table');\n    $newTable[0].scrollLeft = scrollLeft;\n\n    // Cache the scrollbar height for later use.\n    _scrollbarHeightPx = _scrollbarHeightPx || $newTable[0].offsetHeight - $newTable[0].clientHeight;\n  }\n\n  function _attachEvents() {\n    self.element.on('click', '.socrata-table thead th', _handleRowHeaderClick);\n\n    self.element.on('mouseenter mousemove', '.socrata-table thead th', _showDescriptionFlyout);\n    self.element.on('mouseleave', '.socrata-table thead th', _hideDescriptionFlyout);\n\n    self.element.on('mouseenter mousemove', '.socrata-table tbody td', _showCellFlyout);\n    self.element.on('mouseleave', '.socrata-table tbody td', _hideCellFlyout);\n  }\n\n  function _detachEvents() {\n    self.element.off('click', '.socrata-table thead th', _handleRowHeaderClick);\n\n    self.element.off('mouseenter mousemove', '.socrata-table thead th', _showDescriptionFlyout);\n    self.element.off('mouseleave', '.socrata-table thead th', _hideDescriptionFlyout);\n\n    self.element.off('mouseenter mousemove', '.socrata-table tbody td', _showCellFlyout);\n    self.element.off('mouseleave', '.socrata-table tbody td', _hideCellFlyout);\n  }\n\n  function _showDescriptionFlyout(event) {\n    var $target = $(event.currentTarget);\n    var noColumnDescription = '<em>{noColumnDescription}</em>';\n    var description = $target.data('column-description') || noColumnDescription;\n    var content = [\n      '<span>{title}</span><br>',\n      '<span>{description}</span>'\n    ].join('\\n');\n\n    content = content.format({\n      title: $target.text(),\n      description: description,\n      noColumnDescription: vif.configuration.localization.NO_COLUMN_DESCRIPTION\n    });\n\n    self.emitEvent(\n      'SOCRATA_VISUALIZATION_COLUMN_FLYOUT',\n      {\n        element: $target[0],\n        content: content,\n        belowTarget: true,\n        rightSideHint: false\n      }\n    );\n  }\n\n  function _hideDescriptionFlyout() {\n    self.emitEvent(\n      'SOCRATA_VISUALIZATION_COLUMN_FLYOUT',\n      null\n    );\n  }\n\n  function _showCellFlyout(event) {\n    var $target = $(event.currentTarget).find('div');\n    var data = $target.text();\n    var overflowing = $target[0].clientWidth < $target[0].scrollWidth;\n\n    if (overflowing) {\n      self.emitEvent(\n        'SOCRATA_VISUALIZATION_CELL_FLYOUT',\n        {\n          element: $target[0],\n          content: data,\n          belowTarget: true,\n          rightSideHint: false\n        }\n      );\n    }\n  }\n\n  function _hideCellFlyout() {\n    self.emitEvent(\n      'SOCRATA_VISUALIZATION_CELL_FLYOUT',\n      null\n    );\n  }\n\n  function _isGeometryType(column) {\n    return _.includes([\n      'point',\n      'multipoint',\n      'line',\n      'multiline',\n      'polygon',\n      'multipolygon',\n      'location'\n    ], column.renderTypeName);\n  }\n\n  function _handleRowHeaderClick() {\n    var columnName = this.getAttribute('data-column-name');\n    var columnRenderType = this.getAttribute('data-column-render-type');\n\n    if (columnName && !_isGeometryType({renderTypeName: columnRenderType})) {\n      self.emitEvent('SOCRATA_VISUALIZATION_COLUMN_CLICKED', columnName);\n    }\n  }\n\n  function _applyFrozenColumns($template) {\n    $template.toggleClass('frozen-columns', !!_columnWidths);\n    $template.find('thead th').each(function() {\n      var $th = $(this);\n      var columnName = $th.attr('data-column-name');\n      var frozenWidth = _.get(_columnWidths, columnName, 150);\n      $th.width(frozenWidth + SORT_ICON_WIDTH);\n    });\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/views/Table.js\n ** module id = 15\n ** module chunks = 0\n **/","'use strict';\n\n'use strict';\nvar utils = require('socrata-utils');\nvar moment = require('moment');\n\nmodule.exports = {\n  renderCell: renderCell,\n  renderBooleanCell: renderBooleanCell,\n  renderNumberCell: renderNumberCell,\n  renderGeoCell: renderGeoCell,\n  renderGeoCellHTML: renderGeoCellHTML,\n  renderMoneyCell: renderMoneyCell,\n  renderTimestampCell: renderTimestampCell\n};\n\nfunction renderCell(cellContent, column, i18n) {\n  var cellText;\n\n  utils.assertIsOneOfTypes(column, 'object');\n  utils.assertHasProperty(column, 'renderTypeName');\n\n  if (_.isUndefined(cellContent)) {\n    return '';\n  }\n\n  switch (column.renderTypeName) {\n    case 'checkbox':\n      cellText = _.escape(renderBooleanCell(cellContent, column));\n      break;\n    case 'number':\n      cellText = _.escape(renderNumberCell(cellContent, column));\n      break;\n\n    // Avoid escaping because cell content is HTML.\n    case 'geo_entity':\n    case 'point':\n      cellText = renderGeoCellHTML(cellContent, column, i18n);\n      break;\n    case 'calendar_date':\n      cellText = _.escape(renderTimestampCell(cellContent, column));\n      break;\n    case 'money':\n      cellText = _.escape(renderMoneyCell(cellContent, column));\n      break;\n    default:\n      cellText = _.escape(cellContent);\n      break;\n  }\n  return cellText;\n}\n\n\n\n/**\n* Renders a boolean value in checkbox format\n*/\nfunction renderBooleanCell(cellContent) {\n  return _.isBoolean(cellContent) && cellContent ? '✓' : '';\n}\n\n/**\n* Render a number based on column specified formatting.\n* This has lots of possible options, so we delegate to helpers.\n*/\nfunction renderNumberCell(input, column) {\n  if (_.isNull(input) || _.isUndefined(input) || input.toString().length === 0) {\n    return '';\n  }\n\n  var amount = parseFloat(input);\n\n  var format = _.extend({\n    precisionStyle: 'standard',\n    precision: undefined,\n    noCommas: false,\n    currency: '$',\n    decimalSeparator: '.',\n    groupSeparator: ',',\n    mask: null\n  }, column.format || {});\n\n  format.commaifyOptions = {\n    decimalCharacter: format.decimalSeparator,\n    groupCharacter: format.groupSeparator\n  };\n\n  if (column.dataTypeName === 'percent') {\n    return _renderPercentageNumber(amount, format);\n  } else if (format.mask) {\n    return _renderMaskedNumber(amount, format);\n  } else {\n    switch (format.precisionStyle) {\n      case 'percentage':\n        return _renderPercentageNumber(amount, format);\n      case 'scientific':\n        return _renderScientificNumber(amount, format);\n      case 'currency':\n        return _renderCurrencyNumber(amount, format);\n      case 'financial':\n        return _renderFinancialNumber(amount, format);\n      case 'standard':\n      default:\n        return _renderStandardNumber(amount, format);\n    }\n  }\n}\n\n/**\n* Renders a Point in plain text as a lat/lng pair.\n*/\nfunction renderGeoCell(cellContent) {\n  var latitudeIndex = 1;\n  var longitudeIndex = 0;\n  var coordinates = _cellCoordinates(cellContent);\n  if (coordinates) {\n    return '({latitude}°, {longitude}°)'.format({\n      latitude: coordinates[latitudeIndex],\n      longitude: coordinates[longitudeIndex]\n    });\n  } else {\n    return '';\n  }\n}\n\n/**\n* Renders a Point wrapped in an HTML span element\n*\n* Parameters:\n* - cellContent: data for the cell (from soda fountain).\n* - i18n: Object containing localized strings for latitude and longitude. Example:\n*   {\n*     latitude: 'Latitude',\n*     longitude: 'Longitude'\n*   }\n*/\nfunction renderGeoCellHTML(cellContent, columnMetadata, i18n) {\n  var latitudeIndex = 1;\n  var longitudeIndex = 0;\n  var coordinates = _cellCoordinates(cellContent);\n\n  utils.assertHasProperties(i18n, 'latitude', 'longitude');\n  if (coordinates) {\n    var template = '<span title=\"{0}\">{1}°</span>';\n    var latitude = template.format(i18n.latitude, coordinates[latitudeIndex]);\n    var longitude = template.format(i18n.longitude, coordinates[longitudeIndex]);\n    return '({latitude}, {longitude})'.format({\n      latitude: latitude,\n      longitude: longitude\n    });\n  } else {\n    return '';\n  }\n}\n\n/**\n* Render a numeric value as currency\n*/\nfunction renderMoneyCell(cellContent, column) {\n  var format = _.extend({\n    currency: '$',\n    decimalSeparator: '.',\n    groupSeparator: ',',\n    humane: false,\n    precision: 2\n  }, column.format || {});\n  var amount = parseFloat(cellContent);\n\n  if (_.isFinite(amount)) {\n    if (format.humane) {\n      // We can't use formatNumber here because this use case is\n      // slightly different — we want to enforce a certain precision,\n      // whereas the normal humane numbers want to use the fewest\n      // digits possible at all times.\n      // The handling on thousands-scale numbers is also different,\n      // because humane currency will always be expressed with the K\n      // scale suffix, whereas our normal humane numbers allow four-\n      // digit thousands output.\n      var absVal = Math.abs(amount);\n      if (absVal < 1000) {\n        cellContent = absVal.toFixed(format.precision).\n          replace('.', format.decimalSeparator);\n      } else {\n        // At this point, we know that we're going to use a suffix for\n        // scale, so we lean on commaify to split up the scale groups.\n        // The number of groups can be used to select the correct\n        // scale suffix, and we can do precision-related formatting\n        // by taking the first two scale groups and treating them\n        // as a float.\n        // For instance, \"12,345,678\" will become an array of three\n        // substrings, and the first two will combine into \"12.345\"\n        // so that our toFixed call can work its magic.\n        var scaleGroupedVal = utils.commaify(Math.floor(absVal)).split(',');\n        var symbols = ['K', 'M', 'B', 'T', 'P', 'E', 'Z', 'Y'];\n        var symbolIndex = scaleGroupedVal.length - 2;\n\n        var value = parseFloat(scaleGroupedVal[0] + '.' + scaleGroupedVal[1]);\n        value = value.toFixed(format.precision);\n        if (parseFloat(value) === 1000) {\n          // The only edge case is when rounding takes us into the\n          // next scale group: 999,999 should be 1M not 1000K.\n          value = '1';\n          if (format.precision > 0) {\n            value += '.' + _.repeat('0', format.precision);\n          }\n          symbolIndex++;\n        }\n\n        cellContent = value.replace('.', format.decimalSeparator) + symbols[symbolIndex];\n      }\n    } else {\n      // Normal formatting without abbreviation.\n      var commaifyOptions = {\n        groupCharacter: format.groupSeparator,\n        decimalCharacter: format.decimalSeparator\n      };\n\n      cellContent = utils.commaify(\n        Math.abs(amount).toFixed(format.precision),\n        commaifyOptions\n      );\n    }\n    cellContent = '{sign}{currency}{cellContent}'.format({\n      sign: amount < 0 ? '-' : '',\n      currency: format.currency,\n      cellContent: cellContent\n    });\n  }\n  return cellContent;\n}\n\n/**\n* Render a date or timestamp following column formatting, otherwise following defaults.\n*/\nfunction renderTimestampCell(cellContent, column) {\n  if (!_.isEmpty(cellContent)) {\n    var time = moment(new Date(cellContent));\n    if (time.isValid()) {\n      if (column.format && column.format.formatString) {\n        // Option A: format using user-specified format string\n        return time.format(column.format.formatString);\n      } else if (time.hour() + time.minute() + time.second() + time.millisecond() === 0) {\n        // Option B: infer date-only string format\n        return time.format('YYYY MMM DD');\n      } else {\n        // Option C: use date-with-time format\n        return time.format('YYYY MMM DD hh:mm:ss A');\n      }\n    }\n  }\n  return '';\n}\n\n/**\n * hoisted helper methods below\n * (must belong to this scope in order to access $window)\n */\n\nfunction _renderCurrencyNumber(amount, format) {\n  var isNegative = amount < 0;\n\n  var value = Math.abs(amount);\n  if (format.precision >= 0) {\n    value = value.toFixed(format.precision);\n  }\n\n  value = utils.commaify(value, format.commaifyOptions);\n  if (format.noCommas) {\n    value = value.replace(new RegExp('\\\\' + format.groupSeparator, 'g'), '');\n  }\n\n  return '{sign}{currency}{value}'.format({\n    sign: isNegative ? '-' : '',\n    currency: format.currency,\n    value: value\n  });\n}\n\nfunction _renderFinancialNumber(amount, format) {\n  var isNegative = amount < 0;\n\n  var value = Math.abs(amount);\n  if (format.precision >= 0) {\n    value = value.toFixed(format.precision);\n  }\n\n  value = utils.commaify(value, format.commaifyOptions);\n  if (format.noCommas) {\n    value = value.replace(new RegExp('\\\\' + format.groupSeparator, 'g'), '');\n  }\n\n  if (isNegative) {\n    return '({0})'.format(value);\n  } else {\n    return String(value);\n  }\n}\n\nfunction _renderScientificNumber(amount, format) {\n  var value =  amount.toExponential(format.precision);\n\n  // no groups, so we can skip groupSeparator and commaify and noCommas\n  return value.replace('.', format.decimalSeparator);\n}\n\nfunction _renderPercentageNumber(amount, format) {\n  var value = amount;\n  if (format.precision >= 0) {\n    value = value.toFixed(format.precision);\n  }\n\n  value = utils.commaify(value, format.commaifyOptions);\n  if (format.noCommas) {\n    value = value.replace(new RegExp('\\\\' + format.groupSeparator, 'g'), '');\n  }\n\n  return value + '%';\n}\n\nfunction _renderStandardNumber(amount, format) {\n  var value = amount;\n  if (format.precision >= 0) {\n    value = value.toFixed(format.precision);\n  }\n\n  if (/^-?\\d{4}$/.test(value)) {\n    return value;\n  }\n\n  value = utils.commaify(value, format.commaifyOptions);\n  // Force commaify off for four-digit numbers (workaround for year columns)\n  if (format.noCommas) {\n    value = value.replace(new RegExp('\\\\' + format.groupSeparator, 'g'), '');\n  }\n\n  return value;\n}\n\n// NOTE: In the dataset view, a mask can lead to some really strange output.\n// We're going to start with a simple approach and refine as we go on.\nfunction _renderMaskedNumber(amount, format) {\n  var maskChar = '#';\n  var amountChars = String(amount).split('');\n  var output = format.mask.slice(0, amountChars.length);\n\n  while (output.indexOf(maskChar) > -1) {\n    output = output.replace(maskChar, amountChars.shift());\n  }\n  output += amountChars.join('');\n\n  return output;\n}\n\nfunction _cellCoordinates(cellContent) {\n  var coordinates = _.get(cellContent, 'value.coordinates', cellContent.coordinates);\n  return _.isArray(coordinates) ? coordinates : null;\n}\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/views/DataTypeFormatter.js\n ** module id = 16\n ** module chunks = 0\n **/","'use strict';\n\nvar utils = require('socrata-utils');\nvar Visualization = require('./Visualization');\nvar L = require('leaflet');\nvar _ = require('lodash');\nvar $ = require('jquery');\n\nvar FEATURE_MAP_MIN_HOVER_THRESHOLD = 5;\nvar FEATURE_MAP_MAX_ZOOM = 18; // same as Leaflet default\nvar FEATURE_MAP_MAX_TILE_DENSITY = 256 * 256;\nvar FEATURE_MAP_TILE_OVERLAP_ZOOM_THRESHOLD = 6;\nvar FEATURE_MAP_ZOOM_DEBOUNCE_INTERVAL = 200;\nvar FEATURE_MAP_RESIZE_DEBOUNCE_INTERVAL = 250;\nvar FEATURE_MAP_FLYOUT_Y_OFFSET = 1.25;\nvar FEATURE_MAP_ROW_INSPECTOR_QUERY_BOX_PADDING = 1;\nvar FEATURE_MAP_ROW_INSPECTOR_MAX_ROW_DENSITY = 100;\nvar FEATURE_MAP_DEFAULT_HOVER = true;\nvar FEATURE_MAP_DEFAULT_PAN_AND_ZOOM = true;\nvar FEATURE_MAP_DEFAULT_LOCATE_USER = false;\n\nfunction FeatureMap(element, vif) {\n\n  _.extend(this, new Visualization(element, vif));\n\n  var self = this;\n\n  var _mapContainer;\n  var _mapElement;\n  var _mapPanZoomDisabledWarning;\n  var _mapLocateUserButton;\n  // This is the element that will be displayed as a marker.\n  var _userCurrentPositionIcon;\n  // This is the actual marker as it exists on the map. We keep this\n  // reference so that we can remove the existing marker if the user\n  // clicks the 'locate me' button more than one time.\n  var _userCurrentPositionMarker;\n  var _userCurrentPositionBounds;\n\n  var _defaultMapOptions = {\n    attributionControl: false,\n    center: [47.609895, -122.330259], // Center on Seattle by default.\n    keyboard: false,\n    scrollWheelZoom: false,\n    zoom: 1,\n    zoomControlPosition: 'topleft',\n    maxZoom: FEATURE_MAP_MAX_ZOOM\n  };\n  var _mapOptions;\n  var _debug;\n  var _hover;\n  var _panAndZoom;\n  var _locateUser;\n  var _startResizeFn;\n  var _completeResizeFn;\n  var _baseTileLayer;\n  var _map;\n  var _lastRenderOptions;\n\n  // We buffer feature layers so that there isn't a visible flash\n  // of emptiness when we transition from one to the next. This is accomplished\n  // by only removing the previous layers when the current one completes rendering.\n\n  // We also keep a handle on the current feature layer Url so we know which of\n  // the existing layers we can safely remove (i.e. not the current one).\n  var _featureLayers = {};\n  var _flyoutData = {};\n  var _currentLayerId;\n\n  _debug = vif.configuration.debug;\n  _hover = (_.isUndefined(vif.configuration.hover)) ? FEATURE_MAP_DEFAULT_HOVER : vif.configuration.hover;\n  _panAndZoom = (_.isUndefined(vif.configuration.panAndZoom)) ? FEATURE_MAP_DEFAULT_PAN_AND_ZOOM : vif.configuration.panAndZoom;\n  _locateUser = !(vif.configuration.locateUser && ('geolocation' in navigator)) ? FEATURE_MAP_DEFAULT_LOCATE_USER : vif.configuration.locateUser;\n\n  _mapOptions = _.merge(_defaultMapOptions, vif.configuration.mapOptions);\n\n  // Render template here so that we can modify the map container's styles\n  // below.\n  _renderTemplate(this.element);\n\n  // CORE-4832: Disable pan and zoom on feature map\n  if (!_panAndZoom) {\n\n    _mapOptions = _.merge(\n      _mapOptions,\n      {\n        dragging: false,\n        zoomControl: false,\n        touchZoom: false,\n        scrollWheelZoom: false,\n        doubleClickZoom: false,\n        boxZoom: false\n      }\n    );\n\n    _mapContainer.css('cursor', 'default');\n    _mapPanZoomDisabledWarning.show();\n  }\n\n  /**\n   * Public methods\n   */\n\n  this.render = function(renderOptions) {\n\n    if (_mapElement.width() > 0 && _mapElement.height() > 0) {\n\n      var boundsChanged;\n      var baseLayerChanged;\n      var vectorTileGetterChanged;\n\n      // Emit render start event\n      _emitRenderStart();\n\n      if (!_map) {\n\n        // Construct leaflet map\n        _map = L.map(_mapElement[0], _mapOptions);\n        // Attach events on first render only\n        _attachEvents(this.element);\n      }\n\n      boundsChanged = renderOptions.bounds !== _.get(_lastRenderOptions, 'bounds');\n      baseLayerChanged = renderOptions.baseLayer !== _.get(_lastRenderOptions, 'baseLayer');\n      vectorTileGetterChanged = renderOptions.vectorTileGetter !== _.get(_lastRenderOptions, 'vectorTileGetter');\n\n      _lastRenderOptions = _.cloneDeep(renderOptions);\n      _lastRenderOptions.bounds = new L.LatLngBounds(\n        renderOptions.bounds.getSouthWest(),\n        renderOptions.bounds.getNorthEast()\n      );\n\n      if (_userCurrentPositionBounds) {\n        _fitBounds(_userCurrentPositionBounds);\n      } else if (boundsChanged) {\n        _fitBounds(renderOptions.bounds);\n      }\n\n      if (baseLayerChanged) {\n        _updateBaseLayer(renderOptions.baseLayer.url, renderOptions.baseLayer.opacity);\n      }\n\n      if (vectorTileGetterChanged) {\n        _createNewFeatureLayer(renderOptions.vectorTileGetter);\n      }\n\n      // Emit render complete event\n      _emitRenderComplete();\n    }\n  };\n\n  this.renderError = function() {\n    console.error('There was an error rendering this feature map');\n  };\n\n  this.invalidateSize = function() {\n    if (_map) {\n      _map.invalidateSize();\n    }\n  };\n\n  this.destroy = function() {\n\n    if (_map) {\n\n      _detachEvents(this.element);\n\n      // Remove the map after detaching events since `_detachEvents()` expects\n      // the `_map` instance to exist.\n      _map.remove();\n    }\n\n    // Finally, clear out the container.\n    this.element.empty();\n  };\n\n  /**\n   * Private methods\n   */\n\n  function _renderTemplate(el) {\n\n    var mapElement = $(\n      '<div>',\n      {\n        'class': 'feature-map'\n      }\n    );\n\n    var mapLegend = $(\n      '<div>',\n      {\n        'class': 'feature-map-legend'\n      }\n    );\n\n    var mapPanZoomDisabledWarningIcon = $(\n      '<div>',\n      {\n        'class': 'icon-warning feature-map-pan-zoom-disabled-warning-icon'\n      }\n    );\n\n    var mapPanZoomDisabledWarning = $(\n      '<div>',\n      {\n        'class': 'feature-map-pan-zoom-disabled-warning'\n      }\n    ).append(mapPanZoomDisabledWarningIcon);\n\n    var mapContainer = $(\n      '<div>',\n      {\n        'class': 'feature-map-container'\n      }\n    ).append([\n      mapElement,\n      mapLegend,\n      mapPanZoomDisabledWarning\n    ]);\n\n    if (_locateUser) {\n\n      var mapLocateUserIcon = $(\n        '<svg class=\"feature-map-locate-user-icon\" viewBox=\"-289 381 32 32\">' +\n        '<polygon class=\"st0\" points=\"-262.5,386.5 -285.5,398 -274,398 -274,409.5 \"/>' +\n        '</svg>'\n      );\n\n      var mapLocateUserBusySpinner = $(\n        '<div>',\n        {\n          'class': 'feature-map-locate-user-busy-spinner'\n        }\n      );\n\n      var mapLocateUserErrorIcon = $(\n        '<svg class=\"feature-map-locate-user-error-icon\" viewBox=\"0 0 1024 1024\">' +\n        '<path fill=\"rgb(68, 68, 68)\" d=\"M978.77 846.495c16.932 33.178 15.816 64.164-3.348 95.176-19.907 31.693-48.312 46.49-85.212 46.49h-756.762c-36.869 0-65.275-14.802-85.181-46.49-18.417-30.264-19.907-61.788-4.434-95.713l378.399-756.495c19.164-36.869 49.055-55.183 89.615-55.183 41.303 0 70.825 18.519 88.561 55.388l378.363 756.828zM455.409 867.517c15.503 15.442 34.324 23.194 56.438 23.194 22.139 0 40.929-7.752 56.438-23.194 15.442-15.503 23.194-34.294 23.194-56.438s-7.752-40.929-23.194-56.438c-15.503-15.503-34.294-23.255-56.438-23.255-22.108 0-40.929 7.752-56.438 23.255-15.473 15.503-23.224 34.294-23.224 56.438s7.752 40.934 23.224 56.438zM450.56 291.84v337.92h122.88v-337.92h-122.88z\"/>' +\n        '</svg>'\n      );\n\n      var mapLocateUserButton = $(\n        '<button>',\n        {\n          'class': 'feature-map-locate-user-btn',\n          'data-locate-user-status': 'ready'\n        }\n      ).append([\n        mapLocateUserIcon,\n        mapLocateUserBusySpinner,\n        mapLocateUserErrorIcon\n      ]);\n\n      mapContainer.append(mapLocateUserButton);\n\n      _userCurrentPositionIcon = L.divIcon({ className: 'feature-map-user-current-position-icon' });\n    }\n\n    self.renderAxisLabels(mapContainer);\n\n    // Cache element selections\n    _mapContainer = mapContainer;\n    _mapElement = mapElement;\n    _mapPanZoomDisabledWarning = mapPanZoomDisabledWarning;\n    _mapLocateUserButton = mapLocateUserButton;\n\n    el.append(mapContainer);\n  }\n\n  function _attachEvents() {\n    var $document = $(document);\n\n    // Only attach map events if the map has actually been instantiated.\n    if (_map) {\n      // Map resizes are messy because our map containers are animated. This\n      // causes Leaflet to believe that we are resizing the map n times when\n      // we are really just doing it once but lerping between the container\n      // sizes. To work around this we can debounce the event twice--once on\n      // the leading edge and once on the trailing edge--to simulate 'start'\n      // and 'stop' events for the resize.\n      _startResizeFn = _.debounce(\n        function() {\n          // We will need to record the current min and max latitude of the\n          // viewport here so that we can reset the viewport to capture a\n          // similar vertical area after the resize event completes.\n        },\n        FEATURE_MAP_RESIZE_DEBOUNCE_INTERVAL,\n        {\n          leading: true,\n          trailing: false\n        }\n      );\n\n      _completeResizeFn = _.debounce(\n        function() {\n          // We will need to reset the viewport using a center point and a\n          // zoom level in order to preserve the 'perceptual' area covered by\n          // the map.\n          // These can be constructed from the min and max latitude of the\n          // pre-resize viewport, which we have conveniently recorded when\n          // the event was originally fired.\n        },\n        FEATURE_MAP_RESIZE_DEBOUNCE_INTERVAL,\n        {\n          leading: false,\n          trailing: true\n        }\n      );\n\n      _map.on('resize', _handleMapResize);\n      _map.on('resize zoomend dragend', _handleExtentChange);\n      _map.on('dragstart zoomstart', _handlePanAndZoom);\n      _map.on('mouseout', _hideFlyout);\n\n      if (_hover) {\n        _map.on('mousemove', _handleMousemove);\n\n        // react to the interactions that would close the RowInspector flannel\n        $document.on('click', _captureLeftClickAndClearHighlight);\n        $document.on('keydown', _captureEscapeAndClearHighlight);\n      }\n\n      _mapPanZoomDisabledWarning.on('mousemove', _handlePanZoomDisabledWarningMousemove);\n      _mapPanZoomDisabledWarning.on('mouseout', _handlePanZoomDisabledWarningMouseout);\n\n      // While this element does not rely on the map existing, it cannot\n      // have any purpose if the map does not exist so we include it in\n      // the check for map existence anyway.\n      if (_locateUser) {\n        _mapLocateUserButton.on('click', _handleLocateUserButtonClick);\n        _mapLocateUserButton.on('mousemove', _handleLocateUserButtonMousemove);\n        _mapLocateUserButton.on('mouseout', _hideFlyout);\n      }\n    }\n\n    $(window).on('resize', _hideRowInspector);\n  }\n\n  function _detachEvents() {\n    var $document = $(document);\n\n    // Only detach map events if the map has actually been instantiated.\n    if (_map) {\n\n      _map.off('resize', _handleMapResize);\n      _map.off('resize dragend zoomend', _handleExtentChange);\n      _map.off('dragstart zoomstart', _handlePanAndZoom);\n      _map.off('mouseout', _hideFlyout);\n\n      if (_hover) {\n        _map.off('mousemove', _handleMousemove);\n\n        $document.on('click', _captureLeftClickAndClearHighlight);\n        $document.on('keydown', _captureEscapeAndClearHighlight);\n      }\n\n      _mapPanZoomDisabledWarning.off('mousemove', _handlePanZoomDisabledWarningMousemove);\n      _mapPanZoomDisabledWarning.off('mouseout', _handlePanZoomDisabledWarningMouseout);\n\n      // While this element does not rely on the map existing, it cannot\n      // have any purpose if the map does not exist so we include it in\n      // the check for map existence anyway.\n      if (_locateUser) {\n        _mapLocateUserButton.off('click', _handleLocateUserButtonClick);\n        _mapLocateUserButton.off('mousemove', _handleLocateUserButtonMousemove);\n        _mapLocateUserButton.off('mouseout', _hideFlyout);\n      }\n    }\n\n    $(window).off('resize', _hideRowInspector);\n  }\n\n  function _emitRenderStart() {\n    self.emitEvent(\n      'SOCRATA_VISUALIZATION_FEATURE_MAP_RENDER_START',\n      null\n    );\n  }\n\n  function _emitRenderComplete() {\n    self.emitEvent(\n      'SOCRATA_VISUALIZATION_FEATURE_MAP_RENDER_COMPLETE',\n      null\n    );\n  }\n\n  function _handleMapResize() {\n\n    // This is debounced and will fire on the leading edge.\n    _startResizeFn();\n    // This is debounced and will fire on the trailing edge.\n    // In the best case, this will be called RESIZE_DEBOUNCE_INTERVAL\n    // milliseconds after the resize event is captured by this handler.\n    _completeResizeFn();\n  }\n\n  function _handleExtentChange() {\n\n    var formattedBounds;\n    var bounds = _map.getBounds();\n\n    if (bounds.isValid()) {\n      formattedBounds = {\n        southwest: [bounds.getSouth(), bounds.getWest()],\n        northeast: [bounds.getNorth(), bounds.getEast()]\n      };\n\n      self.emitEvent(\n        'SOCRATA_VISUALIZATION_FEATURE_MAP_EXTENT_CHANGE',\n        formattedBounds\n      );\n\n      return formattedBounds;\n    }\n  }\n\n  function _handlePanAndZoom() {\n\n    _hideFlyout();\n    _hideRowInspector();\n  }\n\n  function _handleMousemove(event) {\n\n    if (_flyoutData.count > 0) {\n\n      event.originalEvent.target.style.cursor = 'pointer';\n      _showFeatureFlyout(event);\n\n    } else {\n\n      event.originalEvent.target.style.cursor = 'inherit';\n      _hideFlyout();\n\n    }\n\n  }\n\n  function _handlePanZoomDisabledWarningMousemove() {\n    _showPanZoomDisabledWarningFlyout();\n  }\n\n  function _handlePanZoomDisabledWarningMouseout() {\n    _hideFlyout();\n  }\n\n  function _handleLocateUserButtonClick() {\n\n    _updateLocateUserButtonStatus('busy');\n    _showLocateUserButtonFlyout();\n\n    navigator.geolocation.getCurrentPosition(\n      _handleLocateUserSuccess,\n      _handleLocateUserError\n    );\n  }\n\n  function _handleLocateUserSuccess(position) {\n\n    // Test position (City Lights bookstore in San Francisco):\n    //\n    // var userLatLng = new L.LatLng(\n    //   37.79771,\n    //   -122.40647\n    // );\n    var userLatLng = new L.LatLng(\n      position.coords.latitude,\n      position.coords.longitude\n    );\n    var featureBounds = _lastRenderOptions.bounds;\n    var distanceFromBoundsSouthWest;\n    var distanceFromBoundsNorthEast;\n\n    function latLngIsInsideBounds(latLng, bounds) {\n\n      return (\n        latLng.lat >= bounds.getSouthWest().lat &&\n        latLng.lat <= bounds.getNorthEast().lat &&\n        latLng.lng >= bounds.getSouthWest().lng &&\n        latLng.lng <= bounds.getNorthEast().lng\n      );\n    }\n\n    // If the user's current location is within the bounds, then do not\n    // adjust the rendered bounds.\n    if (latLngIsInsideBounds(userLatLng, featureBounds)) {\n\n      _userCurrentPositionBounds = featureBounds;\n\n    // Otherwise, figure out which edge to extend and update the bounds.\n    } else {\n\n      distanceFromBoundsSouthWest = userLatLng.distanceTo(featureBounds.getSouthWest());\n      distanceFromBoundsNorthEast = userLatLng.distanceTo(featureBounds.getNorthEast());\n\n      if (distanceFromBoundsSouthWest <= distanceFromBoundsNorthEast) {\n\n        _userCurrentPositionBounds = L.latLngBounds(userLatLng, featureBounds.getNorthEast());\n\n      } else {\n\n        _userCurrentPositionBounds = L.latLngBounds(featureBounds.getSouthWest(), userLatLng);\n\n      }\n    }\n\n    if (!_userCurrentPositionMarker) {\n\n      _userCurrentPositionMarker = L.marker(\n        userLatLng,\n        {\n          icon: _userCurrentPositionIcon,\n          clickable: false,\n          title: self.getLocalization('USER_CURRENT_POSITION'),\n          alt: self.getLocalization('USER_CURRENT_POSITION')\n        }\n      );\n\n      _userCurrentPositionMarker.addTo(_map);\n\n    } else {\n\n      _userCurrentPositionMarker.update(userLatLng);\n\n    }\n\n    _map.fitBounds(\n      _userCurrentPositionBounds,\n      {\n        animate: true\n      }\n    );\n\n    _updateLocateUserButtonStatus('ready');\n  }\n\n  function _handleLocateUserError() {\n\n    _updateLocateUserButtonStatus('error');\n    _showLocateUserButtonFlyout();\n  }\n\n  function _updateLocateUserButtonStatus(status) {\n\n    utils.assert(\n      status === 'ready' ||\n      status === 'busy' ||\n      status === 'error',\n      'Unrecognized locate user button status: {0}'.format(status)\n    );\n\n    switch (status) {\n\n      case 'ready':\n        _mapLocateUserButton.attr('data-locate-user-status', 'ready');\n        break;\n\n      case 'busy':\n        _mapLocateUserButton.attr('data-locate-user-status', 'busy');\n        break;\n\n      case 'error':\n        _mapLocateUserButton.attr('data-locate-user-status', 'error');\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  function _handleLocateUserButtonMousemove() {\n\n    _showLocateUserButtonFlyout();\n  }\n\n  function _handleVectorTileMousemove(event) {\n\n    if (event.hasOwnProperty('tile')) {\n\n      // Set flyout data and force a refresh of the flyout\n      _flyoutData.offset = {\n        x: event.originalEvent.clientX,\n        y: event.originalEvent.clientY + FEATURE_MAP_FLYOUT_Y_OFFSET\n      };\n      _flyoutData.count = _.sum(event.points, 'count');\n      _flyoutData.totalPoints = event.tile.totalPoints;\n    }\n  }\n\n  function _handleVectorTileClick(event) {\n\n    var inspectorDataQueryConfig;\n\n    if (_flyoutData.count > 0 &&\n      _flyoutData.count <= FEATURE_MAP_ROW_INSPECTOR_MAX_ROW_DENSITY) {\n\n      inspectorDataQueryConfig = {\n        latLng: event.latlng,\n        position: {\n          pageX: event.originalEvent.pageX,\n          pageY: event.originalEvent.pageY\n        },\n        rowCount: _.sum(event.points, 'count'),\n        queryBounds: _getQueryBounds(event.containerPoint)\n      };\n\n      _showRowInspector(inspectorDataQueryConfig);\n\n    }\n  }\n\n  function _handleVectorTileRenderStart() {\n\n    _hideFlyout();\n    _hideRowInspector();\n  }\n\n  function _handleVectorTileRenderComplete() {\n\n    _removeOldFeatureLayers();\n\n    if (_hover) {\n      _map.fire('clearhighlightrequest');\n    }\n  }\n\n  function _showFeatureFlyout(event) {\n    var rowCountUnit;\n    var payload;\n\n    if (_flyoutData.count === 1) {\n      rowCountUnit = (_.has(_lastRenderOptions, 'unit.one')) ? _lastRenderOptions.unit.one : vif.unit.one;\n    } else {\n      rowCountUnit = (_.has(_lastRenderOptions, 'unit.other')) ? _lastRenderOptions.unit.other : vif.unit.other;\n    }\n\n    payload = {\n      title: '{0} {1}'.format(\n        _flyoutData.count,\n        rowCountUnit\n      ),\n      notice: self.getLocalization('FLYOUT_CLICK_TO_INSPECT_NOTICE'),\n      flyoutOffset: {\n        left: event.originalEvent.clientX,\n        top: event.originalEvent.clientY\n      }\n    };\n\n    if (_flyoutData.count > FEATURE_MAP_ROW_INSPECTOR_MAX_ROW_DENSITY) {\n\n      if (_map.getZoom() === FEATURE_MAP_MAX_ZOOM) {\n        payload.notice = self.getLocalization('FLYOUT_FILTER_NOTICE');\n      } else {\n        payload.notice = self.getLocalization('FLYOUT_FILTER_OR_ZOOM_NOTICE');\n      }\n\n      // If the tile we are hovering over has more points then the\n      // TileServer limit or the selected points contain more than the\n      // max number of rows to be displayed on a flannel,\n      // prompt the user to filter and/or zoom in for accurate data.\n      if (_flyoutData.totalPoints >= FEATURE_MAP_MAX_TILE_DENSITY) {\n        payload.title = '{0} {1}'.format(\n          self.getLocalization('FLYOUT_DENSE_DATA_NOTICE'),\n          (_.has(_lastRenderOptions, 'unit.other')) ? _lastRenderOptions.unit.other : vif.unit.other\n        );\n      }\n    }\n\n    self.emitEvent(\n      'SOCRATA_VISUALIZATION_FLYOUT_SHOW',\n      payload\n    );\n  }\n\n  function _showPanZoomDisabledWarningFlyout() {\n\n    var payload = {\n      element: _mapPanZoomDisabledWarning[0],\n      title: self.getLocalization('FLYOUT_PAN_ZOOM_DISABLED_WARNING_TITLE')\n    };\n\n    self.emitEvent(\n      'SOCRATA_VISUALIZATION_FLYOUT_SHOW',\n      payload\n    );\n  }\n\n  function _showLocateUserButtonFlyout() {\n\n    var locateUserStatus = _mapLocateUserButton.attr('data-locate-user-status');\n    var payload;\n\n    if (locateUserStatus === 'ready') {\n\n      payload = {\n        element: _mapLocateUserButton[0],\n        title: self.getLocalization('FLYOUT_CLICK_TO_LOCATE_USER_TITLE'),\n        notice: self.getLocalization('FLYOUT_CLICK_TO_LOCATE_USER_NOTICE')\n      };\n\n    } else if (locateUserStatus === 'busy') {\n\n      payload = {\n        element: _mapLocateUserButton[0],\n        title: self.getLocalization('FLYOUT_LOCATING_USER_TITLE'),\n        notice: null\n      };\n\n    } else {\n\n      payload = {\n        element: _mapLocateUserButton[0],\n        title: self.getLocalization('FLYOUT_LOCATE_USER_ERROR_TITLE'),\n        notice: self.getLocalization('FLYOUT_LOCATE_USER_ERROR_NOTICE')\n      };\n\n    }\n\n    self.emitEvent(\n      'SOCRATA_VISUALIZATION_FLYOUT_SHOW',\n      payload\n    );\n  }\n\n  function _hideFlyout() {\n\n    self.emitEvent(\n      'SOCRATA_VISUALIZATION_FLYOUT_HIDE',\n      null\n    );\n  }\n\n  function _showRowInspector(inspectorDataQueryConfig) {\n\n    var payload = {\n      data: null,\n      position: inspectorDataQueryConfig.position,\n      error: false,\n      message: null\n    };\n\n    // Emit one event to cause the row inspector to be rendered.\n    self.emitEvent(\n      'SOCRATA_VISUALIZATION_ROW_INSPECTOR_SHOW',\n      payload\n    );\n\n    // Emit a second event to initiate a query for the row\n    // data which we intend to inspect.\n    self.emitEvent(\n      'SOCRATA_VISUALIZATION_ROW_INSPECTOR_QUERY',\n      inspectorDataQueryConfig\n    );\n  }\n\n  function _hideRowInspector() {\n\n    self.emitEvent(\n      'SOCRATA_VISUALIZATION_ROW_INSPECTOR_HIDE'\n    );\n\n    _map.fire('clearhighlightrequest');\n  }\n\n  function _captureEscapeAndClearHighlight(event) {\n\n    if (event.which === 27) {\n      _map.fire('clearhighlightrequest');\n    }\n  }\n\n  function _captureLeftClickAndClearHighlight(event) {\n\n    var $target = $(event.target);\n    var isLeftClick = event.which === 1;\n    var isOutsideOfMap = $target.closest('.feature-map-container').length === 0;\n    var isIconClose = $target.is('.icon-close');\n\n    if (isLeftClick && (isOutsideOfMap || isIconClose)) {\n      _map.fire('clearhighlightrequest');\n    }\n  }\n\n  /**\n   * Map behavior\n   */\n\n  function _updateBaseLayer(url, opacity) {\n\n    if (_baseTileLayer) {\n      _map.removeLayer(_baseTileLayer);\n    }\n\n    _baseTileLayer = L.tileLayer(\n      url,\n      {\n        attribution: '',\n        detectRetina: false,\n        opacity: opacity,\n        unloadInvisibleTiles: true\n      }\n    );\n\n    _map.addLayer(_baseTileLayer);\n  }\n\n  /**\n   * Derives a bounding box that contains each element in a set of points\n   * and then causes the map to fit that bounding box within its viewport.\n   *\n   * @param bounds - The Leaflet LatLngBounds object that represents the\n   *   extents of the column's features.\n   */\n  function _fitBounds(bounds) {\n\n    // It is critical to invalidate size prior to updating bounds.\n    // Otherwise, leaflet will fit the bounds to an incorrectly sized viewport.\n    // This manifests itself as the map being zoomed all of the way out.\n    _map.invalidateSize();\n\n    _map.fitBounds(\n      bounds,\n      {\n        animate: false,\n        pan: { animate: false },\n        zoom: { animate: false }\n      }\n    );\n  }\n\n  /**\n   * Creates a new feature layer with a specific tileServer endpoint\n   * and adds it to the map. Because of the way vector tiles are\n   * implemented (in mapbox-vector-tiles.js) it is necessary to\n   * create an entirely new feature layer every time the page's\n   * global where clause changes.\n   *\n   * This function should be used in conjunction with removeOldFeatureLayer\n   * so that there is only ever one active feature layer attached to the\n   * map at a time.\n   *\n   * @param {Object} map - The Leaflet map object.\n   * @param {Function} vectorTileGetter - Function that gets a vector tile\n   */\n  function _createNewFeatureLayer(vectorTileGetter) {\n\n    var layer;\n    var layerId = _.uniqueId();\n    var featureLayerOptions = {\n      // Data requests\n      vectorTileGetter: vectorTileGetter,\n      // Behavior\n      debug: _debug,\n      hover: _hover,\n      debounceMilliseconds: FEATURE_MAP_ZOOM_DEBOUNCE_INTERVAL,\n      rowInspectorMaxRowDensity: FEATURE_MAP_ROW_INSPECTOR_MAX_ROW_DENSITY,\n      maxZoom: FEATURE_MAP_MAX_ZOOM,\n      maxTileDensity: FEATURE_MAP_MAX_TILE_DENSITY,\n      tileOverlapZoomThreshold: FEATURE_MAP_TILE_OVERLAP_ZOOM_THRESHOLD,\n      // Helper functions\n      getFeatureId: _getFeatureId,\n      getFeatureStyle: _getFeatureStyle,\n      getHoverThreshold: _getHoverThreshold,\n      // Event handlers\n      onRenderStart: _handleVectorTileRenderStart,\n      onRenderComplete: _handleVectorTileRenderComplete,\n      onMousemove: _handleVectorTileMousemove,\n      onClick: _handleVectorTileClick\n    };\n\n    // Don't create duplicate layers.\n    if (!_featureLayers.hasOwnProperty(layerId)) {\n\n      layer = new L.TileLayer.VectorTileManager(featureLayerOptions);\n\n      _map.addLayer(layer);\n\n      _featureLayers[layerId] = layer;\n      _currentLayerId = layerId;\n    }\n  }\n\n  /**\n   * Removes existing but out of date feature layers from the map.\n   * This is used in conjunction with `_createNewFeatureLayer()`.\n   */\n  function _removeOldFeatureLayers() {\n\n    Object.keys(_featureLayers).forEach(function(layerId) {\n\n      if (layerId !== _currentLayerId) {\n        _map.removeLayer(_featureLayers[layerId]);\n        delete _featureLayers[layerId];\n      }\n    });\n  }\n\n  /**\n   * Determines within box query bounds to be passed into row query\n   * This accepts a container point so that we can build up a bounds\n   * object based on screen-space positioning (e.g. in pixels).\n   *\n   * @param {Object} leafletContainerPoint - The 'container point' that\n   *   Leaflet provides on click events.\n   *   @propery {Number} x - The x offset of the point (in pixels)\n   *   @propery {Number} y - The y offset of the point (in pixels)\n   *\n   * @return {Object}\n   *   @property {Object} northeast - The northeast point of the bounding\n   *     box.\n   *     @property {Number} lat - The latitude of the point.\n   *     @property {Number} lng - The longitude of the point.\n   *   @property {Object} southwest - The southwest point of the bounding\n   *     box.\n   *     @property {Number} lat - The latitude of the point.\n   *     @property {Number} lng - The longitude of the point.\n   */\n  function _getQueryBounds(leafletContainerPoint) {\n\n    var hoverThreshold = _getHoverThreshold(_map.getZoom());\n    var delta = FEATURE_MAP_ROW_INSPECTOR_QUERY_BOX_PADDING + hoverThreshold;\n    var northeastContainerPoint = L.point(\n      leafletContainerPoint.x - delta,\n      leafletContainerPoint.y + delta\n    );\n    var southwestContainerPoint = L.point(\n      leafletContainerPoint.x + delta,\n      leafletContainerPoint.y - delta\n    );\n\n    return {\n      northeast: _map.containerPointToLatLng(northeastContainerPoint),\n      southwest: _map.containerPointToLatLng(southwestContainerPoint)\n    };\n  }\n\n  /**\n   * Returns a unique string id for a feature that will be used as a key\n   * into a key => value hash. The 'index' parameter is the index of this\n   * feature into the array of all features.\n   *\n   * @param feature - The feature for which we will compute an id.\n   * @param index - The index of the feature into the tile's collection\n   *   of features.\n   *\n   * @return {String}\n   */\n  function _getFeatureId(feature, index) {\n    return String(index);\n  }\n\n  /**\n  * Returns the current hover threshold at the given zoom level, calculated\n  * based on point radius.\n  *\n  * @param zoomLevel - The current zoom level of the map.\n  *\n  * @return {Number}\n  */\n  function _getHoverThreshold(zoomLevel) {\n\n    return Math.max(\n      _scalePointFeatureRadiusByZoomLevel(zoomLevel),\n      FEATURE_MAP_MIN_HOVER_THRESHOLD\n    );\n  }\n\n  /**\n   * Scales points according to zoom level. The maximum zoom level\n   * in Leaflet is 18; the minimum is 1.\n   *\n   * @param zoomLevel - The current zoom level of the map.\n   *\n   * @return {Number}\n   */\n  function _scalePointFeatureRadiusByZoomLevel(zoomLevel) {\n\n    // This was created somewhat arbitrarily by Chris to\n    // result in point features which get slightly larger\n    // as the map is zoomed in. It can be replaced with\n    // any function which computes a number that makes\n    // sense as the radius of a point feature in pixels.\n    return Math.pow(zoomLevel * 0.0695, 5) + 2;\n  }\n\n  /**\n   * Returns an object specifying the styles with which a point feature\n   * will be rendered.\n   *\n   * This function is called by the Vector Tile Layer extension to Leaflet\n   * as it iterates over features in a vector tile.\n   *\n   * @return {Object} - A style object that will be used to render the\n   *   feature.\n   */\n  function _getPointStyle() {\n\n    return {\n      color: _calculatePointColor,\n      highlightColor: 'rgba(255, 255, 255, .5)',\n      radius: _scalePointFeatureRadiusByZoomLevel,\n      lineWidth: 1,\n      strokeStyle: _calculateStrokeStyleColor\n    };\n  }\n\n  /**\n  * Determine point fill color at given zoom level.\n  * Makes points more transparent as map zooms out.\n  */\n  function _calculatePointColor(zoomLevel) {\n    return 'rgba(234,105,0,' + (0.2 * Math.pow(zoomLevel / 18, 5) + 0.6) + ')';\n  }\n\n  /**\n  * Determine stroke style (point outline) at given zoom level.\n  * Dims point outline color as map zooms out.\n  */\n  function _calculateStrokeStyleColor(zoomLevel) {\n    return 'rgba(255,255,255,' + (0.8 * Math.pow(zoomLevel / 18, 8) + 0.1) + ')';\n  }\n\n  /**\n   * Returns an object specifying the styles with which a line string\n   * feature will be rendered.\n   *\n   * This function is called by the Vector Tile Layer extension to Leaflet\n   * as it iterates over features in a vector tile.\n   *\n   * @return {Object} - A style object that will be used to render the\n   *   feature.\n   */\n  function _getLineStringStyle() {\n\n    return {\n      color: 'rgba(161,217,155,0.8)',\n      size: 3\n    };\n  }\n\n  /**\n   * Returns an object specifying the styles with which a polygon feature\n   * will be rendered.\n   *\n   * This function is called by the Vector Tile Layer extension to Leaflet\n   * as it iterates over features in a vector tile.\n   *\n   * @return {Object} - A style object that will be used to render the\n   *   feature.\n   */\n  function _getPolygonStyle() {\n\n    return {\n      color: 'rgba(149,139,255,0.4)',\n      outline: {\n        color: 'rgb(20,20,20)',\n        size: 2\n      }\n    };\n  }\n\n  /**\n   * Provides a generic interface to the styling functions above and\n   * dispatches requests to the appropriate type based on the feature\n   * being styled.\n   *\n   * @param feature - The feature that we will style.\n   *\n   * @return {Object} - A function that can be used to generate a style\n   *   object.\n   */\n  function _getFeatureStyle(feature) {\n\n    switch (feature.type) {\n      case 1:\n        return _getPointStyle();\n      case 2:\n        return _getLineStringStyle();\n      case 3:\n        return _getPolygonStyle();\n      default:\n        throw new Error('Cannot apply style to unknown feature type \"' + feature.type + '\".');\n    }\n  }\n}\n\nmodule.exports = FeatureMap;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/views/FeatureMap.js\n ** module id = 18\n ** module chunks = 0\n **/","'use strict';\n\n/*\n Leaflet, a JavaScript library for mobile-friendly interactive maps. http://leafletjs.com\n (c) 2010-2013, Vladimir Agafonkin\n (c) 2010-2011, CloudMade\n*/\n(function (window, document, undefined) {\r\nvar oldL = window.L,\r\n    L = {};\r\n\r\nL.version = '0.7.7';\r\n\r\n// define Leaflet for Node module pattern loaders, including Browserify\r\nif (typeof module === 'object' && typeof module.exports === 'object') {\r\n\tmodule.exports = L;\r\n\r\n// define Leaflet as an AMD module\r\n} else if (typeof define === 'function' && define.amd) {\r\n\tdefine(L);\r\n}\r\n\r\n// define Leaflet as a global L variable, saving the original L to restore later if needed\r\n\r\nL.noConflict = function () {\r\n\twindow.L = oldL;\r\n\treturn this;\r\n};\r\n\r\nwindow.L = L;\r\n\n\n/*\r\n * L.Util contains various utility functions used throughout Leaflet code.\r\n */\r\n\r\nL.Util = {\r\n\textend: function (dest) { // (Object[, Object, ...]) ->\r\n\t\tvar sources = Array.prototype.slice.call(arguments, 1),\r\n\t\t    i, j, len, src;\r\n\r\n\t\tfor (j = 0, len = sources.length; j < len; j++) {\r\n\t\t\tsrc = sources[j] || {};\r\n\t\t\tfor (i in src) {\r\n\t\t\t\tif (src.hasOwnProperty(i)) {\r\n\t\t\t\t\tdest[i] = src[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn dest;\r\n\t},\r\n\r\n\tbind: function (fn, obj) { // (Function, Object) -> Function\r\n\t\tvar args = arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : null;\r\n\t\treturn function () {\r\n\t\t\treturn fn.apply(obj, args || arguments);\r\n\t\t};\r\n\t},\r\n\r\n\tstamp: (function () {\r\n\t\tvar lastId = 0,\r\n\t\t    key = '_leaflet_id';\r\n\t\treturn function (obj) {\r\n\t\t\tobj[key] = obj[key] || ++lastId;\r\n\t\t\treturn obj[key];\r\n\t\t};\r\n\t}()),\r\n\r\n\tinvokeEach: function (obj, method, context) {\r\n\t\tvar i, args;\r\n\r\n\t\tif (typeof obj === 'object') {\r\n\t\t\targs = Array.prototype.slice.call(arguments, 3);\r\n\r\n\t\t\tfor (i in obj) {\r\n\t\t\t\tmethod.apply(context, [i, obj[i]].concat(args));\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t},\r\n\r\n\tlimitExecByInterval: function (fn, time, context) {\r\n\t\tvar lock, execOnUnlock;\r\n\r\n\t\treturn function wrapperFn() {\r\n\t\t\tvar args = arguments;\r\n\r\n\t\t\tif (lock) {\r\n\t\t\t\texecOnUnlock = true;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tlock = true;\r\n\r\n\t\t\tsetTimeout(function () {\r\n\t\t\t\tlock = false;\r\n\r\n\t\t\t\tif (execOnUnlock) {\r\n\t\t\t\t\twrapperFn.apply(context, args);\r\n\t\t\t\t\texecOnUnlock = false;\r\n\t\t\t\t}\r\n\t\t\t}, time);\r\n\r\n\t\t\tfn.apply(context, args);\r\n\t\t};\r\n\t},\r\n\r\n\tfalseFn: function () {\r\n\t\treturn false;\r\n\t},\r\n\r\n\tformatNum: function (num, digits) {\r\n\t\tvar pow = Math.pow(10, digits || 5);\r\n\t\treturn Math.round(num * pow) / pow;\r\n\t},\r\n\r\n\ttrim: function (str) {\r\n\t\treturn str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\r\n\t},\r\n\r\n\tsplitWords: function (str) {\r\n\t\treturn L.Util.trim(str).split(/\\s+/);\r\n\t},\r\n\r\n\tsetOptions: function (obj, options) {\r\n\t\tobj.options = L.extend({}, obj.options, options);\r\n\t\treturn obj.options;\r\n\t},\r\n\r\n\tgetParamString: function (obj, existingUrl, uppercase) {\r\n\t\tvar params = [];\r\n\t\tfor (var i in obj) {\r\n\t\t\tparams.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));\r\n\t\t}\r\n\t\treturn ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');\r\n\t},\r\n\ttemplate: function (str, data) {\r\n\t\treturn str.replace(/\\{ *([\\w_]+) *\\}/g, function (str, key) {\r\n\t\t\tvar value = data[key];\r\n\t\t\tif (value === undefined) {\r\n\t\t\t\tthrow new Error('No value provided for variable ' + str);\r\n\t\t\t} else if (typeof value === 'function') {\r\n\t\t\t\tvalue = value(data);\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t});\r\n\t},\r\n\r\n\tisArray: Array.isArray || function (obj) {\r\n\t\treturn (Object.prototype.toString.call(obj) === '[object Array]');\r\n\t},\r\n\r\n\temptyImageUrl: 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='\r\n};\r\n\r\n(function () {\r\n\r\n\t// inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/\r\n\r\n\tfunction getPrefixed(name) {\r\n\t\tvar i, fn,\r\n\t\t    prefixes = ['webkit', 'moz', 'o', 'ms'];\r\n\r\n\t\tfor (i = 0; i < prefixes.length && !fn; i++) {\r\n\t\t\tfn = window[prefixes[i] + name];\r\n\t\t}\r\n\r\n\t\treturn fn;\r\n\t}\r\n\r\n\tvar lastTime = 0;\r\n\r\n\tfunction timeoutDefer(fn) {\r\n\t\tvar time = +new Date(),\r\n\t\t    timeToCall = Math.max(0, 16 - (time - lastTime));\r\n\r\n\t\tlastTime = time + timeToCall;\r\n\t\treturn window.setTimeout(fn, timeToCall);\r\n\t}\r\n\r\n\tvar requestFn = window.requestAnimationFrame ||\r\n\t        getPrefixed('RequestAnimationFrame') || timeoutDefer;\r\n\r\n\tvar cancelFn = window.cancelAnimationFrame ||\r\n\t        getPrefixed('CancelAnimationFrame') ||\r\n\t        getPrefixed('CancelRequestAnimationFrame') ||\r\n\t        function (id) { window.clearTimeout(id); };\r\n\r\n\r\n\tL.Util.requestAnimFrame = function (fn, context, immediate, element) {\r\n\t\tfn = L.bind(fn, context);\r\n\r\n\t\tif (immediate && requestFn === timeoutDefer) {\r\n\t\t\tfn();\r\n\t\t} else {\r\n\t\t\treturn requestFn.call(window, fn, element);\r\n\t\t}\r\n\t};\r\n\r\n\tL.Util.cancelAnimFrame = function (id) {\r\n\t\tif (id) {\r\n\t\t\tcancelFn.call(window, id);\r\n\t\t}\r\n\t};\r\n\r\n}());\r\n\r\n// shortcuts for most used utility functions\r\nL.extend = L.Util.extend;\r\nL.bind = L.Util.bind;\r\nL.stamp = L.Util.stamp;\r\nL.setOptions = L.Util.setOptions;\r\n\n\n/*\r\n * L.Class powers the OOP facilities of the library.\r\n * Thanks to John Resig and Dean Edwards for inspiration!\r\n */\r\n\r\nL.Class = function () {};\r\n\r\nL.Class.extend = function (props) {\r\n\r\n\t// extended class with the new prototype\r\n\tvar NewClass = function () {\r\n\r\n\t\t// call the constructor\r\n\t\tif (this.initialize) {\r\n\t\t\tthis.initialize.apply(this, arguments);\r\n\t\t}\r\n\r\n\t\t// call all constructor hooks\r\n\t\tif (this._initHooks) {\r\n\t\t\tthis.callInitHooks();\r\n\t\t}\r\n\t};\r\n\r\n\t// instantiate class without calling constructor\r\n\tvar F = function () {};\r\n\tF.prototype = this.prototype;\r\n\r\n\tvar proto = new F();\r\n\tproto.constructor = NewClass;\r\n\r\n\tNewClass.prototype = proto;\r\n\r\n\t//inherit parent's statics\r\n\tfor (var i in this) {\r\n\t\tif (this.hasOwnProperty(i) && i !== 'prototype') {\r\n\t\t\tNewClass[i] = this[i];\r\n\t\t}\r\n\t}\r\n\r\n\t// mix static properties into the class\r\n\tif (props.statics) {\r\n\t\tL.extend(NewClass, props.statics);\r\n\t\tdelete props.statics;\r\n\t}\r\n\r\n\t// mix includes into the prototype\r\n\tif (props.includes) {\r\n\t\tL.Util.extend.apply(null, [proto].concat(props.includes));\r\n\t\tdelete props.includes;\r\n\t}\r\n\r\n\t// merge options\r\n\tif (props.options && proto.options) {\r\n\t\tprops.options = L.extend({}, proto.options, props.options);\r\n\t}\r\n\r\n\t// mix given properties into the prototype\r\n\tL.extend(proto, props);\r\n\r\n\tproto._initHooks = [];\r\n\r\n\tvar parent = this;\r\n\t// jshint camelcase: false\r\n\tNewClass.__super__ = parent.prototype;\r\n\r\n\t// add method for calling all hooks\r\n\tproto.callInitHooks = function () {\r\n\r\n\t\tif (this._initHooksCalled) { return; }\r\n\r\n\t\tif (parent.prototype.callInitHooks) {\r\n\t\t\tparent.prototype.callInitHooks.call(this);\r\n\t\t}\r\n\r\n\t\tthis._initHooksCalled = true;\r\n\r\n\t\tfor (var i = 0, len = proto._initHooks.length; i < len; i++) {\r\n\t\t\tproto._initHooks[i].call(this);\r\n\t\t}\r\n\t};\r\n\r\n\treturn NewClass;\r\n};\r\n\r\n\r\n// method for adding properties to prototype\r\nL.Class.include = function (props) {\r\n\tL.extend(this.prototype, props);\r\n};\r\n\r\n// merge new default options to the Class\r\nL.Class.mergeOptions = function (options) {\r\n\tL.extend(this.prototype.options, options);\r\n};\r\n\r\n// add a constructor hook\r\nL.Class.addInitHook = function (fn) { // (Function) || (String, args...)\r\n\tvar args = Array.prototype.slice.call(arguments, 1);\r\n\r\n\tvar init = typeof fn === 'function' ? fn : function () {\r\n\t\tthis[fn].apply(this, args);\r\n\t};\r\n\r\n\tthis.prototype._initHooks = this.prototype._initHooks || [];\r\n\tthis.prototype._initHooks.push(init);\r\n};\r\n\n\n/*\r\n * L.Mixin.Events is used to add custom events functionality to Leaflet classes.\r\n */\r\n\r\nvar eventsKey = '_leaflet_events';\r\n\r\nL.Mixin = {};\r\n\r\nL.Mixin.Events = {\r\n\r\n\taddEventListener: function (types, fn, context) { // (String, Function[, Object]) or (Object[, Object])\r\n\r\n\t\t// types can be a map of types/handlers\r\n\t\tif (L.Util.invokeEach(types, this.addEventListener, this, fn, context)) { return this; }\r\n\r\n\t\tvar events = this[eventsKey] = this[eventsKey] || {},\r\n\t\t    contextId = context && context !== this && L.stamp(context),\r\n\t\t    i, len, event, type, indexKey, indexLenKey, typeIndex;\r\n\r\n\t\t// types can be a string of space-separated words\r\n\t\ttypes = L.Util.splitWords(types);\r\n\r\n\t\tfor (i = 0, len = types.length; i < len; i++) {\r\n\t\t\tevent = {\r\n\t\t\t\taction: fn,\r\n\t\t\t\tcontext: context || this\r\n\t\t\t};\r\n\t\t\ttype = types[i];\r\n\r\n\t\t\tif (contextId) {\r\n\t\t\t\t// store listeners of a particular context in a separate hash (if it has an id)\r\n\t\t\t\t// gives a major performance boost when removing thousands of map layers\r\n\r\n\t\t\t\tindexKey = type + '_idx';\r\n\t\t\t\tindexLenKey = indexKey + '_len';\r\n\r\n\t\t\t\ttypeIndex = events[indexKey] = events[indexKey] || {};\r\n\r\n\t\t\t\tif (!typeIndex[contextId]) {\r\n\t\t\t\t\ttypeIndex[contextId] = [];\r\n\r\n\t\t\t\t\t// keep track of the number of keys in the index to quickly check if it's empty\r\n\t\t\t\t\tevents[indexLenKey] = (events[indexLenKey] || 0) + 1;\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttypeIndex[contextId].push(event);\r\n\r\n\r\n\t\t\t} else {\r\n\t\t\t\tevents[type] = events[type] || [];\r\n\t\t\t\tevents[type].push(event);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\thasEventListeners: function (type) { // (String) -> Boolean\r\n\t\tvar events = this[eventsKey];\r\n\t\treturn !!events && ((type in events && events[type].length > 0) ||\r\n\t\t                    (type + '_idx' in events && events[type + '_idx_len'] > 0));\r\n\t},\r\n\r\n\tremoveEventListener: function (types, fn, context) { // ([String, Function, Object]) or (Object[, Object])\r\n\r\n\t\tif (!this[eventsKey]) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tif (!types) {\r\n\t\t\treturn this.clearAllEventListeners();\r\n\t\t}\r\n\r\n\t\tif (L.Util.invokeEach(types, this.removeEventListener, this, fn, context)) { return this; }\r\n\r\n\t\tvar events = this[eventsKey],\r\n\t\t    contextId = context && context !== this && L.stamp(context),\r\n\t\t    i, len, type, listeners, j, indexKey, indexLenKey, typeIndex, removed;\r\n\r\n\t\ttypes = L.Util.splitWords(types);\r\n\r\n\t\tfor (i = 0, len = types.length; i < len; i++) {\r\n\t\t\ttype = types[i];\r\n\t\t\tindexKey = type + '_idx';\r\n\t\t\tindexLenKey = indexKey + '_len';\r\n\r\n\t\t\ttypeIndex = events[indexKey];\r\n\r\n\t\t\tif (!fn) {\r\n\t\t\t\t// clear all listeners for a type if function isn't specified\r\n\t\t\t\tdelete events[type];\r\n\t\t\t\tdelete events[indexKey];\r\n\t\t\t\tdelete events[indexLenKey];\r\n\r\n\t\t\t} else {\r\n\t\t\t\tlisteners = contextId && typeIndex ? typeIndex[contextId] : events[type];\r\n\r\n\t\t\t\tif (listeners) {\r\n\t\t\t\t\tfor (j = listeners.length - 1; j >= 0; j--) {\r\n\t\t\t\t\t\tif ((listeners[j].action === fn) && (!context || (listeners[j].context === context))) {\r\n\t\t\t\t\t\t\tremoved = listeners.splice(j, 1);\r\n\t\t\t\t\t\t\t// set the old action to a no-op, because it is possible\r\n\t\t\t\t\t\t\t// that the listener is being iterated over as part of a dispatch\r\n\t\t\t\t\t\t\tremoved[0].action = L.Util.falseFn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (context && typeIndex && (listeners.length === 0)) {\r\n\t\t\t\t\t\tdelete typeIndex[contextId];\r\n\t\t\t\t\t\tevents[indexLenKey]--;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tclearAllEventListeners: function () {\r\n\t\tdelete this[eventsKey];\r\n\t\treturn this;\r\n\t},\r\n\r\n\tfireEvent: function (type, data) { // (String[, Object])\r\n\t\tif (!this.hasEventListeners(type)) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tvar event = L.Util.extend({}, data, { type: type, target: this });\r\n\r\n\t\tvar events = this[eventsKey],\r\n\t\t    listeners, i, len, typeIndex, contextId;\r\n\r\n\t\tif (events[type]) {\r\n\t\t\t// make sure adding/removing listeners inside other listeners won't cause infinite loop\r\n\t\t\tlisteners = events[type].slice();\r\n\r\n\t\t\tfor (i = 0, len = listeners.length; i < len; i++) {\r\n\t\t\t\tlisteners[i].action.call(listeners[i].context, event);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// fire event for the context-indexed listeners as well\r\n\t\ttypeIndex = events[type + '_idx'];\r\n\r\n\t\tfor (contextId in typeIndex) {\r\n\t\t\tlisteners = typeIndex[contextId].slice();\r\n\r\n\t\t\tif (listeners) {\r\n\t\t\t\tfor (i = 0, len = listeners.length; i < len; i++) {\r\n\t\t\t\t\tlisteners[i].action.call(listeners[i].context, event);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\taddOneTimeEventListener: function (types, fn, context) {\r\n\r\n\t\tif (L.Util.invokeEach(types, this.addOneTimeEventListener, this, fn, context)) { return this; }\r\n\r\n\t\tvar handler = L.bind(function () {\r\n\t\t\tthis\r\n\t\t\t    .removeEventListener(types, fn, context)\r\n\t\t\t    .removeEventListener(types, handler, context);\r\n\t\t}, this);\r\n\r\n\t\treturn this\r\n\t\t    .addEventListener(types, fn, context)\r\n\t\t    .addEventListener(types, handler, context);\r\n\t}\r\n};\r\n\r\nL.Mixin.Events.on = L.Mixin.Events.addEventListener;\r\nL.Mixin.Events.off = L.Mixin.Events.removeEventListener;\r\nL.Mixin.Events.once = L.Mixin.Events.addOneTimeEventListener;\r\nL.Mixin.Events.fire = L.Mixin.Events.fireEvent;\r\n\n\n/*\r\n * L.Browser handles different browser and feature detections for internal Leaflet use.\r\n */\r\n\r\n(function () {\r\n\r\n\tvar ie = 'ActiveXObject' in window,\r\n\t\tielt9 = ie && !document.addEventListener,\r\n\r\n\t    // terrible browser detection to work around Safari / iOS / Android browser bugs\r\n\t    ua = navigator.userAgent.toLowerCase(),\r\n\t    webkit = ua.indexOf('webkit') !== -1,\r\n\t    chrome = ua.indexOf('chrome') !== -1,\r\n\t    phantomjs = ua.indexOf('phantom') !== -1,\r\n\t    android = ua.indexOf('android') !== -1,\r\n\t    android23 = ua.search('android [23]') !== -1,\r\n\t\tgecko = ua.indexOf('gecko') !== -1,\r\n\r\n\t    mobile = typeof orientation !== undefined + '',\r\n\t    msPointer = !window.PointerEvent && window.MSPointerEvent,\r\n\t\tpointer = (window.PointerEvent && window.navigator.pointerEnabled) ||\r\n\t\t\t\t  msPointer,\r\n\t    retina = ('devicePixelRatio' in window && window.devicePixelRatio > 1) ||\r\n\t             ('matchMedia' in window && window.matchMedia('(min-resolution:144dpi)') &&\r\n\t              window.matchMedia('(min-resolution:144dpi)').matches),\r\n\r\n\t    doc = document.documentElement,\r\n\t    ie3d = ie && ('transition' in doc.style),\r\n\t    webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23,\r\n\t    gecko3d = 'MozPerspective' in doc.style,\r\n\t    opera3d = 'OTransition' in doc.style,\r\n\t    any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d || opera3d) && !phantomjs;\r\n\r\n\tvar touch = !window.L_NO_TOUCH && !phantomjs && (pointer || 'ontouchstart' in window ||\r\n\t\t(window.DocumentTouch && document instanceof window.DocumentTouch));\r\n\r\n\tL.Browser = {\r\n\t\tie: ie,\r\n\t\tielt9: ielt9,\r\n\t\twebkit: webkit,\r\n\t\tgecko: gecko && !webkit && !window.opera && !ie,\r\n\r\n\t\tandroid: android,\r\n\t\tandroid23: android23,\r\n\r\n\t\tchrome: chrome,\r\n\r\n\t\tie3d: ie3d,\r\n\t\twebkit3d: webkit3d,\r\n\t\tgecko3d: gecko3d,\r\n\t\topera3d: opera3d,\r\n\t\tany3d: any3d,\r\n\r\n\t\tmobile: mobile,\r\n\t\tmobileWebkit: mobile && webkit,\r\n\t\tmobileWebkit3d: mobile && webkit3d,\r\n\t\tmobileOpera: mobile && window.opera,\r\n\r\n\t\ttouch: touch,\r\n\t\tmsPointer: msPointer,\r\n\t\tpointer: pointer,\r\n\r\n\t\tretina: retina\r\n\t};\r\n\r\n}());\r\n\n\n/*\r\n * L.Point represents a point with x and y coordinates.\r\n */\r\n\r\nL.Point = function (/*Number*/ x, /*Number*/ y, /*Boolean*/ round) {\r\n\tthis.x = (round ? Math.round(x) : x);\r\n\tthis.y = (round ? Math.round(y) : y);\r\n};\r\n\r\nL.Point.prototype = {\r\n\r\n\tclone: function () {\r\n\t\treturn new L.Point(this.x, this.y);\r\n\t},\r\n\r\n\t// non-destructive, returns a new point\r\n\tadd: function (point) {\r\n\t\treturn this.clone()._add(L.point(point));\r\n\t},\r\n\r\n\t// destructive, used directly for performance in situations where it's safe to modify existing point\r\n\t_add: function (point) {\r\n\t\tthis.x += point.x;\r\n\t\tthis.y += point.y;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsubtract: function (point) {\r\n\t\treturn this.clone()._subtract(L.point(point));\r\n\t},\r\n\r\n\t_subtract: function (point) {\r\n\t\tthis.x -= point.x;\r\n\t\tthis.y -= point.y;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tdivideBy: function (num) {\r\n\t\treturn this.clone()._divideBy(num);\r\n\t},\r\n\r\n\t_divideBy: function (num) {\r\n\t\tthis.x /= num;\r\n\t\tthis.y /= num;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tmultiplyBy: function (num) {\r\n\t\treturn this.clone()._multiplyBy(num);\r\n\t},\r\n\r\n\t_multiplyBy: function (num) {\r\n\t\tthis.x *= num;\r\n\t\tthis.y *= num;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tround: function () {\r\n\t\treturn this.clone()._round();\r\n\t},\r\n\r\n\t_round: function () {\r\n\t\tthis.x = Math.round(this.x);\r\n\t\tthis.y = Math.round(this.y);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tfloor: function () {\r\n\t\treturn this.clone()._floor();\r\n\t},\r\n\r\n\t_floor: function () {\r\n\t\tthis.x = Math.floor(this.x);\r\n\t\tthis.y = Math.floor(this.y);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tdistanceTo: function (point) {\r\n\t\tpoint = L.point(point);\r\n\r\n\t\tvar x = point.x - this.x,\r\n\t\t    y = point.y - this.y;\r\n\r\n\t\treturn Math.sqrt(x * x + y * y);\r\n\t},\r\n\r\n\tequals: function (point) {\r\n\t\tpoint = L.point(point);\r\n\r\n\t\treturn point.x === this.x &&\r\n\t\t       point.y === this.y;\r\n\t},\r\n\r\n\tcontains: function (point) {\r\n\t\tpoint = L.point(point);\r\n\r\n\t\treturn Math.abs(point.x) <= Math.abs(this.x) &&\r\n\t\t       Math.abs(point.y) <= Math.abs(this.y);\r\n\t},\r\n\r\n\ttoString: function () {\r\n\t\treturn 'Point(' +\r\n\t\t        L.Util.formatNum(this.x) + ', ' +\r\n\t\t        L.Util.formatNum(this.y) + ')';\r\n\t}\r\n};\r\n\r\nL.point = function (x, y, round) {\r\n\tif (x instanceof L.Point) {\r\n\t\treturn x;\r\n\t}\r\n\tif (L.Util.isArray(x)) {\r\n\t\treturn new L.Point(x[0], x[1]);\r\n\t}\r\n\tif (x === undefined || x === null) {\r\n\t\treturn x;\r\n\t}\r\n\treturn new L.Point(x, y, round);\r\n};\r\n\n\n/*\r\n * L.Bounds represents a rectangular area on the screen in pixel coordinates.\r\n */\r\n\r\nL.Bounds = function (a, b) { //(Point, Point) or Point[]\r\n\tif (!a) { return; }\r\n\r\n\tvar points = b ? [a, b] : a;\r\n\r\n\tfor (var i = 0, len = points.length; i < len; i++) {\r\n\t\tthis.extend(points[i]);\r\n\t}\r\n};\r\n\r\nL.Bounds.prototype = {\r\n\t// extend the bounds to contain the given point\r\n\textend: function (point) { // (Point)\r\n\t\tpoint = L.point(point);\r\n\r\n\t\tif (!this.min && !this.max) {\r\n\t\t\tthis.min = point.clone();\r\n\t\t\tthis.max = point.clone();\r\n\t\t} else {\r\n\t\t\tthis.min.x = Math.min(point.x, this.min.x);\r\n\t\t\tthis.max.x = Math.max(point.x, this.max.x);\r\n\t\t\tthis.min.y = Math.min(point.y, this.min.y);\r\n\t\t\tthis.max.y = Math.max(point.y, this.max.y);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetCenter: function (round) { // (Boolean) -> Point\r\n\t\treturn new L.Point(\r\n\t\t        (this.min.x + this.max.x) / 2,\r\n\t\t        (this.min.y + this.max.y) / 2, round);\r\n\t},\r\n\r\n\tgetBottomLeft: function () { // -> Point\r\n\t\treturn new L.Point(this.min.x, this.max.y);\r\n\t},\r\n\r\n\tgetTopRight: function () { // -> Point\r\n\t\treturn new L.Point(this.max.x, this.min.y);\r\n\t},\r\n\r\n\tgetSize: function () {\r\n\t\treturn this.max.subtract(this.min);\r\n\t},\r\n\r\n\tcontains: function (obj) { // (Bounds) or (Point) -> Boolean\r\n\t\tvar min, max;\r\n\r\n\t\tif (typeof obj[0] === 'number' || obj instanceof L.Point) {\r\n\t\t\tobj = L.point(obj);\r\n\t\t} else {\r\n\t\t\tobj = L.bounds(obj);\r\n\t\t}\r\n\r\n\t\tif (obj instanceof L.Bounds) {\r\n\t\t\tmin = obj.min;\r\n\t\t\tmax = obj.max;\r\n\t\t} else {\r\n\t\t\tmin = max = obj;\r\n\t\t}\r\n\r\n\t\treturn (min.x >= this.min.x) &&\r\n\t\t       (max.x <= this.max.x) &&\r\n\t\t       (min.y >= this.min.y) &&\r\n\t\t       (max.y <= this.max.y);\r\n\t},\r\n\r\n\tintersects: function (bounds) { // (Bounds) -> Boolean\r\n\t\tbounds = L.bounds(bounds);\r\n\r\n\t\tvar min = this.min,\r\n\t\t    max = this.max,\r\n\t\t    min2 = bounds.min,\r\n\t\t    max2 = bounds.max,\r\n\t\t    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),\r\n\t\t    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);\r\n\r\n\t\treturn xIntersects && yIntersects;\r\n\t},\r\n\r\n\tisValid: function () {\r\n\t\treturn !!(this.min && this.max);\r\n\t}\r\n};\r\n\r\nL.bounds = function (a, b) { // (Bounds) or (Point, Point) or (Point[])\r\n\tif (!a || a instanceof L.Bounds) {\r\n\t\treturn a;\r\n\t}\r\n\treturn new L.Bounds(a, b);\r\n};\r\n\n\n/*\r\n * L.Transformation is an utility class to perform simple point transformations through a 2d-matrix.\r\n */\r\n\r\nL.Transformation = function (a, b, c, d) {\r\n\tthis._a = a;\r\n\tthis._b = b;\r\n\tthis._c = c;\r\n\tthis._d = d;\r\n};\r\n\r\nL.Transformation.prototype = {\r\n\ttransform: function (point, scale) { // (Point, Number) -> Point\r\n\t\treturn this._transform(point.clone(), scale);\r\n\t},\r\n\r\n\t// destructive transform (faster)\r\n\t_transform: function (point, scale) {\r\n\t\tscale = scale || 1;\r\n\t\tpoint.x = scale * (this._a * point.x + this._b);\r\n\t\tpoint.y = scale * (this._c * point.y + this._d);\r\n\t\treturn point;\r\n\t},\r\n\r\n\tuntransform: function (point, scale) {\r\n\t\tscale = scale || 1;\r\n\t\treturn new L.Point(\r\n\t\t        (point.x / scale - this._b) / this._a,\r\n\t\t        (point.y / scale - this._d) / this._c);\r\n\t}\r\n};\r\n\n\n/*\r\n * L.DomUtil contains various utility functions for working with DOM.\r\n */\r\n\r\nL.DomUtil = {\r\n\tget: function (id) {\r\n\t\treturn (typeof id === 'string' ? document.getElementById(id) : id);\r\n\t},\r\n\r\n\tgetStyle: function (el, style) {\r\n\r\n\t\tvar value = el.style[style];\r\n\r\n\t\tif (!value && el.currentStyle) {\r\n\t\t\tvalue = el.currentStyle[style];\r\n\t\t}\r\n\r\n\t\tif ((!value || value === 'auto') && document.defaultView) {\r\n\t\t\tvar css = document.defaultView.getComputedStyle(el, null);\r\n\t\t\tvalue = css ? css[style] : null;\r\n\t\t}\r\n\r\n\t\treturn value === 'auto' ? null : value;\r\n\t},\r\n\r\n\tgetViewportOffset: function (element) {\r\n\r\n\t\tvar top = 0,\r\n\t\t    left = 0,\r\n\t\t    el = element,\r\n\t\t    docBody = document.body,\r\n\t\t    docEl = document.documentElement,\r\n\t\t    pos;\r\n\r\n\t\tdo {\r\n\t\t\ttop  += el.offsetTop  || 0;\r\n\t\t\tleft += el.offsetLeft || 0;\r\n\r\n\t\t\t//add borders\r\n\t\t\ttop += parseInt(L.DomUtil.getStyle(el, 'borderTopWidth'), 10) || 0;\r\n\t\t\tleft += parseInt(L.DomUtil.getStyle(el, 'borderLeftWidth'), 10) || 0;\r\n\r\n\t\t\tpos = L.DomUtil.getStyle(el, 'position');\r\n\r\n\t\t\tif (el.offsetParent === docBody && pos === 'absolute') { break; }\r\n\r\n\t\t\tif (pos === 'fixed') {\r\n\t\t\t\ttop  += docBody.scrollTop  || docEl.scrollTop  || 0;\r\n\t\t\t\tleft += docBody.scrollLeft || docEl.scrollLeft || 0;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tif (pos === 'relative' && !el.offsetLeft) {\r\n\t\t\t\tvar width = L.DomUtil.getStyle(el, 'width'),\r\n\t\t\t\t    maxWidth = L.DomUtil.getStyle(el, 'max-width'),\r\n\t\t\t\t    r = el.getBoundingClientRect();\r\n\r\n\t\t\t\tif (width !== 'none' || maxWidth !== 'none') {\r\n\t\t\t\t\tleft += r.left + el.clientLeft;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//calculate full y offset since we're breaking out of the loop\r\n\t\t\t\ttop += r.top + (docBody.scrollTop  || docEl.scrollTop  || 0);\r\n\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tel = el.offsetParent;\r\n\r\n\t\t} while (el);\r\n\r\n\t\tel = element;\r\n\r\n\t\tdo {\r\n\t\t\tif (el === docBody) { break; }\r\n\r\n\t\t\ttop  -= el.scrollTop  || 0;\r\n\t\t\tleft -= el.scrollLeft || 0;\r\n\r\n\t\t\tel = el.parentNode;\r\n\t\t} while (el);\r\n\r\n\t\treturn new L.Point(left, top);\r\n\t},\r\n\r\n\tdocumentIsLtr: function () {\r\n\t\tif (!L.DomUtil._docIsLtrCached) {\r\n\t\t\tL.DomUtil._docIsLtrCached = true;\r\n\t\t\tL.DomUtil._docIsLtr = L.DomUtil.getStyle(document.body, 'direction') === 'ltr';\r\n\t\t}\r\n\t\treturn L.DomUtil._docIsLtr;\r\n\t},\r\n\r\n\tcreate: function (tagName, className, container) {\r\n\r\n\t\tvar el = document.createElement(tagName);\r\n\t\tel.className = className;\r\n\r\n\t\tif (container) {\r\n\t\t\tcontainer.appendChild(el);\r\n\t\t}\r\n\r\n\t\treturn el;\r\n\t},\r\n\r\n\thasClass: function (el, name) {\r\n\t\tif (el.classList !== undefined) {\r\n\t\t\treturn el.classList.contains(name);\r\n\t\t}\r\n\t\tvar className = L.DomUtil._getClass(el);\r\n\t\treturn className.length > 0 && new RegExp('(^|\\\\s)' + name + '(\\\\s|$)').test(className);\r\n\t},\r\n\r\n\taddClass: function (el, name) {\r\n\t\tif (el.classList !== undefined) {\r\n\t\t\tvar classes = L.Util.splitWords(name);\r\n\t\t\tfor (var i = 0, len = classes.length; i < len; i++) {\r\n\t\t\t\tel.classList.add(classes[i]);\r\n\t\t\t}\r\n\t\t} else if (!L.DomUtil.hasClass(el, name)) {\r\n\t\t\tvar className = L.DomUtil._getClass(el);\r\n\t\t\tL.DomUtil._setClass(el, (className ? className + ' ' : '') + name);\r\n\t\t}\r\n\t},\r\n\r\n\tremoveClass: function (el, name) {\r\n\t\tif (el.classList !== undefined) {\r\n\t\t\tel.classList.remove(name);\r\n\t\t} else {\r\n\t\t\tL.DomUtil._setClass(el, L.Util.trim((' ' + L.DomUtil._getClass(el) + ' ').replace(' ' + name + ' ', ' ')));\r\n\t\t}\r\n\t},\r\n\r\n\t_setClass: function (el, name) {\r\n\t\tif (el.className.baseVal === undefined) {\r\n\t\t\tel.className = name;\r\n\t\t} else {\r\n\t\t\t// in case of SVG element\r\n\t\t\tel.className.baseVal = name;\r\n\t\t}\r\n\t},\r\n\r\n\t_getClass: function (el) {\r\n\t\treturn el.className.baseVal === undefined ? el.className : el.className.baseVal;\r\n\t},\r\n\r\n\tsetOpacity: function (el, value) {\r\n\r\n\t\tif ('opacity' in el.style) {\r\n\t\t\tel.style.opacity = value;\r\n\r\n\t\t} else if ('filter' in el.style) {\r\n\r\n\t\t\tvar filter = false,\r\n\t\t\t    filterName = 'DXImageTransform.Microsoft.Alpha';\r\n\r\n\t\t\t// filters collection throws an error if we try to retrieve a filter that doesn't exist\r\n\t\t\ttry {\r\n\t\t\t\tfilter = el.filters.item(filterName);\r\n\t\t\t} catch (e) {\r\n\t\t\t\t// don't set opacity to 1 if we haven't already set an opacity,\r\n\t\t\t\t// it isn't needed and breaks transparent pngs.\r\n\t\t\t\tif (value === 1) { return; }\r\n\t\t\t}\r\n\r\n\t\t\tvalue = Math.round(value * 100);\r\n\r\n\t\t\tif (filter) {\r\n\t\t\t\tfilter.Enabled = (value !== 100);\r\n\t\t\t\tfilter.Opacity = value;\r\n\t\t\t} else {\r\n\t\t\t\tel.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\ttestProp: function (props) {\r\n\r\n\t\tvar style = document.documentElement.style;\r\n\r\n\t\tfor (var i = 0; i < props.length; i++) {\r\n\t\t\tif (props[i] in style) {\r\n\t\t\t\treturn props[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t},\r\n\r\n\tgetTranslateString: function (point) {\r\n\t\t// on WebKit browsers (Chrome/Safari/iOS Safari/Android) using translate3d instead of translate\r\n\t\t// makes animation smoother as it ensures HW accel is used. Firefox 13 doesn't care\r\n\t\t// (same speed either way), Opera 12 doesn't support translate3d\r\n\r\n\t\tvar is3d = L.Browser.webkit3d,\r\n\t\t    open = 'translate' + (is3d ? '3d' : '') + '(',\r\n\t\t    close = (is3d ? ',0' : '') + ')';\r\n\r\n\t\treturn open + point.x + 'px,' + point.y + 'px' + close;\r\n\t},\r\n\r\n\tgetScaleString: function (scale, origin) {\r\n\r\n\t\tvar preTranslateStr = L.DomUtil.getTranslateString(origin.add(origin.multiplyBy(-1 * scale))),\r\n\t\t    scaleStr = ' scale(' + scale + ') ';\r\n\r\n\t\treturn preTranslateStr + scaleStr;\r\n\t},\r\n\r\n\tsetPosition: function (el, point, disable3D) { // (HTMLElement, Point[, Boolean])\r\n\r\n\t\t// jshint camelcase: false\r\n\t\tel._leaflet_pos = point;\r\n\r\n\t\tif (!disable3D && L.Browser.any3d) {\r\n\t\t\tel.style[L.DomUtil.TRANSFORM] =  L.DomUtil.getTranslateString(point);\r\n\t\t} else {\r\n\t\t\tel.style.left = point.x + 'px';\r\n\t\t\tel.style.top = point.y + 'px';\r\n\t\t}\r\n\t},\r\n\r\n\tgetPosition: function (el) {\r\n\t\t// this method is only used for elements previously positioned using setPosition,\r\n\t\t// so it's safe to cache the position for performance\r\n\r\n\t\t// jshint camelcase: false\r\n\t\treturn el._leaflet_pos;\r\n\t}\r\n};\r\n\r\n\r\n// prefix style property names\r\n\r\nL.DomUtil.TRANSFORM = L.DomUtil.testProp(\r\n        ['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);\r\n\r\n// webkitTransition comes first because some browser versions that drop vendor prefix don't do\r\n// the same for the transitionend event, in particular the Android 4.1 stock browser\r\n\r\nL.DomUtil.TRANSITION = L.DomUtil.testProp(\r\n        ['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);\r\n\r\nL.DomUtil.TRANSITION_END =\r\n        L.DomUtil.TRANSITION === 'webkitTransition' || L.DomUtil.TRANSITION === 'OTransition' ?\r\n        L.DomUtil.TRANSITION + 'End' : 'transitionend';\r\n\r\n(function () {\r\n    if ('onselectstart' in document) {\r\n        L.extend(L.DomUtil, {\r\n            disableTextSelection: function () {\r\n                L.DomEvent.on(window, 'selectstart', L.DomEvent.preventDefault);\r\n            },\r\n\r\n            enableTextSelection: function () {\r\n                L.DomEvent.off(window, 'selectstart', L.DomEvent.preventDefault);\r\n            }\r\n        });\r\n    } else {\r\n        var userSelectProperty = L.DomUtil.testProp(\r\n            ['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);\r\n\r\n        L.extend(L.DomUtil, {\r\n            disableTextSelection: function () {\r\n                if (userSelectProperty) {\r\n                    var style = document.documentElement.style;\r\n                    this._userSelect = style[userSelectProperty];\r\n                    style[userSelectProperty] = 'none';\r\n                }\r\n            },\r\n\r\n            enableTextSelection: function () {\r\n                if (userSelectProperty) {\r\n                    document.documentElement.style[userSelectProperty] = this._userSelect;\r\n                    delete this._userSelect;\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n\tL.extend(L.DomUtil, {\r\n\t\tdisableImageDrag: function () {\r\n\t\t\tL.DomEvent.on(window, 'dragstart', L.DomEvent.preventDefault);\r\n\t\t},\r\n\r\n\t\tenableImageDrag: function () {\r\n\t\t\tL.DomEvent.off(window, 'dragstart', L.DomEvent.preventDefault);\r\n\t\t}\r\n\t});\r\n})();\r\n\n\n/*\r\n * L.LatLng represents a geographical point with latitude and longitude coordinates.\r\n */\r\n\r\nL.LatLng = function (lat, lng, alt) { // (Number, Number, Number)\r\n\tlat = parseFloat(lat);\r\n\tlng = parseFloat(lng);\r\n\r\n\tif (isNaN(lat) || isNaN(lng)) {\r\n\t\tthrow new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');\r\n\t}\r\n\r\n\tthis.lat = lat;\r\n\tthis.lng = lng;\r\n\r\n\tif (alt !== undefined) {\r\n\t\tthis.alt = parseFloat(alt);\r\n\t}\r\n};\r\n\r\nL.extend(L.LatLng, {\r\n\tDEG_TO_RAD: Math.PI / 180,\r\n\tRAD_TO_DEG: 180 / Math.PI,\r\n\tMAX_MARGIN: 1.0E-9 // max margin of error for the \"equals\" check\r\n});\r\n\r\nL.LatLng.prototype = {\r\n\tequals: function (obj) { // (LatLng) -> Boolean\r\n\t\tif (!obj) { return false; }\r\n\r\n\t\tobj = L.latLng(obj);\r\n\r\n\t\tvar margin = Math.max(\r\n\t\t        Math.abs(this.lat - obj.lat),\r\n\t\t        Math.abs(this.lng - obj.lng));\r\n\r\n\t\treturn margin <= L.LatLng.MAX_MARGIN;\r\n\t},\r\n\r\n\ttoString: function (precision) { // (Number) -> String\r\n\t\treturn 'LatLng(' +\r\n\t\t        L.Util.formatNum(this.lat, precision) + ', ' +\r\n\t\t        L.Util.formatNum(this.lng, precision) + ')';\r\n\t},\r\n\r\n\t// Haversine distance formula, see http://en.wikipedia.org/wiki/Haversine_formula\r\n\t// TODO move to projection code, LatLng shouldn't know about Earth\r\n\tdistanceTo: function (other) { // (LatLng) -> Number\r\n\t\tother = L.latLng(other);\r\n\r\n\t\tvar R = 6378137, // earth radius in meters\r\n\t\t    d2r = L.LatLng.DEG_TO_RAD,\r\n\t\t    dLat = (other.lat - this.lat) * d2r,\r\n\t\t    dLon = (other.lng - this.lng) * d2r,\r\n\t\t    lat1 = this.lat * d2r,\r\n\t\t    lat2 = other.lat * d2r,\r\n\t\t    sin1 = Math.sin(dLat / 2),\r\n\t\t    sin2 = Math.sin(dLon / 2);\r\n\r\n\t\tvar a = sin1 * sin1 + sin2 * sin2 * Math.cos(lat1) * Math.cos(lat2);\r\n\r\n\t\treturn R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n\t},\r\n\r\n\twrap: function (a, b) { // (Number, Number) -> LatLng\r\n\t\tvar lng = this.lng;\r\n\r\n\t\ta = a || -180;\r\n\t\tb = b ||  180;\r\n\r\n\t\tlng = (lng + b) % (b - a) + (lng < a || lng === b ? b : a);\r\n\r\n\t\treturn new L.LatLng(this.lat, lng);\r\n\t}\r\n};\r\n\r\nL.latLng = function (a, b) { // (LatLng) or ([Number, Number]) or (Number, Number)\r\n\tif (a instanceof L.LatLng) {\r\n\t\treturn a;\r\n\t}\r\n\tif (L.Util.isArray(a)) {\r\n\t\tif (typeof a[0] === 'number' || typeof a[0] === 'string') {\r\n\t\t\treturn new L.LatLng(a[0], a[1], a[2]);\r\n\t\t} else {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n\tif (a === undefined || a === null) {\r\n\t\treturn a;\r\n\t}\r\n\tif (typeof a === 'object' && 'lat' in a) {\r\n\t\treturn new L.LatLng(a.lat, 'lng' in a ? a.lng : a.lon);\r\n\t}\r\n\tif (b === undefined) {\r\n\t\treturn null;\r\n\t}\r\n\treturn new L.LatLng(a, b);\r\n};\r\n\r\n\n\n/*\r\n * L.LatLngBounds represents a rectangular area on the map in geographical coordinates.\r\n */\r\n\r\nL.LatLngBounds = function (southWest, northEast) { // (LatLng, LatLng) or (LatLng[])\r\n\tif (!southWest) { return; }\r\n\r\n\tvar latlngs = northEast ? [southWest, northEast] : southWest;\r\n\r\n\tfor (var i = 0, len = latlngs.length; i < len; i++) {\r\n\t\tthis.extend(latlngs[i]);\r\n\t}\r\n};\r\n\r\nL.LatLngBounds.prototype = {\r\n\t// extend the bounds to contain the given point or bounds\r\n\textend: function (obj) { // (LatLng) or (LatLngBounds)\r\n\t\tif (!obj) { return this; }\r\n\r\n\t\tvar latLng = L.latLng(obj);\r\n\t\tif (latLng !== null) {\r\n\t\t\tobj = latLng;\r\n\t\t} else {\r\n\t\t\tobj = L.latLngBounds(obj);\r\n\t\t}\r\n\r\n\t\tif (obj instanceof L.LatLng) {\r\n\t\t\tif (!this._southWest && !this._northEast) {\r\n\t\t\t\tthis._southWest = new L.LatLng(obj.lat, obj.lng);\r\n\t\t\t\tthis._northEast = new L.LatLng(obj.lat, obj.lng);\r\n\t\t\t} else {\r\n\t\t\t\tthis._southWest.lat = Math.min(obj.lat, this._southWest.lat);\r\n\t\t\t\tthis._southWest.lng = Math.min(obj.lng, this._southWest.lng);\r\n\r\n\t\t\t\tthis._northEast.lat = Math.max(obj.lat, this._northEast.lat);\r\n\t\t\t\tthis._northEast.lng = Math.max(obj.lng, this._northEast.lng);\r\n\t\t\t}\r\n\t\t} else if (obj instanceof L.LatLngBounds) {\r\n\t\t\tthis.extend(obj._southWest);\r\n\t\t\tthis.extend(obj._northEast);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// extend the bounds by a percentage\r\n\tpad: function (bufferRatio) { // (Number) -> LatLngBounds\r\n\t\tvar sw = this._southWest,\r\n\t\t    ne = this._northEast,\r\n\t\t    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,\r\n\t\t    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;\r\n\r\n\t\treturn new L.LatLngBounds(\r\n\t\t        new L.LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),\r\n\t\t        new L.LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));\r\n\t},\r\n\r\n\tgetCenter: function () { // -> LatLng\r\n\t\treturn new L.LatLng(\r\n\t\t        (this._southWest.lat + this._northEast.lat) / 2,\r\n\t\t        (this._southWest.lng + this._northEast.lng) / 2);\r\n\t},\r\n\r\n\tgetSouthWest: function () {\r\n\t\treturn this._southWest;\r\n\t},\r\n\r\n\tgetNorthEast: function () {\r\n\t\treturn this._northEast;\r\n\t},\r\n\r\n\tgetNorthWest: function () {\r\n\t\treturn new L.LatLng(this.getNorth(), this.getWest());\r\n\t},\r\n\r\n\tgetSouthEast: function () {\r\n\t\treturn new L.LatLng(this.getSouth(), this.getEast());\r\n\t},\r\n\r\n\tgetWest: function () {\r\n\t\treturn this._southWest.lng;\r\n\t},\r\n\r\n\tgetSouth: function () {\r\n\t\treturn this._southWest.lat;\r\n\t},\r\n\r\n\tgetEast: function () {\r\n\t\treturn this._northEast.lng;\r\n\t},\r\n\r\n\tgetNorth: function () {\r\n\t\treturn this._northEast.lat;\r\n\t},\r\n\r\n\tcontains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean\r\n\t\tif (typeof obj[0] === 'number' || obj instanceof L.LatLng) {\r\n\t\t\tobj = L.latLng(obj);\r\n\t\t} else {\r\n\t\t\tobj = L.latLngBounds(obj);\r\n\t\t}\r\n\r\n\t\tvar sw = this._southWest,\r\n\t\t    ne = this._northEast,\r\n\t\t    sw2, ne2;\r\n\r\n\t\tif (obj instanceof L.LatLngBounds) {\r\n\t\t\tsw2 = obj.getSouthWest();\r\n\t\t\tne2 = obj.getNorthEast();\r\n\t\t} else {\r\n\t\t\tsw2 = ne2 = obj;\r\n\t\t}\r\n\r\n\t\treturn (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&\r\n\t\t       (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);\r\n\t},\r\n\r\n\tintersects: function (bounds) { // (LatLngBounds)\r\n\t\tbounds = L.latLngBounds(bounds);\r\n\r\n\t\tvar sw = this._southWest,\r\n\t\t    ne = this._northEast,\r\n\t\t    sw2 = bounds.getSouthWest(),\r\n\t\t    ne2 = bounds.getNorthEast(),\r\n\r\n\t\t    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),\r\n\t\t    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);\r\n\r\n\t\treturn latIntersects && lngIntersects;\r\n\t},\r\n\r\n\ttoBBoxString: function () {\r\n\t\treturn [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');\r\n\t},\r\n\r\n\tequals: function (bounds) { // (LatLngBounds)\r\n\t\tif (!bounds) { return false; }\r\n\r\n\t\tbounds = L.latLngBounds(bounds);\r\n\r\n\t\treturn this._southWest.equals(bounds.getSouthWest()) &&\r\n\t\t       this._northEast.equals(bounds.getNorthEast());\r\n\t},\r\n\r\n\tisValid: function () {\r\n\t\treturn !!(this._southWest && this._northEast);\r\n\t}\r\n};\r\n\r\n//TODO International date line?\r\n\r\nL.latLngBounds = function (a, b) { // (LatLngBounds) or (LatLng, LatLng)\r\n\tif (!a || a instanceof L.LatLngBounds) {\r\n\t\treturn a;\r\n\t}\r\n\treturn new L.LatLngBounds(a, b);\r\n};\r\n\n\n/*\r\n * L.Projection contains various geographical projections used by CRS classes.\r\n */\r\n\r\nL.Projection = {};\r\n\n\n/*\r\n * Spherical Mercator is the most popular map projection, used by EPSG:3857 CRS used by default.\r\n */\r\n\r\nL.Projection.SphericalMercator = {\r\n\tMAX_LATITUDE: 85.0511287798,\r\n\r\n\tproject: function (latlng) { // (LatLng) -> Point\r\n\t\tvar d = L.LatLng.DEG_TO_RAD,\r\n\t\t    max = this.MAX_LATITUDE,\r\n\t\t    lat = Math.max(Math.min(max, latlng.lat), -max),\r\n\t\t    x = latlng.lng * d,\r\n\t\t    y = lat * d;\r\n\r\n\t\ty = Math.log(Math.tan((Math.PI / 4) + (y / 2)));\r\n\r\n\t\treturn new L.Point(x, y);\r\n\t},\r\n\r\n\tunproject: function (point) { // (Point, Boolean) -> LatLng\r\n\t\tvar d = L.LatLng.RAD_TO_DEG,\r\n\t\t    lng = point.x * d,\r\n\t\t    lat = (2 * Math.atan(Math.exp(point.y)) - (Math.PI / 2)) * d;\r\n\r\n\t\treturn new L.LatLng(lat, lng);\r\n\t}\r\n};\r\n\n\n/*\r\n * Simple equirectangular (Plate Carree) projection, used by CRS like EPSG:4326 and Simple.\r\n */\r\n\r\nL.Projection.LonLat = {\r\n\tproject: function (latlng) {\r\n\t\treturn new L.Point(latlng.lng, latlng.lat);\r\n\t},\r\n\r\n\tunproject: function (point) {\r\n\t\treturn new L.LatLng(point.y, point.x);\r\n\t}\r\n};\r\n\n\n/*\r\n * L.CRS is a base object for all defined CRS (Coordinate Reference Systems) in Leaflet.\r\n */\r\n\r\nL.CRS = {\r\n\tlatLngToPoint: function (latlng, zoom) { // (LatLng, Number) -> Point\r\n\t\tvar projectedPoint = this.projection.project(latlng),\r\n\t\t    scale = this.scale(zoom);\r\n\r\n\t\treturn this.transformation._transform(projectedPoint, scale);\r\n\t},\r\n\r\n\tpointToLatLng: function (point, zoom) { // (Point, Number[, Boolean]) -> LatLng\r\n\t\tvar scale = this.scale(zoom),\r\n\t\t    untransformedPoint = this.transformation.untransform(point, scale);\r\n\r\n\t\treturn this.projection.unproject(untransformedPoint);\r\n\t},\r\n\r\n\tproject: function (latlng) {\r\n\t\treturn this.projection.project(latlng);\r\n\t},\r\n\r\n\tscale: function (zoom) {\r\n\t\treturn 256 * Math.pow(2, zoom);\r\n\t},\r\n\r\n\tgetSize: function (zoom) {\r\n\t\tvar s = this.scale(zoom);\r\n\t\treturn L.point(s, s);\r\n\t}\r\n};\r\n\n\n/*\n * A simple CRS that can be used for flat non-Earth maps like panoramas or game maps.\n */\n\nL.CRS.Simple = L.extend({}, L.CRS, {\n\tprojection: L.Projection.LonLat,\n\ttransformation: new L.Transformation(1, 0, -1, 0),\n\n\tscale: function (zoom) {\n\t\treturn Math.pow(2, zoom);\n\t}\n});\n\n\n/*\r\n * L.CRS.EPSG3857 (Spherical Mercator) is the most common CRS for web mapping\r\n * and is used by Leaflet by default.\r\n */\r\n\r\nL.CRS.EPSG3857 = L.extend({}, L.CRS, {\r\n\tcode: 'EPSG:3857',\r\n\r\n\tprojection: L.Projection.SphericalMercator,\r\n\ttransformation: new L.Transformation(0.5 / Math.PI, 0.5, -0.5 / Math.PI, 0.5),\r\n\r\n\tproject: function (latlng) { // (LatLng) -> Point\r\n\t\tvar projectedPoint = this.projection.project(latlng),\r\n\t\t    earthRadius = 6378137;\r\n\t\treturn projectedPoint.multiplyBy(earthRadius);\r\n\t}\r\n});\r\n\r\nL.CRS.EPSG900913 = L.extend({}, L.CRS.EPSG3857, {\r\n\tcode: 'EPSG:900913'\r\n});\r\n\n\n/*\r\n * L.CRS.EPSG4326 is a CRS popular among advanced GIS specialists.\r\n */\r\n\r\nL.CRS.EPSG4326 = L.extend({}, L.CRS, {\r\n\tcode: 'EPSG:4326',\r\n\r\n\tprojection: L.Projection.LonLat,\r\n\ttransformation: new L.Transformation(1 / 360, 0.5, -1 / 360, 0.5)\r\n});\r\n\n\n/*\r\n * L.Map is the central class of the API - it is used to create a map.\r\n */\r\n\r\nL.Map = L.Class.extend({\r\n\r\n\tincludes: L.Mixin.Events,\r\n\r\n\toptions: {\r\n\t\tcrs: L.CRS.EPSG3857,\r\n\r\n\t\t/*\r\n\t\tcenter: LatLng,\r\n\t\tzoom: Number,\r\n\t\tlayers: Array,\r\n\t\t*/\r\n\r\n\t\tfadeAnimation: L.DomUtil.TRANSITION && !L.Browser.android23,\r\n\t\ttrackResize: true,\r\n\t\tmarkerZoomAnimation: L.DomUtil.TRANSITION && L.Browser.any3d\r\n\t},\r\n\r\n\tinitialize: function (id, options) { // (HTMLElement or String, Object)\r\n\t\toptions = L.setOptions(this, options);\r\n\r\n\r\n\t\tthis._initContainer(id);\r\n\t\tthis._initLayout();\r\n\r\n\t\t// hack for https://github.com/Leaflet/Leaflet/issues/1980\r\n\t\tthis._onResize = L.bind(this._onResize, this);\r\n\r\n\t\tthis._initEvents();\r\n\r\n\t\tif (options.maxBounds) {\r\n\t\t\tthis.setMaxBounds(options.maxBounds);\r\n\t\t}\r\n\r\n\t\tif (options.center && options.zoom !== undefined) {\r\n\t\t\tthis.setView(L.latLng(options.center), options.zoom, {reset: true});\r\n\t\t}\r\n\r\n\t\tthis._handlers = [];\r\n\r\n\t\tthis._layers = {};\r\n\t\tthis._zoomBoundLayers = {};\r\n\t\tthis._tileLayersNum = 0;\r\n\r\n\t\tthis.callInitHooks();\r\n\r\n\t\tthis._addLayers(options.layers);\r\n\t},\r\n\r\n\r\n\t// public methods that modify map state\r\n\r\n\t// replaced by animation-powered implementation in Map.PanAnimation.js\r\n\tsetView: function (center, zoom) {\r\n\t\tzoom = zoom === undefined ? this.getZoom() : zoom;\r\n\t\tthis._resetView(L.latLng(center), this._limitZoom(zoom));\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetZoom: function (zoom, options) {\r\n\t\tif (!this._loaded) {\r\n\t\t\tthis._zoom = this._limitZoom(zoom);\r\n\t\t\treturn this;\r\n\t\t}\r\n\t\treturn this.setView(this.getCenter(), zoom, {zoom: options});\r\n\t},\r\n\r\n\tzoomIn: function (delta, options) {\r\n\t\treturn this.setZoom(this._zoom + (delta || 1), options);\r\n\t},\r\n\r\n\tzoomOut: function (delta, options) {\r\n\t\treturn this.setZoom(this._zoom - (delta || 1), options);\r\n\t},\r\n\r\n\tsetZoomAround: function (latlng, zoom, options) {\r\n\t\tvar scale = this.getZoomScale(zoom),\r\n\t\t    viewHalf = this.getSize().divideBy(2),\r\n\t\t    containerPoint = latlng instanceof L.Point ? latlng : this.latLngToContainerPoint(latlng),\r\n\r\n\t\t    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),\r\n\t\t    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));\r\n\r\n\t\treturn this.setView(newCenter, zoom, {zoom: options});\r\n\t},\r\n\r\n\tfitBounds: function (bounds, options) {\r\n\r\n\t\toptions = options || {};\r\n\t\tbounds = bounds.getBounds ? bounds.getBounds() : L.latLngBounds(bounds);\r\n\r\n\t\tvar paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),\r\n\t\t    paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]),\r\n\r\n\t\t    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));\r\n\r\n\t\tzoom = (options.maxZoom) ? Math.min(options.maxZoom, zoom) : zoom;\r\n\r\n\t\tvar paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),\r\n\r\n\t\t    swPoint = this.project(bounds.getSouthWest(), zoom),\r\n\t\t    nePoint = this.project(bounds.getNorthEast(), zoom),\r\n\t\t    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);\r\n\r\n\t\treturn this.setView(center, zoom, options);\r\n\t},\r\n\r\n\tfitWorld: function (options) {\r\n\t\treturn this.fitBounds([[-90, -180], [90, 180]], options);\r\n\t},\r\n\r\n\tpanTo: function (center, options) { // (LatLng)\r\n\t\treturn this.setView(center, this._zoom, {pan: options});\r\n\t},\r\n\r\n\tpanBy: function (offset) { // (Point)\r\n\t\t// replaced with animated panBy in Map.PanAnimation.js\r\n\t\tthis.fire('movestart');\r\n\r\n\t\tthis._rawPanBy(L.point(offset));\r\n\r\n\t\tthis.fire('move');\r\n\t\treturn this.fire('moveend');\r\n\t},\r\n\r\n\tsetMaxBounds: function (bounds) {\r\n\t\tbounds = L.latLngBounds(bounds);\r\n\r\n\t\tthis.options.maxBounds = bounds;\r\n\r\n\t\tif (!bounds) {\r\n\t\t\treturn this.off('moveend', this._panInsideMaxBounds, this);\r\n\t\t}\r\n\r\n\t\tif (this._loaded) {\r\n\t\t\tthis._panInsideMaxBounds();\r\n\t\t}\r\n\r\n\t\treturn this.on('moveend', this._panInsideMaxBounds, this);\r\n\t},\r\n\r\n\tpanInsideBounds: function (bounds, options) {\r\n\t\tvar center = this.getCenter(),\r\n\t\t\tnewCenter = this._limitCenter(center, this._zoom, bounds);\r\n\r\n\t\tif (center.equals(newCenter)) { return this; }\r\n\r\n\t\treturn this.panTo(newCenter, options);\r\n\t},\r\n\r\n\taddLayer: function (layer) {\r\n\t\t// TODO method is too big, refactor\r\n\r\n\t\tvar id = L.stamp(layer);\r\n\r\n\t\tif (this._layers[id]) { return this; }\r\n\r\n\t\tthis._layers[id] = layer;\r\n\r\n\t\t// TODO getMaxZoom, getMinZoom in ILayer (instead of options)\r\n\t\tif (layer.options && (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom))) {\r\n\t\t\tthis._zoomBoundLayers[id] = layer;\r\n\t\t\tthis._updateZoomLevels();\r\n\t\t}\r\n\r\n\t\t// TODO looks ugly, refactor!!!\r\n\t\tif (this.options.zoomAnimation && L.TileLayer && (layer instanceof L.TileLayer)) {\r\n\t\t\tthis._tileLayersNum++;\r\n\t\t\tthis._tileLayersToLoad++;\r\n\t\t\tlayer.on('load', this._onTileLayerLoad, this);\r\n\t\t}\r\n\r\n\t\tif (this._loaded) {\r\n\t\t\tthis._layerAdd(layer);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveLayer: function (layer) {\r\n\t\tvar id = L.stamp(layer);\r\n\r\n\t\tif (!this._layers[id]) { return this; }\r\n\r\n\t\tif (this._loaded) {\r\n\t\t\tlayer.onRemove(this);\r\n\t\t}\r\n\r\n\t\tdelete this._layers[id];\r\n\r\n\t\tif (this._loaded) {\r\n\t\t\tthis.fire('layerremove', {layer: layer});\r\n\t\t}\r\n\r\n\t\tif (this._zoomBoundLayers[id]) {\r\n\t\t\tdelete this._zoomBoundLayers[id];\r\n\t\t\tthis._updateZoomLevels();\r\n\t\t}\r\n\r\n\t\t// TODO looks ugly, refactor\r\n\t\tif (this.options.zoomAnimation && L.TileLayer && (layer instanceof L.TileLayer)) {\r\n\t\t\tthis._tileLayersNum--;\r\n\t\t\tthis._tileLayersToLoad--;\r\n\t\t\tlayer.off('load', this._onTileLayerLoad, this);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\thasLayer: function (layer) {\r\n\t\tif (!layer) { return false; }\r\n\r\n\t\treturn (L.stamp(layer) in this._layers);\r\n\t},\r\n\r\n\teachLayer: function (method, context) {\r\n\t\tfor (var i in this._layers) {\r\n\t\t\tmethod.call(context, this._layers[i]);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tinvalidateSize: function (options) {\r\n\t\tif (!this._loaded) { return this; }\r\n\r\n\t\toptions = L.extend({\r\n\t\t\tanimate: false,\r\n\t\t\tpan: true\r\n\t\t}, options === true ? {animate: true} : options);\r\n\r\n\t\tvar oldSize = this.getSize();\r\n\t\tthis._sizeChanged = true;\r\n\t\tthis._initialCenter = null;\r\n\r\n\t\tvar newSize = this.getSize(),\r\n\t\t    oldCenter = oldSize.divideBy(2).round(),\r\n\t\t    newCenter = newSize.divideBy(2).round(),\r\n\t\t    offset = oldCenter.subtract(newCenter);\r\n\r\n\t\tif (!offset.x && !offset.y) { return this; }\r\n\r\n\t\tif (options.animate && options.pan) {\r\n\t\t\tthis.panBy(offset);\r\n\r\n\t\t} else {\r\n\t\t\tif (options.pan) {\r\n\t\t\t\tthis._rawPanBy(offset);\r\n\t\t\t}\r\n\r\n\t\t\tthis.fire('move');\r\n\r\n\t\t\tif (options.debounceMoveend) {\r\n\t\t\t\tclearTimeout(this._sizeTimer);\r\n\t\t\t\tthis._sizeTimer = setTimeout(L.bind(this.fire, this, 'moveend'), 200);\r\n\t\t\t} else {\r\n\t\t\t\tthis.fire('moveend');\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this.fire('resize', {\r\n\t\t\toldSize: oldSize,\r\n\t\t\tnewSize: newSize\r\n\t\t});\r\n\t},\r\n\r\n\t// TODO handler.addTo\r\n\taddHandler: function (name, HandlerClass) {\r\n\t\tif (!HandlerClass) { return this; }\r\n\r\n\t\tvar handler = this[name] = new HandlerClass(this);\r\n\r\n\t\tthis._handlers.push(handler);\r\n\r\n\t\tif (this.options[name]) {\r\n\t\t\thandler.enable();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremove: function () {\r\n\t\tif (this._loaded) {\r\n\t\t\tthis.fire('unload');\r\n\t\t}\r\n\r\n\t\tthis._initEvents('off');\r\n\r\n\t\ttry {\r\n\t\t\t// throws error in IE6-8\r\n\t\t\tdelete this._container._leaflet;\r\n\t\t} catch (e) {\r\n\t\t\tthis._container._leaflet = undefined;\r\n\t\t}\r\n\r\n\t\tthis._clearPanes();\r\n\t\tif (this._clearControlPos) {\r\n\t\t\tthis._clearControlPos();\r\n\t\t}\r\n\r\n\t\tthis._clearHandlers();\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\r\n\t// public methods for getting map state\r\n\r\n\tgetCenter: function () { // (Boolean) -> LatLng\r\n\t\tthis._checkIfLoaded();\r\n\r\n\t\tif (this._initialCenter && !this._moved()) {\r\n\t\t\treturn this._initialCenter;\r\n\t\t}\r\n\t\treturn this.layerPointToLatLng(this._getCenterLayerPoint());\r\n\t},\r\n\r\n\tgetZoom: function () {\r\n\t\treturn this._zoom;\r\n\t},\r\n\r\n\tgetBounds: function () {\r\n\t\tvar bounds = this.getPixelBounds(),\r\n\t\t    sw = this.unproject(bounds.getBottomLeft()),\r\n\t\t    ne = this.unproject(bounds.getTopRight());\r\n\r\n\t\treturn new L.LatLngBounds(sw, ne);\r\n\t},\r\n\r\n\tgetMinZoom: function () {\r\n\t\treturn this.options.minZoom === undefined ?\r\n\t\t\t(this._layersMinZoom === undefined ? 0 : this._layersMinZoom) :\r\n\t\t\tthis.options.minZoom;\r\n\t},\r\n\r\n\tgetMaxZoom: function () {\r\n\t\treturn this.options.maxZoom === undefined ?\r\n\t\t\t(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :\r\n\t\t\tthis.options.maxZoom;\r\n\t},\r\n\r\n\tgetBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number\r\n\t\tbounds = L.latLngBounds(bounds);\r\n\r\n\t\tvar zoom = this.getMinZoom() - (inside ? 1 : 0),\r\n\t\t    maxZoom = this.getMaxZoom(),\r\n\t\t    size = this.getSize(),\r\n\r\n\t\t    nw = bounds.getNorthWest(),\r\n\t\t    se = bounds.getSouthEast(),\r\n\r\n\t\t    zoomNotFound = true,\r\n\t\t    boundsSize;\r\n\r\n\t\tpadding = L.point(padding || [0, 0]);\r\n\r\n\t\tdo {\r\n\t\t\tzoom++;\r\n\t\t\tboundsSize = this.project(se, zoom).subtract(this.project(nw, zoom)).add(padding);\r\n\t\t\tzoomNotFound = !inside ? size.contains(boundsSize) : boundsSize.x < size.x || boundsSize.y < size.y;\r\n\r\n\t\t} while (zoomNotFound && zoom <= maxZoom);\r\n\r\n\t\tif (zoomNotFound && inside) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn inside ? zoom : zoom - 1;\r\n\t},\r\n\r\n\tgetSize: function () {\r\n\t\tif (!this._size || this._sizeChanged) {\r\n\t\t\tthis._size = new L.Point(\r\n\t\t\t\tthis._container.clientWidth,\r\n\t\t\t\tthis._container.clientHeight);\r\n\r\n\t\t\tthis._sizeChanged = false;\r\n\t\t}\r\n\t\treturn this._size.clone();\r\n\t},\r\n\r\n\tgetPixelBounds: function () {\r\n\t\tvar topLeftPoint = this._getTopLeftPoint();\r\n\t\treturn new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));\r\n\t},\r\n\r\n\tgetPixelOrigin: function () {\r\n\t\tthis._checkIfLoaded();\r\n\t\treturn this._initialTopLeftPoint;\r\n\t},\r\n\r\n\tgetPanes: function () {\r\n\t\treturn this._panes;\r\n\t},\r\n\r\n\tgetContainer: function () {\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\r\n\t// TODO replace with universal implementation after refactoring projections\r\n\r\n\tgetZoomScale: function (toZoom) {\r\n\t\tvar crs = this.options.crs;\r\n\t\treturn crs.scale(toZoom) / crs.scale(this._zoom);\r\n\t},\r\n\r\n\tgetScaleZoom: function (scale) {\r\n\t\treturn this._zoom + (Math.log(scale) / Math.LN2);\r\n\t},\r\n\r\n\r\n\t// conversion methods\r\n\r\n\tproject: function (latlng, zoom) { // (LatLng[, Number]) -> Point\r\n\t\tzoom = zoom === undefined ? this._zoom : zoom;\r\n\t\treturn this.options.crs.latLngToPoint(L.latLng(latlng), zoom);\r\n\t},\r\n\r\n\tunproject: function (point, zoom) { // (Point[, Number]) -> LatLng\r\n\t\tzoom = zoom === undefined ? this._zoom : zoom;\r\n\t\treturn this.options.crs.pointToLatLng(L.point(point), zoom);\r\n\t},\r\n\r\n\tlayerPointToLatLng: function (point) { // (Point)\r\n\t\tvar projectedPoint = L.point(point).add(this.getPixelOrigin());\r\n\t\treturn this.unproject(projectedPoint);\r\n\t},\r\n\r\n\tlatLngToLayerPoint: function (latlng) { // (LatLng)\r\n\t\tvar projectedPoint = this.project(L.latLng(latlng))._round();\r\n\t\treturn projectedPoint._subtract(this.getPixelOrigin());\r\n\t},\r\n\r\n\tcontainerPointToLayerPoint: function (point) { // (Point)\r\n\t\treturn L.point(point).subtract(this._getMapPanePos());\r\n\t},\r\n\r\n\tlayerPointToContainerPoint: function (point) { // (Point)\r\n\t\treturn L.point(point).add(this._getMapPanePos());\r\n\t},\r\n\r\n\tcontainerPointToLatLng: function (point) {\r\n\t\tvar layerPoint = this.containerPointToLayerPoint(L.point(point));\r\n\t\treturn this.layerPointToLatLng(layerPoint);\r\n\t},\r\n\r\n\tlatLngToContainerPoint: function (latlng) {\r\n\t\treturn this.layerPointToContainerPoint(this.latLngToLayerPoint(L.latLng(latlng)));\r\n\t},\r\n\r\n\tmouseEventToContainerPoint: function (e) { // (MouseEvent)\r\n\t\treturn L.DomEvent.getMousePosition(e, this._container);\r\n\t},\r\n\r\n\tmouseEventToLayerPoint: function (e) { // (MouseEvent)\r\n\t\treturn this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));\r\n\t},\r\n\r\n\tmouseEventToLatLng: function (e) { // (MouseEvent)\r\n\t\treturn this.layerPointToLatLng(this.mouseEventToLayerPoint(e));\r\n\t},\r\n\r\n\r\n\t// map initialization methods\r\n\r\n\t_initContainer: function (id) {\r\n\t\tvar container = this._container = L.DomUtil.get(id);\r\n\r\n\t\tif (!container) {\r\n\t\t\tthrow new Error('Map container not found.');\r\n\t\t} else if (container._leaflet) {\r\n\t\t\tthrow new Error('Map container is already initialized.');\r\n\t\t}\r\n\r\n\t\tcontainer._leaflet = true;\r\n\t},\r\n\r\n\t_initLayout: function () {\r\n\t\tvar container = this._container;\r\n\r\n\t\tL.DomUtil.addClass(container, 'leaflet-container' +\r\n\t\t\t(L.Browser.touch ? ' leaflet-touch' : '') +\r\n\t\t\t(L.Browser.retina ? ' leaflet-retina' : '') +\r\n\t\t\t(L.Browser.ielt9 ? ' leaflet-oldie' : '') +\r\n\t\t\t(this.options.fadeAnimation ? ' leaflet-fade-anim' : ''));\r\n\r\n\t\tvar position = L.DomUtil.getStyle(container, 'position');\r\n\r\n\t\tif (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {\r\n\t\t\tcontainer.style.position = 'relative';\r\n\t\t}\r\n\r\n\t\tthis._initPanes();\r\n\r\n\t\tif (this._initControlPos) {\r\n\t\t\tthis._initControlPos();\r\n\t\t}\r\n\t},\r\n\r\n\t_initPanes: function () {\r\n\t\tvar panes = this._panes = {};\r\n\r\n\t\tthis._mapPane = panes.mapPane = this._createPane('leaflet-map-pane', this._container);\r\n\r\n\t\tthis._tilePane = panes.tilePane = this._createPane('leaflet-tile-pane', this._mapPane);\r\n\t\tpanes.objectsPane = this._createPane('leaflet-objects-pane', this._mapPane);\r\n\t\tpanes.shadowPane = this._createPane('leaflet-shadow-pane');\r\n\t\tpanes.overlayPane = this._createPane('leaflet-overlay-pane');\r\n\t\tpanes.markerPane = this._createPane('leaflet-marker-pane');\r\n\t\tpanes.popupPane = this._createPane('leaflet-popup-pane');\r\n\r\n\t\tvar zoomHide = ' leaflet-zoom-hide';\r\n\r\n\t\tif (!this.options.markerZoomAnimation) {\r\n\t\t\tL.DomUtil.addClass(panes.markerPane, zoomHide);\r\n\t\t\tL.DomUtil.addClass(panes.shadowPane, zoomHide);\r\n\t\t\tL.DomUtil.addClass(panes.popupPane, zoomHide);\r\n\t\t}\r\n\t},\r\n\r\n\t_createPane: function (className, container) {\r\n\t\treturn L.DomUtil.create('div', className, container || this._panes.objectsPane);\r\n\t},\r\n\r\n\t_clearPanes: function () {\r\n\t\tthis._container.removeChild(this._mapPane);\r\n\t},\r\n\r\n\t_addLayers: function (layers) {\r\n\t\tlayers = layers ? (L.Util.isArray(layers) ? layers : [layers]) : [];\r\n\r\n\t\tfor (var i = 0, len = layers.length; i < len; i++) {\r\n\t\t\tthis.addLayer(layers[i]);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// private methods that modify map state\r\n\r\n\t_resetView: function (center, zoom, preserveMapOffset, afterZoomAnim) {\r\n\r\n\t\tvar zoomChanged = (this._zoom !== zoom);\r\n\r\n\t\tif (!afterZoomAnim) {\r\n\t\t\tthis.fire('movestart');\r\n\r\n\t\t\tif (zoomChanged) {\r\n\t\t\t\tthis.fire('zoomstart');\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._zoom = zoom;\r\n\t\tthis._initialCenter = center;\r\n\r\n\t\tthis._initialTopLeftPoint = this._getNewTopLeftPoint(center);\r\n\r\n\t\tif (!preserveMapOffset) {\r\n\t\t\tL.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));\r\n\t\t} else {\r\n\t\t\tthis._initialTopLeftPoint._add(this._getMapPanePos());\r\n\t\t}\r\n\r\n\t\tthis._tileLayersToLoad = this._tileLayersNum;\r\n\r\n\t\tvar loading = !this._loaded;\r\n\t\tthis._loaded = true;\r\n\r\n\t\tthis.fire('viewreset', {hard: !preserveMapOffset});\r\n\r\n\t\tif (loading) {\r\n\t\t\tthis.fire('load');\r\n\t\t\tthis.eachLayer(this._layerAdd, this);\r\n\t\t}\r\n\r\n\t\tthis.fire('move');\r\n\r\n\t\tif (zoomChanged || afterZoomAnim) {\r\n\t\t\tthis.fire('zoomend');\r\n\t\t}\r\n\r\n\t\tthis.fire('moveend', {hard: !preserveMapOffset});\r\n\t},\r\n\r\n\t_rawPanBy: function (offset) {\r\n\t\tL.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));\r\n\t},\r\n\r\n\t_getZoomSpan: function () {\r\n\t\treturn this.getMaxZoom() - this.getMinZoom();\r\n\t},\r\n\r\n\t_updateZoomLevels: function () {\r\n\t\tvar i,\r\n\t\t\tminZoom = Infinity,\r\n\t\t\tmaxZoom = -Infinity,\r\n\t\t\toldZoomSpan = this._getZoomSpan();\r\n\r\n\t\tfor (i in this._zoomBoundLayers) {\r\n\t\t\tvar layer = this._zoomBoundLayers[i];\r\n\t\t\tif (!isNaN(layer.options.minZoom)) {\r\n\t\t\t\tminZoom = Math.min(minZoom, layer.options.minZoom);\r\n\t\t\t}\r\n\t\t\tif (!isNaN(layer.options.maxZoom)) {\r\n\t\t\t\tmaxZoom = Math.max(maxZoom, layer.options.maxZoom);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (i === undefined) { // we have no tilelayers\r\n\t\t\tthis._layersMaxZoom = this._layersMinZoom = undefined;\r\n\t\t} else {\r\n\t\t\tthis._layersMaxZoom = maxZoom;\r\n\t\t\tthis._layersMinZoom = minZoom;\r\n\t\t}\r\n\r\n\t\tif (oldZoomSpan !== this._getZoomSpan()) {\r\n\t\t\tthis.fire('zoomlevelschange');\r\n\t\t}\r\n\t},\r\n\r\n\t_panInsideMaxBounds: function () {\r\n\t\tthis.panInsideBounds(this.options.maxBounds);\r\n\t},\r\n\r\n\t_checkIfLoaded: function () {\r\n\t\tif (!this._loaded) {\r\n\t\t\tthrow new Error('Set map center and zoom first.');\r\n\t\t}\r\n\t},\r\n\r\n\t// map events\r\n\r\n\t_initEvents: function (onOff) {\r\n\t\tif (!L.DomEvent) { return; }\r\n\r\n\t\tonOff = onOff || 'on';\r\n\r\n\t\tL.DomEvent[onOff](this._container, 'click', this._onMouseClick, this);\r\n\r\n\t\tvar events = ['dblclick', 'mousedown', 'mouseup', 'mouseenter',\r\n\t\t              'mouseleave', 'mousemove', 'contextmenu'],\r\n\t\t    i, len;\r\n\r\n\t\tfor (i = 0, len = events.length; i < len; i++) {\r\n\t\t\tL.DomEvent[onOff](this._container, events[i], this._fireMouseEvent, this);\r\n\t\t}\r\n\r\n\t\tif (this.options.trackResize) {\r\n\t\t\tL.DomEvent[onOff](window, 'resize', this._onResize, this);\r\n\t\t}\r\n\t},\r\n\r\n\t_onResize: function () {\r\n\t\tL.Util.cancelAnimFrame(this._resizeRequest);\r\n\t\tthis._resizeRequest = L.Util.requestAnimFrame(\r\n\t\t        function () { this.invalidateSize({debounceMoveend: true}); }, this, false, this._container);\r\n\t},\r\n\r\n\t_onMouseClick: function (e) {\r\n\t\tif (!this._loaded || (!e._simulated &&\r\n\t\t        ((this.dragging && this.dragging.moved()) ||\r\n\t\t         (this.boxZoom  && this.boxZoom.moved()))) ||\r\n\t\t            L.DomEvent._skipped(e)) { return; }\r\n\r\n\t\tthis.fire('preclick');\r\n\t\tthis._fireMouseEvent(e);\r\n\t},\r\n\r\n\t_fireMouseEvent: function (e) {\r\n\t\tif (!this._loaded || L.DomEvent._skipped(e)) { return; }\r\n\r\n\t\tvar type = e.type;\r\n\r\n\t\ttype = (type === 'mouseenter' ? 'mouseover' : (type === 'mouseleave' ? 'mouseout' : type));\r\n\r\n\t\tif (!this.hasEventListeners(type)) { return; }\r\n\r\n\t\tif (type === 'contextmenu') {\r\n\t\t\tL.DomEvent.preventDefault(e);\r\n\t\t}\r\n\r\n\t\tvar containerPoint = this.mouseEventToContainerPoint(e),\r\n\t\t    layerPoint = this.containerPointToLayerPoint(containerPoint),\r\n\t\t    latlng = this.layerPointToLatLng(layerPoint);\r\n\r\n\t\tthis.fire(type, {\r\n\t\t\tlatlng: latlng,\r\n\t\t\tlayerPoint: layerPoint,\r\n\t\t\tcontainerPoint: containerPoint,\r\n\t\t\toriginalEvent: e\r\n\t\t});\r\n\t},\r\n\r\n\t_onTileLayerLoad: function () {\r\n\t\tthis._tileLayersToLoad--;\r\n\t\tif (this._tileLayersNum && !this._tileLayersToLoad) {\r\n\t\t\tthis.fire('tilelayersload');\r\n\t\t}\r\n\t},\r\n\r\n\t_clearHandlers: function () {\r\n\t\tfor (var i = 0, len = this._handlers.length; i < len; i++) {\r\n\t\t\tthis._handlers[i].disable();\r\n\t\t}\r\n\t},\r\n\r\n\twhenReady: function (callback, context) {\r\n\t\tif (this._loaded) {\r\n\t\t\tcallback.call(context || this, this);\r\n\t\t} else {\r\n\t\t\tthis.on('load', callback, context);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_layerAdd: function (layer) {\r\n\t\tlayer.onAdd(this);\r\n\t\tthis.fire('layeradd', {layer: layer});\r\n\t},\r\n\r\n\r\n\t// private methods for getting map state\r\n\r\n\t_getMapPanePos: function () {\r\n\t\treturn L.DomUtil.getPosition(this._mapPane);\r\n\t},\r\n\r\n\t_moved: function () {\r\n\t\tvar pos = this._getMapPanePos();\r\n\t\treturn pos && !pos.equals([0, 0]);\r\n\t},\r\n\r\n\t_getTopLeftPoint: function () {\r\n\t\treturn this.getPixelOrigin().subtract(this._getMapPanePos());\r\n\t},\r\n\r\n\t_getNewTopLeftPoint: function (center, zoom) {\r\n\t\tvar viewHalf = this.getSize()._divideBy(2);\r\n\t\t// TODO round on display, not calculation to increase precision?\r\n\t\treturn this.project(center, zoom)._subtract(viewHalf)._round();\r\n\t},\r\n\r\n\t_latLngToNewLayerPoint: function (latlng, newZoom, newCenter) {\r\n\t\tvar topLeft = this._getNewTopLeftPoint(newCenter, newZoom).add(this._getMapPanePos());\r\n\t\treturn this.project(latlng, newZoom)._subtract(topLeft);\r\n\t},\r\n\r\n\t// layer point of the current center\r\n\t_getCenterLayerPoint: function () {\r\n\t\treturn this.containerPointToLayerPoint(this.getSize()._divideBy(2));\r\n\t},\r\n\r\n\t// offset of the specified place to the current center in pixels\r\n\t_getCenterOffset: function (latlng) {\r\n\t\treturn this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());\r\n\t},\r\n\r\n\t// adjust center for view to get inside bounds\r\n\t_limitCenter: function (center, zoom, bounds) {\r\n\r\n\t\tif (!bounds) { return center; }\r\n\r\n\t\tvar centerPoint = this.project(center, zoom),\r\n\t\t    viewHalf = this.getSize().divideBy(2),\r\n\t\t    viewBounds = new L.Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),\r\n\t\t    offset = this._getBoundsOffset(viewBounds, bounds, zoom);\r\n\r\n\t\treturn this.unproject(centerPoint.add(offset), zoom);\r\n\t},\r\n\r\n\t// adjust offset for view to get inside bounds\r\n\t_limitOffset: function (offset, bounds) {\r\n\t\tif (!bounds) { return offset; }\r\n\r\n\t\tvar viewBounds = this.getPixelBounds(),\r\n\t\t    newBounds = new L.Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));\r\n\r\n\t\treturn offset.add(this._getBoundsOffset(newBounds, bounds));\r\n\t},\r\n\r\n\t// returns offset needed for pxBounds to get inside maxBounds at a specified zoom\r\n\t_getBoundsOffset: function (pxBounds, maxBounds, zoom) {\r\n\t\tvar nwOffset = this.project(maxBounds.getNorthWest(), zoom).subtract(pxBounds.min),\r\n\t\t    seOffset = this.project(maxBounds.getSouthEast(), zoom).subtract(pxBounds.max),\r\n\r\n\t\t    dx = this._rebound(nwOffset.x, -seOffset.x),\r\n\t\t    dy = this._rebound(nwOffset.y, -seOffset.y);\r\n\r\n\t\treturn new L.Point(dx, dy);\r\n\t},\r\n\r\n\t_rebound: function (left, right) {\r\n\t\treturn left + right > 0 ?\r\n\t\t\tMath.round(left - right) / 2 :\r\n\t\t\tMath.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));\r\n\t},\r\n\r\n\t_limitZoom: function (zoom) {\r\n\t\tvar min = this.getMinZoom(),\r\n\t\t    max = this.getMaxZoom();\r\n\r\n\t\treturn Math.max(min, Math.min(max, zoom));\r\n\t}\r\n});\r\n\r\nL.map = function (id, options) {\r\n\treturn new L.Map(id, options);\r\n};\r\n\n\n/*\r\n * Mercator projection that takes into account that the Earth is not a perfect sphere.\r\n * Less popular than spherical mercator; used by projections like EPSG:3395.\r\n */\r\n\r\nL.Projection.Mercator = {\r\n\tMAX_LATITUDE: 85.0840591556,\r\n\r\n\tR_MINOR: 6356752.314245179,\r\n\tR_MAJOR: 6378137,\r\n\r\n\tproject: function (latlng) { // (LatLng) -> Point\r\n\t\tvar d = L.LatLng.DEG_TO_RAD,\r\n\t\t    max = this.MAX_LATITUDE,\r\n\t\t    lat = Math.max(Math.min(max, latlng.lat), -max),\r\n\t\t    r = this.R_MAJOR,\r\n\t\t    r2 = this.R_MINOR,\r\n\t\t    x = latlng.lng * d * r,\r\n\t\t    y = lat * d,\r\n\t\t    tmp = r2 / r,\r\n\t\t    eccent = Math.sqrt(1.0 - tmp * tmp),\r\n\t\t    con = eccent * Math.sin(y);\r\n\r\n\t\tcon = Math.pow((1 - con) / (1 + con), eccent * 0.5);\r\n\r\n\t\tvar ts = Math.tan(0.5 * ((Math.PI * 0.5) - y)) / con;\r\n\t\ty = -r * Math.log(ts);\r\n\r\n\t\treturn new L.Point(x, y);\r\n\t},\r\n\r\n\tunproject: function (point) { // (Point, Boolean) -> LatLng\r\n\t\tvar d = L.LatLng.RAD_TO_DEG,\r\n\t\t    r = this.R_MAJOR,\r\n\t\t    r2 = this.R_MINOR,\r\n\t\t    lng = point.x * d / r,\r\n\t\t    tmp = r2 / r,\r\n\t\t    eccent = Math.sqrt(1 - (tmp * tmp)),\r\n\t\t    ts = Math.exp(- point.y / r),\r\n\t\t    phi = (Math.PI / 2) - 2 * Math.atan(ts),\r\n\t\t    numIter = 15,\r\n\t\t    tol = 1e-7,\r\n\t\t    i = numIter,\r\n\t\t    dphi = 0.1,\r\n\t\t    con;\r\n\r\n\t\twhile ((Math.abs(dphi) > tol) && (--i > 0)) {\r\n\t\t\tcon = eccent * Math.sin(phi);\r\n\t\t\tdphi = (Math.PI / 2) - 2 * Math.atan(ts *\r\n\t\t\t            Math.pow((1.0 - con) / (1.0 + con), 0.5 * eccent)) - phi;\r\n\t\t\tphi += dphi;\r\n\t\t}\r\n\r\n\t\treturn new L.LatLng(phi * d, lng);\r\n\t}\r\n};\r\n\n\n\r\nL.CRS.EPSG3395 = L.extend({}, L.CRS, {\r\n\tcode: 'EPSG:3395',\r\n\r\n\tprojection: L.Projection.Mercator,\r\n\r\n\ttransformation: (function () {\r\n\t\tvar m = L.Projection.Mercator,\r\n\t\t    r = m.R_MAJOR,\r\n\t\t    scale = 0.5 / (Math.PI * r);\r\n\r\n\t\treturn new L.Transformation(scale, 0.5, -scale, 0.5);\r\n\t}())\r\n});\r\n\n\n/*\r\n * L.TileLayer is used for standard xyz-numbered tile layers.\r\n */\r\n\r\nL.TileLayer = L.Class.extend({\r\n\tincludes: L.Mixin.Events,\r\n\r\n\toptions: {\r\n\t\tminZoom: 0,\r\n\t\tmaxZoom: 18,\r\n\t\ttileSize: 256,\r\n\t\tsubdomains: 'abc',\r\n\t\terrorTileUrl: '',\r\n\t\tattribution: '',\r\n\t\tzoomOffset: 0,\r\n\t\topacity: 1,\r\n\t\t/*\r\n\t\tmaxNativeZoom: null,\r\n\t\tzIndex: null,\r\n\t\ttms: false,\r\n\t\tcontinuousWorld: false,\r\n\t\tnoWrap: false,\r\n\t\tzoomReverse: false,\r\n\t\tdetectRetina: false,\r\n\t\treuseTiles: false,\r\n\t\tbounds: false,\r\n\t\t*/\r\n\t\tunloadInvisibleTiles: L.Browser.mobile,\r\n\t\tupdateWhenIdle: L.Browser.mobile\r\n\t},\r\n\r\n\tinitialize: function (url, options) {\r\n\t\toptions = L.setOptions(this, options);\r\n\r\n\t\t// detecting retina displays, adjusting tileSize and zoom levels\r\n\t\tif (options.detectRetina && L.Browser.retina && options.maxZoom > 0) {\r\n\r\n\t\t\toptions.tileSize = Math.floor(options.tileSize / 2);\r\n\t\t\toptions.zoomOffset++;\r\n\r\n\t\t\tif (options.minZoom > 0) {\r\n\t\t\t\toptions.minZoom--;\r\n\t\t\t}\r\n\t\t\tthis.options.maxZoom--;\r\n\t\t}\r\n\r\n\t\tif (options.bounds) {\r\n\t\t\toptions.bounds = L.latLngBounds(options.bounds);\r\n\t\t}\r\n\r\n\t\tthis._url = url;\r\n\r\n\t\tvar subdomains = this.options.subdomains;\r\n\r\n\t\tif (typeof subdomains === 'string') {\r\n\t\t\tthis.options.subdomains = subdomains.split('');\r\n\t\t}\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\t\tthis._animated = map._zoomAnimated;\r\n\r\n\t\t// create a container div for tiles\r\n\t\tthis._initContainer();\r\n\r\n\t\t// set up events\r\n\t\tmap.on({\r\n\t\t\t'viewreset': this._reset,\r\n\t\t\t'moveend': this._update\r\n\t\t}, this);\r\n\r\n\t\tif (this._animated) {\r\n\t\t\tmap.on({\r\n\t\t\t\t'zoomanim': this._animateZoom,\r\n\t\t\t\t'zoomend': this._endZoomAnim\r\n\t\t\t}, this);\r\n\t\t}\r\n\r\n\t\tif (!this.options.updateWhenIdle) {\r\n\t\t\tthis._limitedUpdate = L.Util.limitExecByInterval(this._update, 150, this);\r\n\t\t\tmap.on('move', this._limitedUpdate, this);\r\n\t\t}\r\n\r\n\t\tthis._reset();\r\n\t\tthis._update();\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tthis._container.parentNode.removeChild(this._container);\r\n\r\n\t\tmap.off({\r\n\t\t\t'viewreset': this._reset,\r\n\t\t\t'moveend': this._update\r\n\t\t}, this);\r\n\r\n\t\tif (this._animated) {\r\n\t\t\tmap.off({\r\n\t\t\t\t'zoomanim': this._animateZoom,\r\n\t\t\t\t'zoomend': this._endZoomAnim\r\n\t\t\t}, this);\r\n\t\t}\r\n\r\n\t\tif (!this.options.updateWhenIdle) {\r\n\t\t\tmap.off('move', this._limitedUpdate, this);\r\n\t\t}\r\n\r\n\t\tthis._container = null;\r\n\t\tthis._map = null;\r\n\t},\r\n\r\n\tbringToFront: function () {\r\n\t\tvar pane = this._map._panes.tilePane;\r\n\r\n\t\tif (this._container) {\r\n\t\t\tpane.appendChild(this._container);\r\n\t\t\tthis._setAutoZIndex(pane, Math.max);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tbringToBack: function () {\r\n\t\tvar pane = this._map._panes.tilePane;\r\n\r\n\t\tif (this._container) {\r\n\t\t\tpane.insertBefore(this._container, pane.firstChild);\r\n\t\t\tthis._setAutoZIndex(pane, Math.min);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetAttribution: function () {\r\n\t\treturn this.options.attribution;\r\n\t},\r\n\r\n\tgetContainer: function () {\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\tsetOpacity: function (opacity) {\r\n\t\tthis.options.opacity = opacity;\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._updateOpacity();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetZIndex: function (zIndex) {\r\n\t\tthis.options.zIndex = zIndex;\r\n\t\tthis._updateZIndex();\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetUrl: function (url, noRedraw) {\r\n\t\tthis._url = url;\r\n\r\n\t\tif (!noRedraw) {\r\n\t\t\tthis.redraw();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tredraw: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis._reset({hard: true});\r\n\t\t\tthis._update();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_updateZIndex: function () {\r\n\t\tif (this._container && this.options.zIndex !== undefined) {\r\n\t\t\tthis._container.style.zIndex = this.options.zIndex;\r\n\t\t}\r\n\t},\r\n\r\n\t_setAutoZIndex: function (pane, compare) {\r\n\r\n\t\tvar layers = pane.children,\r\n\t\t    edgeZIndex = -compare(Infinity, -Infinity), // -Infinity for max, Infinity for min\r\n\t\t    zIndex, i, len;\r\n\r\n\t\tfor (i = 0, len = layers.length; i < len; i++) {\r\n\r\n\t\t\tif (layers[i] !== this._container) {\r\n\t\t\t\tzIndex = parseInt(layers[i].style.zIndex, 10);\r\n\r\n\t\t\t\tif (!isNaN(zIndex)) {\r\n\t\t\t\t\tedgeZIndex = compare(edgeZIndex, zIndex);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.options.zIndex = this._container.style.zIndex =\r\n\t\t        (isFinite(edgeZIndex) ? edgeZIndex : 0) + compare(1, -1);\r\n\t},\r\n\r\n\t_updateOpacity: function () {\r\n\t\tvar i,\r\n\t\t    tiles = this._tiles;\r\n\r\n\t\tif (L.Browser.ielt9) {\r\n\t\t\tfor (i in tiles) {\r\n\t\t\t\tL.DomUtil.setOpacity(tiles[i], this.options.opacity);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tL.DomUtil.setOpacity(this._container, this.options.opacity);\r\n\t\t}\r\n\t},\r\n\r\n\t_initContainer: function () {\r\n\t\tvar tilePane = this._map._panes.tilePane;\r\n\r\n\t\tif (!this._container) {\r\n\t\t\tthis._container = L.DomUtil.create('div', 'leaflet-layer');\r\n\r\n\t\t\tthis._updateZIndex();\r\n\r\n\t\t\tif (this._animated) {\r\n\t\t\t\tvar className = 'leaflet-tile-container';\r\n\r\n\t\t\t\tthis._bgBuffer = L.DomUtil.create('div', className, this._container);\r\n\t\t\t\tthis._tileContainer = L.DomUtil.create('div', className, this._container);\r\n\r\n\t\t\t} else {\r\n\t\t\t\tthis._tileContainer = this._container;\r\n\t\t\t}\r\n\r\n\t\t\ttilePane.appendChild(this._container);\r\n\r\n\t\t\tif (this.options.opacity < 1) {\r\n\t\t\t\tthis._updateOpacity();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_reset: function (e) {\r\n\t\tfor (var key in this._tiles) {\r\n\t\t\tthis.fire('tileunload', {tile: this._tiles[key]});\r\n\t\t}\r\n\r\n\t\tthis._tiles = {};\r\n\t\tthis._tilesToLoad = 0;\r\n\r\n\t\tif (this.options.reuseTiles) {\r\n\t\t\tthis._unusedTiles = [];\r\n\t\t}\r\n\r\n\t\tthis._tileContainer.innerHTML = '';\r\n\r\n\t\tif (this._animated && e && e.hard) {\r\n\t\t\tthis._clearBgBuffer();\r\n\t\t}\r\n\r\n\t\tthis._initContainer();\r\n\t},\r\n\r\n\t_getTileSize: function () {\r\n\t\tvar map = this._map,\r\n\t\t    zoom = map.getZoom() + this.options.zoomOffset,\r\n\t\t    zoomN = this.options.maxNativeZoom,\r\n\t\t    tileSize = this.options.tileSize;\r\n\r\n\t\tif (zoomN && zoom > zoomN) {\r\n\t\t\ttileSize = Math.round(map.getZoomScale(zoom) / map.getZoomScale(zoomN) * tileSize);\r\n\t\t}\r\n\r\n\t\treturn tileSize;\r\n\t},\r\n\r\n\t_update: function () {\r\n\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tvar map = this._map,\r\n\t\t    bounds = map.getPixelBounds(),\r\n\t\t    zoom = map.getZoom(),\r\n\t\t    tileSize = this._getTileSize();\r\n\r\n\t\tif (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar tileBounds = L.bounds(\r\n\t\t        bounds.min.divideBy(tileSize)._floor(),\r\n\t\t        bounds.max.divideBy(tileSize)._floor());\r\n\r\n\t\tthis._addTilesFromCenterOut(tileBounds);\r\n\r\n\t\tif (this.options.unloadInvisibleTiles || this.options.reuseTiles) {\r\n\t\t\tthis._removeOtherTiles(tileBounds);\r\n\t\t}\r\n\t},\r\n\r\n\t_addTilesFromCenterOut: function (bounds) {\r\n\t\tvar queue = [],\r\n\t\t    center = bounds.getCenter();\r\n\r\n\t\tvar j, i, point;\r\n\r\n\t\tfor (j = bounds.min.y; j <= bounds.max.y; j++) {\r\n\t\t\tfor (i = bounds.min.x; i <= bounds.max.x; i++) {\r\n\t\t\t\tpoint = new L.Point(i, j);\r\n\r\n\t\t\t\tif (this._tileShouldBeLoaded(point)) {\r\n\t\t\t\t\tqueue.push(point);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar tilesToLoad = queue.length;\r\n\r\n\t\tif (tilesToLoad === 0) { return; }\r\n\r\n\t\t// load tiles in order of their distance to center\r\n\t\tqueue.sort(function (a, b) {\r\n\t\t\treturn a.distanceTo(center) - b.distanceTo(center);\r\n\t\t});\r\n\r\n\t\tvar fragment = document.createDocumentFragment();\r\n\r\n\t\t// if its the first batch of tiles to load\r\n\t\tif (!this._tilesToLoad) {\r\n\t\t\tthis.fire('loading');\r\n\t\t}\r\n\r\n\t\tthis._tilesToLoad += tilesToLoad;\r\n\r\n\t\tfor (i = 0; i < tilesToLoad; i++) {\r\n\t\t\tthis._addTile(queue[i], fragment);\r\n\t\t}\r\n\r\n\t\tthis._tileContainer.appendChild(fragment);\r\n\t},\r\n\r\n\t_tileShouldBeLoaded: function (tilePoint) {\r\n\t\tif ((tilePoint.x + ':' + tilePoint.y) in this._tiles) {\r\n\t\t\treturn false; // already loaded\r\n\t\t}\r\n\r\n\t\tvar options = this.options;\r\n\r\n\t\tif (!options.continuousWorld) {\r\n\t\t\tvar limit = this._getWrapTileNum();\r\n\r\n\t\t\t// don't load if exceeds world bounds\r\n\t\t\tif ((options.noWrap && (tilePoint.x < 0 || tilePoint.x >= limit.x)) ||\r\n\t\t\t\ttilePoint.y < 0 || tilePoint.y >= limit.y) { return false; }\r\n\t\t}\r\n\r\n\t\tif (options.bounds) {\r\n\t\t\tvar tileSize = this._getTileSize(),\r\n\t\t\t    nwPoint = tilePoint.multiplyBy(tileSize),\r\n\t\t\t    sePoint = nwPoint.add([tileSize, tileSize]),\r\n\t\t\t    nw = this._map.unproject(nwPoint),\r\n\t\t\t    se = this._map.unproject(sePoint);\r\n\r\n\t\t\t// TODO temporary hack, will be removed after refactoring projections\r\n\t\t\t// https://github.com/Leaflet/Leaflet/issues/1618\r\n\t\t\tif (!options.continuousWorld && !options.noWrap) {\r\n\t\t\t\tnw = nw.wrap();\r\n\t\t\t\tse = se.wrap();\r\n\t\t\t}\r\n\r\n\t\t\tif (!options.bounds.intersects([nw, se])) { return false; }\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t},\r\n\r\n\t_removeOtherTiles: function (bounds) {\r\n\t\tvar kArr, x, y, key;\r\n\r\n\t\tfor (key in this._tiles) {\r\n\t\t\tkArr = key.split(':');\r\n\t\t\tx = parseInt(kArr[0], 10);\r\n\t\t\ty = parseInt(kArr[1], 10);\r\n\r\n\t\t\t// remove tile if it's out of bounds\r\n\t\t\tif (x < bounds.min.x || x > bounds.max.x || y < bounds.min.y || y > bounds.max.y) {\r\n\t\t\t\tthis._removeTile(key);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_removeTile: function (key) {\r\n\t\tvar tile = this._tiles[key];\r\n\r\n\t\tthis.fire('tileunload', {tile: tile, url: tile.src});\r\n\r\n\t\tif (this.options.reuseTiles) {\r\n\t\t\tL.DomUtil.removeClass(tile, 'leaflet-tile-loaded');\r\n\t\t\tthis._unusedTiles.push(tile);\r\n\r\n\t\t} else if (tile.parentNode === this._tileContainer) {\r\n\t\t\tthis._tileContainer.removeChild(tile);\r\n\t\t}\r\n\r\n\t\t// for https://github.com/CloudMade/Leaflet/issues/137\r\n\t\tif (!L.Browser.android) {\r\n\t\t\ttile.onload = null;\r\n\t\t\ttile.src = L.Util.emptyImageUrl;\r\n\t\t}\r\n\r\n\t\tdelete this._tiles[key];\r\n\t},\r\n\r\n\t_addTile: function (tilePoint, container) {\r\n\t\tvar tilePos = this._getTilePos(tilePoint);\r\n\r\n\t\t// get unused tile - or create a new tile\r\n\t\tvar tile = this._getTile();\r\n\r\n\t\t/*\r\n\t\tChrome 20 layouts much faster with top/left (verify with timeline, frames)\r\n\t\tAndroid 4 browser has display issues with top/left and requires transform instead\r\n\t\t(other browsers don't currently care) - see debug/hacks/jitter.html for an example\r\n\t\t*/\r\n\t\tL.DomUtil.setPosition(tile, tilePos, L.Browser.chrome);\r\n\r\n\t\tthis._tiles[tilePoint.x + ':' + tilePoint.y] = tile;\r\n\r\n\t\tthis._loadTile(tile, tilePoint);\r\n\r\n\t\tif (tile.parentNode !== this._tileContainer) {\r\n\t\t\tcontainer.appendChild(tile);\r\n\t\t}\r\n\t},\r\n\r\n\t_getZoomForUrl: function () {\r\n\r\n\t\tvar options = this.options,\r\n\t\t    zoom = this._map.getZoom();\r\n\r\n\t\tif (options.zoomReverse) {\r\n\t\t\tzoom = options.maxZoom - zoom;\r\n\t\t}\r\n\r\n\t\tzoom += options.zoomOffset;\r\n\r\n\t\treturn options.maxNativeZoom ? Math.min(zoom, options.maxNativeZoom) : zoom;\r\n\t},\r\n\r\n\t_getTilePos: function (tilePoint) {\r\n\t\tvar origin = this._map.getPixelOrigin(),\r\n\t\t    tileSize = this._getTileSize();\r\n\r\n\t\treturn tilePoint.multiplyBy(tileSize).subtract(origin);\r\n\t},\r\n\r\n\t// image-specific code (override to implement e.g. Canvas or SVG tile layer)\r\n\r\n\tgetTileUrl: function (tilePoint) {\r\n\t\treturn L.Util.template(this._url, L.extend({\r\n\t\t\ts: this._getSubdomain(tilePoint),\r\n\t\t\tz: tilePoint.z,\r\n\t\t\tx: tilePoint.x,\r\n\t\t\ty: tilePoint.y\r\n\t\t}, this.options));\r\n\t},\r\n\r\n\t_getWrapTileNum: function () {\r\n\t\tvar crs = this._map.options.crs,\r\n\t\t    size = crs.getSize(this._map.getZoom());\r\n\t\treturn size.divideBy(this._getTileSize())._floor();\r\n\t},\r\n\r\n\t_adjustTilePoint: function (tilePoint) {\r\n\r\n\t\tvar limit = this._getWrapTileNum();\r\n\r\n\t\t// wrap tile coordinates\r\n\t\tif (!this.options.continuousWorld && !this.options.noWrap) {\r\n\t\t\ttilePoint.x = ((tilePoint.x % limit.x) + limit.x) % limit.x;\r\n\t\t}\r\n\r\n\t\tif (this.options.tms) {\r\n\t\t\ttilePoint.y = limit.y - tilePoint.y - 1;\r\n\t\t}\r\n\r\n\t\ttilePoint.z = this._getZoomForUrl();\r\n\t},\r\n\r\n\t_getSubdomain: function (tilePoint) {\r\n\t\tvar index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;\r\n\t\treturn this.options.subdomains[index];\r\n\t},\r\n\r\n\t_getTile: function () {\r\n\t\tif (this.options.reuseTiles && this._unusedTiles.length > 0) {\r\n\t\t\tvar tile = this._unusedTiles.pop();\r\n\t\t\tthis._resetTile(tile);\r\n\t\t\treturn tile;\r\n\t\t}\r\n\t\treturn this._createTile();\r\n\t},\r\n\r\n\t// Override if data stored on a tile needs to be cleaned up before reuse\r\n\t_resetTile: function (/*tile*/) {},\r\n\r\n\t_createTile: function () {\r\n\t\tvar tile = L.DomUtil.create('img', 'leaflet-tile');\r\n\t\ttile.style.width = tile.style.height = this._getTileSize() + 'px';\r\n\t\ttile.galleryimg = 'no';\r\n\r\n\t\ttile.onselectstart = tile.onmousemove = L.Util.falseFn;\r\n\r\n\t\tif (L.Browser.ielt9 && this.options.opacity !== undefined) {\r\n\t\t\tL.DomUtil.setOpacity(tile, this.options.opacity);\r\n\t\t}\r\n\t\t// without this hack, tiles disappear after zoom on Chrome for Android\r\n\t\t// https://github.com/Leaflet/Leaflet/issues/2078\r\n\t\tif (L.Browser.mobileWebkit3d) {\r\n\t\t\ttile.style.WebkitBackfaceVisibility = 'hidden';\r\n\t\t}\r\n\t\treturn tile;\r\n\t},\r\n\r\n\t_loadTile: function (tile, tilePoint) {\r\n\t\ttile._layer  = this;\r\n\t\ttile.onload  = this._tileOnLoad;\r\n\t\ttile.onerror = this._tileOnError;\r\n\r\n\t\tthis._adjustTilePoint(tilePoint);\r\n\t\ttile.src     = this.getTileUrl(tilePoint);\r\n\r\n\t\tthis.fire('tileloadstart', {\r\n\t\t\ttile: tile,\r\n\t\t\turl: tile.src\r\n\t\t});\r\n\t},\r\n\r\n\t_tileLoaded: function () {\r\n\t\tthis._tilesToLoad--;\r\n\r\n\t\tif (this._animated) {\r\n\t\t\tL.DomUtil.addClass(this._tileContainer, 'leaflet-zoom-animated');\r\n\t\t}\r\n\r\n\t\tif (!this._tilesToLoad) {\r\n\t\t\tthis.fire('load');\r\n\r\n\t\t\tif (this._animated) {\r\n\t\t\t\t// clear scaled tiles after all new tiles are loaded (for performance)\r\n\t\t\t\tclearTimeout(this._clearBgBufferTimer);\r\n\t\t\t\tthis._clearBgBufferTimer = setTimeout(L.bind(this._clearBgBuffer, this), 500);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_tileOnLoad: function () {\r\n\t\tvar layer = this._layer;\r\n\r\n\t\t//Only if we are loading an actual image\r\n\t\tif (this.src !== L.Util.emptyImageUrl) {\r\n\t\t\tL.DomUtil.addClass(this, 'leaflet-tile-loaded');\r\n\r\n\t\t\tlayer.fire('tileload', {\r\n\t\t\t\ttile: this,\r\n\t\t\t\turl: this.src\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tlayer._tileLoaded();\r\n\t},\r\n\r\n\t_tileOnError: function () {\r\n\t\tvar layer = this._layer;\r\n\r\n\t\tlayer.fire('tileerror', {\r\n\t\t\ttile: this,\r\n\t\t\turl: this.src\r\n\t\t});\r\n\r\n\t\tvar newUrl = layer.options.errorTileUrl;\r\n\t\tif (newUrl) {\r\n\t\t\tthis.src = newUrl;\r\n\t\t}\r\n\r\n\t\tlayer._tileLoaded();\r\n\t}\r\n});\r\n\r\nL.tileLayer = function (url, options) {\r\n\treturn new L.TileLayer(url, options);\r\n};\r\n\n\n/*\r\n * L.TileLayer.WMS is used for putting WMS tile layers on the map.\r\n */\r\n\r\nL.TileLayer.WMS = L.TileLayer.extend({\r\n\r\n\tdefaultWmsParams: {\r\n\t\tservice: 'WMS',\r\n\t\trequest: 'GetMap',\r\n\t\tversion: '1.1.1',\r\n\t\tlayers: '',\r\n\t\tstyles: '',\r\n\t\tformat: 'image/jpeg',\r\n\t\ttransparent: false\r\n\t},\r\n\r\n\tinitialize: function (url, options) { // (String, Object)\r\n\r\n\t\tthis._url = url;\r\n\r\n\t\tvar wmsParams = L.extend({}, this.defaultWmsParams),\r\n\t\t    tileSize = options.tileSize || this.options.tileSize;\r\n\r\n\t\tif (options.detectRetina && L.Browser.retina) {\r\n\t\t\twmsParams.width = wmsParams.height = tileSize * 2;\r\n\t\t} else {\r\n\t\t\twmsParams.width = wmsParams.height = tileSize;\r\n\t\t}\r\n\r\n\t\tfor (var i in options) {\r\n\t\t\t// all keys that are not TileLayer options go to WMS params\r\n\t\t\tif (!this.options.hasOwnProperty(i) && i !== 'crs') {\r\n\t\t\t\twmsParams[i] = options[i];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.wmsParams = wmsParams;\r\n\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\r\n\t\tthis._crs = this.options.crs || map.options.crs;\r\n\r\n\t\tthis._wmsVersion = parseFloat(this.wmsParams.version);\r\n\r\n\t\tvar projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';\r\n\t\tthis.wmsParams[projectionKey] = this._crs.code;\r\n\r\n\t\tL.TileLayer.prototype.onAdd.call(this, map);\r\n\t},\r\n\r\n\tgetTileUrl: function (tilePoint) { // (Point, Number) -> String\r\n\r\n\t\tvar map = this._map,\r\n\t\t    tileSize = this.options.tileSize,\r\n\r\n\t\t    nwPoint = tilePoint.multiplyBy(tileSize),\r\n\t\t    sePoint = nwPoint.add([tileSize, tileSize]),\r\n\r\n\t\t    nw = this._crs.project(map.unproject(nwPoint, tilePoint.z)),\r\n\t\t    se = this._crs.project(map.unproject(sePoint, tilePoint.z)),\r\n\t\t    bbox = this._wmsVersion >= 1.3 && this._crs === L.CRS.EPSG4326 ?\r\n\t\t        [se.y, nw.x, nw.y, se.x].join(',') :\r\n\t\t        [nw.x, se.y, se.x, nw.y].join(','),\r\n\r\n\t\t    url = L.Util.template(this._url, {s: this._getSubdomain(tilePoint)});\r\n\r\n\t\treturn url + L.Util.getParamString(this.wmsParams, url, true) + '&BBOX=' + bbox;\r\n\t},\r\n\r\n\tsetParams: function (params, noRedraw) {\r\n\r\n\t\tL.extend(this.wmsParams, params);\r\n\r\n\t\tif (!noRedraw) {\r\n\t\t\tthis.redraw();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n});\r\n\r\nL.tileLayer.wms = function (url, options) {\r\n\treturn new L.TileLayer.WMS(url, options);\r\n};\r\n\n\n/*\r\n * L.TileLayer.Canvas is a class that you can use as a base for creating\r\n * dynamically drawn Canvas-based tile layers.\r\n */\r\n\r\nL.TileLayer.Canvas = L.TileLayer.extend({\r\n\toptions: {\r\n\t\tasync: false\r\n\t},\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tredraw: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis._reset({hard: true});\r\n\t\t\tthis._update();\r\n\t\t}\r\n\r\n\t\tfor (var i in this._tiles) {\r\n\t\t\tthis._redrawTile(this._tiles[i]);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_redrawTile: function (tile) {\r\n\t\tthis.drawTile(tile, tile._tilePoint, this._map._zoom);\r\n\t},\r\n\r\n\t_createTile: function () {\r\n\t\tvar tile = L.DomUtil.create('canvas', 'leaflet-tile');\r\n\t\ttile.width = tile.height = this.options.tileSize;\r\n\t\ttile.onselectstart = tile.onmousemove = L.Util.falseFn;\r\n\t\treturn tile;\r\n\t},\r\n\r\n\t_loadTile: function (tile, tilePoint) {\r\n\t\ttile._layer = this;\r\n\t\ttile._tilePoint = tilePoint;\r\n\r\n\t\tthis._redrawTile(tile);\r\n\r\n\t\tif (!this.options.async) {\r\n\t\t\tthis.tileDrawn(tile);\r\n\t\t}\r\n\t},\r\n\r\n\tdrawTile: function (/*tile, tilePoint*/) {\r\n\t\t// override with rendering code\r\n\t},\r\n\r\n\ttileDrawn: function (tile) {\r\n\t\tthis._tileOnLoad.call(tile);\r\n\t}\r\n});\r\n\r\n\r\nL.tileLayer.canvas = function (options) {\r\n\treturn new L.TileLayer.Canvas(options);\r\n};\r\n\n\n/*\r\n * L.ImageOverlay is used to overlay images over the map (to specific geographical bounds).\r\n */\r\n\r\nL.ImageOverlay = L.Class.extend({\r\n\tincludes: L.Mixin.Events,\r\n\r\n\toptions: {\r\n\t\topacity: 1\r\n\t},\r\n\r\n\tinitialize: function (url, bounds, options) { // (String, LatLngBounds, Object)\r\n\t\tthis._url = url;\r\n\t\tthis._bounds = L.latLngBounds(bounds);\r\n\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\r\n\t\tif (!this._image) {\r\n\t\t\tthis._initImage();\r\n\t\t}\r\n\r\n\t\tmap._panes.overlayPane.appendChild(this._image);\r\n\r\n\t\tmap.on('viewreset', this._reset, this);\r\n\r\n\t\tif (map.options.zoomAnimation && L.Browser.any3d) {\r\n\t\t\tmap.on('zoomanim', this._animateZoom, this);\r\n\t\t}\r\n\r\n\t\tthis._reset();\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap.getPanes().overlayPane.removeChild(this._image);\r\n\r\n\t\tmap.off('viewreset', this._reset, this);\r\n\r\n\t\tif (map.options.zoomAnimation) {\r\n\t\t\tmap.off('zoomanim', this._animateZoom, this);\r\n\t\t}\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetOpacity: function (opacity) {\r\n\t\tthis.options.opacity = opacity;\r\n\t\tthis._updateOpacity();\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// TODO remove bringToFront/bringToBack duplication from TileLayer/Path\r\n\tbringToFront: function () {\r\n\t\tif (this._image) {\r\n\t\t\tthis._map._panes.overlayPane.appendChild(this._image);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tbringToBack: function () {\r\n\t\tvar pane = this._map._panes.overlayPane;\r\n\t\tif (this._image) {\r\n\t\t\tpane.insertBefore(this._image, pane.firstChild);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetUrl: function (url) {\r\n\t\tthis._url = url;\r\n\t\tthis._image.src = this._url;\r\n\t},\r\n\r\n\tgetAttribution: function () {\r\n\t\treturn this.options.attribution;\r\n\t},\r\n\r\n\t_initImage: function () {\r\n\t\tthis._image = L.DomUtil.create('img', 'leaflet-image-layer');\r\n\r\n\t\tif (this._map.options.zoomAnimation && L.Browser.any3d) {\r\n\t\t\tL.DomUtil.addClass(this._image, 'leaflet-zoom-animated');\r\n\t\t} else {\r\n\t\t\tL.DomUtil.addClass(this._image, 'leaflet-zoom-hide');\r\n\t\t}\r\n\r\n\t\tthis._updateOpacity();\r\n\r\n\t\t//TODO createImage util method to remove duplication\r\n\t\tL.extend(this._image, {\r\n\t\t\tgalleryimg: 'no',\r\n\t\t\tonselectstart: L.Util.falseFn,\r\n\t\t\tonmousemove: L.Util.falseFn,\r\n\t\t\tonload: L.bind(this._onImageLoad, this),\r\n\t\t\tsrc: this._url\r\n\t\t});\r\n\t},\r\n\r\n\t_animateZoom: function (e) {\r\n\t\tvar map = this._map,\r\n\t\t    image = this._image,\r\n\t\t    scale = map.getZoomScale(e.zoom),\r\n\t\t    nw = this._bounds.getNorthWest(),\r\n\t\t    se = this._bounds.getSouthEast(),\r\n\r\n\t\t    topLeft = map._latLngToNewLayerPoint(nw, e.zoom, e.center),\r\n\t\t    size = map._latLngToNewLayerPoint(se, e.zoom, e.center)._subtract(topLeft),\r\n\t\t    origin = topLeft._add(size._multiplyBy((1 / 2) * (1 - 1 / scale)));\r\n\r\n\t\timage.style[L.DomUtil.TRANSFORM] =\r\n\t\t        L.DomUtil.getTranslateString(origin) + ' scale(' + scale + ') ';\r\n\t},\r\n\r\n\t_reset: function () {\r\n\t\tvar image   = this._image,\r\n\t\t    topLeft = this._map.latLngToLayerPoint(this._bounds.getNorthWest()),\r\n\t\t    size = this._map.latLngToLayerPoint(this._bounds.getSouthEast())._subtract(topLeft);\r\n\r\n\t\tL.DomUtil.setPosition(image, topLeft);\r\n\r\n\t\timage.style.width  = size.x + 'px';\r\n\t\timage.style.height = size.y + 'px';\r\n\t},\r\n\r\n\t_onImageLoad: function () {\r\n\t\tthis.fire('load');\r\n\t},\r\n\r\n\t_updateOpacity: function () {\r\n\t\tL.DomUtil.setOpacity(this._image, this.options.opacity);\r\n\t}\r\n});\r\n\r\nL.imageOverlay = function (url, bounds, options) {\r\n\treturn new L.ImageOverlay(url, bounds, options);\r\n};\r\n\n\n/*\r\n * L.Icon is an image-based icon class that you can use with L.Marker for custom markers.\r\n */\r\n\r\nL.Icon = L.Class.extend({\r\n\toptions: {\r\n\t\t/*\r\n\t\ticonUrl: (String) (required)\r\n\t\ticonRetinaUrl: (String) (optional, used for retina devices if detected)\r\n\t\ticonSize: (Point) (can be set through CSS)\r\n\t\ticonAnchor: (Point) (centered by default, can be set in CSS with negative margins)\r\n\t\tpopupAnchor: (Point) (if not specified, popup opens in the anchor point)\r\n\t\tshadowUrl: (String) (no shadow by default)\r\n\t\tshadowRetinaUrl: (String) (optional, used for retina devices if detected)\r\n\t\tshadowSize: (Point)\r\n\t\tshadowAnchor: (Point)\r\n\t\t*/\r\n\t\tclassName: ''\r\n\t},\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tcreateIcon: function (oldIcon) {\r\n\t\treturn this._createIcon('icon', oldIcon);\r\n\t},\r\n\r\n\tcreateShadow: function (oldIcon) {\r\n\t\treturn this._createIcon('shadow', oldIcon);\r\n\t},\r\n\r\n\t_createIcon: function (name, oldIcon) {\r\n\t\tvar src = this._getIconUrl(name);\r\n\r\n\t\tif (!src) {\r\n\t\t\tif (name === 'icon') {\r\n\t\t\t\tthrow new Error('iconUrl not set in Icon options (see the docs).');\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tvar img;\r\n\t\tif (!oldIcon || oldIcon.tagName !== 'IMG') {\r\n\t\t\timg = this._createImg(src);\r\n\t\t} else {\r\n\t\t\timg = this._createImg(src, oldIcon);\r\n\t\t}\r\n\t\tthis._setIconStyles(img, name);\r\n\r\n\t\treturn img;\r\n\t},\r\n\r\n\t_setIconStyles: function (img, name) {\r\n\t\tvar options = this.options,\r\n\t\t    size = L.point(options[name + 'Size']),\r\n\t\t    anchor;\r\n\r\n\t\tif (name === 'shadow') {\r\n\t\t\tanchor = L.point(options.shadowAnchor || options.iconAnchor);\r\n\t\t} else {\r\n\t\t\tanchor = L.point(options.iconAnchor);\r\n\t\t}\r\n\r\n\t\tif (!anchor && size) {\r\n\t\t\tanchor = size.divideBy(2, true);\r\n\t\t}\r\n\r\n\t\timg.className = 'leaflet-marker-' + name + ' ' + options.className;\r\n\r\n\t\tif (anchor) {\r\n\t\t\timg.style.marginLeft = (-anchor.x) + 'px';\r\n\t\t\timg.style.marginTop  = (-anchor.y) + 'px';\r\n\t\t}\r\n\r\n\t\tif (size) {\r\n\t\t\timg.style.width  = size.x + 'px';\r\n\t\t\timg.style.height = size.y + 'px';\r\n\t\t}\r\n\t},\r\n\r\n\t_createImg: function (src, el) {\r\n\t\tel = el || document.createElement('img');\r\n\t\tel.src = src;\r\n\t\treturn el;\r\n\t},\r\n\r\n\t_getIconUrl: function (name) {\r\n\t\tif (L.Browser.retina && this.options[name + 'RetinaUrl']) {\r\n\t\t\treturn this.options[name + 'RetinaUrl'];\r\n\t\t}\r\n\t\treturn this.options[name + 'Url'];\r\n\t}\r\n});\r\n\r\nL.icon = function (options) {\r\n\treturn new L.Icon(options);\r\n};\r\n\n\n/*\n * L.Icon.Default is the blue marker icon used by default in Leaflet.\n */\n\nL.Icon.Default = L.Icon.extend({\n\n\toptions: {\n\t\ticonSize: [25, 41],\n\t\ticonAnchor: [12, 41],\n\t\tpopupAnchor: [1, -34],\n\n\t\tshadowSize: [41, 41]\n\t},\n\n\t_getIconUrl: function (name) {\n\t\tvar key = name + 'Url';\n\n\t\tif (this.options[key]) {\n\t\t\treturn this.options[key];\n\t\t}\n\n\t\tif (L.Browser.retina && name === 'icon') {\n\t\t\tname += '-2x';\n\t\t}\n\n\t\tvar path = L.Icon.Default.imagePath;\n\n\t\tif (!path) {\n\t\t\tthrow new Error('Couldn\\'t autodetect L.Icon.Default.imagePath, set it manually.');\n\t\t}\n\n\t\treturn path + '/marker-' + name + '.png';\n\t}\n});\n\nL.Icon.Default.imagePath = (function () {\n\tvar scripts = document.getElementsByTagName('script'),\n\t    leafletRe = /[\\/^]leaflet[\\-\\._]?([\\w\\-\\._]*)\\.js\\??/;\n\n\tvar i, len, src, matches, path;\n\n\tfor (i = 0, len = scripts.length; i < len; i++) {\n\t\tsrc = scripts[i].src;\n\t\tmatches = src.match(leafletRe);\n\n\t\tif (matches) {\n\t\t\tpath = src.split(leafletRe)[0];\n\t\t\treturn (path ? path + '/' : '') + 'images';\n\t\t}\n\t}\n}());\n\n\n/*\r\n * L.Marker is used to display clickable/draggable icons on the map.\r\n */\r\n\r\nL.Marker = L.Class.extend({\r\n\r\n\tincludes: L.Mixin.Events,\r\n\r\n\toptions: {\r\n\t\ticon: new L.Icon.Default(),\r\n\t\ttitle: '',\r\n\t\talt: '',\r\n\t\tclickable: true,\r\n\t\tdraggable: false,\r\n\t\tkeyboard: true,\r\n\t\tzIndexOffset: 0,\r\n\t\topacity: 1,\r\n\t\triseOnHover: false,\r\n\t\triseOffset: 250\r\n\t},\r\n\r\n\tinitialize: function (latlng, options) {\r\n\t\tL.setOptions(this, options);\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\r\n\t\tmap.on('viewreset', this.update, this);\r\n\r\n\t\tthis._initIcon();\r\n\t\tthis.update();\r\n\t\tthis.fire('add');\r\n\r\n\t\tif (map.options.zoomAnimation && map.options.markerZoomAnimation) {\r\n\t\t\tmap.on('zoomanim', this._animateZoom, this);\r\n\t\t}\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tif (this.dragging) {\r\n\t\t\tthis.dragging.disable();\r\n\t\t}\r\n\r\n\t\tthis._removeIcon();\r\n\t\tthis._removeShadow();\r\n\r\n\t\tthis.fire('remove');\r\n\r\n\t\tmap.off({\r\n\t\t\t'viewreset': this.update,\r\n\t\t\t'zoomanim': this._animateZoom\r\n\t\t}, this);\r\n\r\n\t\tthis._map = null;\r\n\t},\r\n\r\n\tgetLatLng: function () {\r\n\t\treturn this._latlng;\r\n\t},\r\n\r\n\tsetLatLng: function (latlng) {\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\r\n\t\tthis.update();\r\n\r\n\t\treturn this.fire('move', { latlng: this._latlng });\r\n\t},\r\n\r\n\tsetZIndexOffset: function (offset) {\r\n\t\tthis.options.zIndexOffset = offset;\r\n\t\tthis.update();\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetIcon: function (icon) {\r\n\r\n\t\tthis.options.icon = icon;\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._initIcon();\r\n\t\t\tthis.update();\r\n\t\t}\r\n\r\n\t\tif (this._popup) {\r\n\t\t\tthis.bindPopup(this._popup);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tupdate: function () {\r\n\t\tif (this._icon) {\r\n\t\t\tthis._setPos(this._map.latLngToLayerPoint(this._latlng).round());\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_initIcon: function () {\r\n\t\tvar options = this.options,\r\n\t\t    map = this._map,\r\n\t\t    animation = (map.options.zoomAnimation && map.options.markerZoomAnimation),\r\n\t\t    classToAdd = animation ? 'leaflet-zoom-animated' : 'leaflet-zoom-hide';\r\n\r\n\t\tvar icon = options.icon.createIcon(this._icon),\r\n\t\t\taddIcon = false;\r\n\r\n\t\t// if we're not reusing the icon, remove the old one and init new one\r\n\t\tif (icon !== this._icon) {\r\n\t\t\tif (this._icon) {\r\n\t\t\t\tthis._removeIcon();\r\n\t\t\t}\r\n\t\t\taddIcon = true;\r\n\r\n\t\t\tif (options.title) {\r\n\t\t\t\ticon.title = options.title;\r\n\t\t\t}\r\n\r\n\t\t\tif (options.alt) {\r\n\t\t\t\ticon.alt = options.alt;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tL.DomUtil.addClass(icon, classToAdd);\r\n\r\n\t\tif (options.keyboard) {\r\n\t\t\ticon.tabIndex = '0';\r\n\t\t}\r\n\r\n\t\tthis._icon = icon;\r\n\r\n\t\tthis._initInteraction();\r\n\r\n\t\tif (options.riseOnHover) {\r\n\t\t\tL.DomEvent\r\n\t\t\t\t.on(icon, 'mouseover', this._bringToFront, this)\r\n\t\t\t\t.on(icon, 'mouseout', this._resetZIndex, this);\r\n\t\t}\r\n\r\n\t\tvar newShadow = options.icon.createShadow(this._shadow),\r\n\t\t\taddShadow = false;\r\n\r\n\t\tif (newShadow !== this._shadow) {\r\n\t\t\tthis._removeShadow();\r\n\t\t\taddShadow = true;\r\n\t\t}\r\n\r\n\t\tif (newShadow) {\r\n\t\t\tL.DomUtil.addClass(newShadow, classToAdd);\r\n\t\t}\r\n\t\tthis._shadow = newShadow;\r\n\r\n\r\n\t\tif (options.opacity < 1) {\r\n\t\t\tthis._updateOpacity();\r\n\t\t}\r\n\r\n\r\n\t\tvar panes = this._map._panes;\r\n\r\n\t\tif (addIcon) {\r\n\t\t\tpanes.markerPane.appendChild(this._icon);\r\n\t\t}\r\n\r\n\t\tif (newShadow && addShadow) {\r\n\t\t\tpanes.shadowPane.appendChild(this._shadow);\r\n\t\t}\r\n\t},\r\n\r\n\t_removeIcon: function () {\r\n\t\tif (this.options.riseOnHover) {\r\n\t\t\tL.DomEvent\r\n\t\t\t    .off(this._icon, 'mouseover', this._bringToFront)\r\n\t\t\t    .off(this._icon, 'mouseout', this._resetZIndex);\r\n\t\t}\r\n\r\n\t\tthis._map._panes.markerPane.removeChild(this._icon);\r\n\r\n\t\tthis._icon = null;\r\n\t},\r\n\r\n\t_removeShadow: function () {\r\n\t\tif (this._shadow) {\r\n\t\t\tthis._map._panes.shadowPane.removeChild(this._shadow);\r\n\t\t}\r\n\t\tthis._shadow = null;\r\n\t},\r\n\r\n\t_setPos: function (pos) {\r\n\t\tL.DomUtil.setPosition(this._icon, pos);\r\n\r\n\t\tif (this._shadow) {\r\n\t\t\tL.DomUtil.setPosition(this._shadow, pos);\r\n\t\t}\r\n\r\n\t\tthis._zIndex = pos.y + this.options.zIndexOffset;\r\n\r\n\t\tthis._resetZIndex();\r\n\t},\r\n\r\n\t_updateZIndex: function (offset) {\r\n\t\tthis._icon.style.zIndex = this._zIndex + offset;\r\n\t},\r\n\r\n\t_animateZoom: function (opt) {\r\n\t\tvar pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();\r\n\r\n\t\tthis._setPos(pos);\r\n\t},\r\n\r\n\t_initInteraction: function () {\r\n\r\n\t\tif (!this.options.clickable) { return; }\r\n\r\n\t\t// TODO refactor into something shared with Map/Path/etc. to DRY it up\r\n\r\n\t\tvar icon = this._icon,\r\n\t\t    events = ['dblclick', 'mousedown', 'mouseover', 'mouseout', 'contextmenu'];\r\n\r\n\t\tL.DomUtil.addClass(icon, 'leaflet-clickable');\r\n\t\tL.DomEvent.on(icon, 'click', this._onMouseClick, this);\r\n\t\tL.DomEvent.on(icon, 'keypress', this._onKeyPress, this);\r\n\r\n\t\tfor (var i = 0; i < events.length; i++) {\r\n\t\t\tL.DomEvent.on(icon, events[i], this._fireMouseEvent, this);\r\n\t\t}\r\n\r\n\t\tif (L.Handler.MarkerDrag) {\r\n\t\t\tthis.dragging = new L.Handler.MarkerDrag(this);\r\n\r\n\t\t\tif (this.options.draggable) {\r\n\t\t\t\tthis.dragging.enable();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_onMouseClick: function (e) {\r\n\t\tvar wasDragged = this.dragging && this.dragging.moved();\r\n\r\n\t\tif (this.hasEventListeners(e.type) || wasDragged) {\r\n\t\t\tL.DomEvent.stopPropagation(e);\r\n\t\t}\r\n\r\n\t\tif (wasDragged) { return; }\r\n\r\n\t\tif ((!this.dragging || !this.dragging._enabled) && this._map.dragging && this._map.dragging.moved()) { return; }\r\n\r\n\t\tthis.fire(e.type, {\r\n\t\t\toriginalEvent: e,\r\n\t\t\tlatlng: this._latlng\r\n\t\t});\r\n\t},\r\n\r\n\t_onKeyPress: function (e) {\r\n\t\tif (e.keyCode === 13) {\r\n\t\t\tthis.fire('click', {\r\n\t\t\t\toriginalEvent: e,\r\n\t\t\t\tlatlng: this._latlng\r\n\t\t\t});\r\n\t\t}\r\n\t},\r\n\r\n\t_fireMouseEvent: function (e) {\r\n\r\n\t\tthis.fire(e.type, {\r\n\t\t\toriginalEvent: e,\r\n\t\t\tlatlng: this._latlng\r\n\t\t});\r\n\r\n\t\t// TODO proper custom event propagation\r\n\t\t// this line will always be called if marker is in a FeatureGroup\r\n\t\tif (e.type === 'contextmenu' && this.hasEventListeners(e.type)) {\r\n\t\t\tL.DomEvent.preventDefault(e);\r\n\t\t}\r\n\t\tif (e.type !== 'mousedown') {\r\n\t\t\tL.DomEvent.stopPropagation(e);\r\n\t\t} else {\r\n\t\t\tL.DomEvent.preventDefault(e);\r\n\t\t}\r\n\t},\r\n\r\n\tsetOpacity: function (opacity) {\r\n\t\tthis.options.opacity = opacity;\r\n\t\tif (this._map) {\r\n\t\t\tthis._updateOpacity();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_updateOpacity: function () {\r\n\t\tL.DomUtil.setOpacity(this._icon, this.options.opacity);\r\n\t\tif (this._shadow) {\r\n\t\t\tL.DomUtil.setOpacity(this._shadow, this.options.opacity);\r\n\t\t}\r\n\t},\r\n\r\n\t_bringToFront: function () {\r\n\t\tthis._updateZIndex(this.options.riseOffset);\r\n\t},\r\n\r\n\t_resetZIndex: function () {\r\n\t\tthis._updateZIndex(0);\r\n\t}\r\n});\r\n\r\nL.marker = function (latlng, options) {\r\n\treturn new L.Marker(latlng, options);\r\n};\r\n\n\n/*\n * L.DivIcon is a lightweight HTML-based icon class (as opposed to the image-based L.Icon)\n * to use with L.Marker.\n */\n\nL.DivIcon = L.Icon.extend({\n\toptions: {\n\t\ticonSize: [12, 12], // also can be set through CSS\n\t\t/*\n\t\ticonAnchor: (Point)\n\t\tpopupAnchor: (Point)\n\t\thtml: (String)\n\t\tbgPos: (Point)\n\t\t*/\n\t\tclassName: 'leaflet-div-icon',\n\t\thtml: false\n\t},\n\n\tcreateIcon: function (oldIcon) {\n\t\tvar div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),\n\t\t    options = this.options;\n\n\t\tif (options.html !== false) {\n\t\t\tdiv.innerHTML = options.html;\n\t\t} else {\n\t\t\tdiv.innerHTML = '';\n\t\t}\n\n\t\tif (options.bgPos) {\n\t\t\tdiv.style.backgroundPosition =\n\t\t\t        (-options.bgPos.x) + 'px ' + (-options.bgPos.y) + 'px';\n\t\t}\n\n\t\tthis._setIconStyles(div, 'icon');\n\t\treturn div;\n\t},\n\n\tcreateShadow: function () {\n\t\treturn null;\n\t}\n});\n\nL.divIcon = function (options) {\n\treturn new L.DivIcon(options);\n};\n\n\n/*\r\n * L.Popup is used for displaying popups on the map.\r\n */\r\n\r\nL.Map.mergeOptions({\r\n\tclosePopupOnClick: true\r\n});\r\n\r\nL.Popup = L.Class.extend({\r\n\tincludes: L.Mixin.Events,\r\n\r\n\toptions: {\r\n\t\tminWidth: 50,\r\n\t\tmaxWidth: 300,\r\n\t\t// maxHeight: null,\r\n\t\tautoPan: true,\r\n\t\tcloseButton: true,\r\n\t\toffset: [0, 7],\r\n\t\tautoPanPadding: [5, 5],\r\n\t\t// autoPanPaddingTopLeft: null,\r\n\t\t// autoPanPaddingBottomRight: null,\r\n\t\tkeepInView: false,\r\n\t\tclassName: '',\r\n\t\tzoomAnimation: true\r\n\t},\r\n\r\n\tinitialize: function (options, source) {\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tthis._source = source;\r\n\t\tthis._animated = L.Browser.any3d && this.options.zoomAnimation;\r\n\t\tthis._isOpen = false;\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\r\n\t\tif (!this._container) {\r\n\t\t\tthis._initLayout();\r\n\t\t}\r\n\r\n\t\tvar animFade = map.options.fadeAnimation;\r\n\r\n\t\tif (animFade) {\r\n\t\t\tL.DomUtil.setOpacity(this._container, 0);\r\n\t\t}\r\n\t\tmap._panes.popupPane.appendChild(this._container);\r\n\r\n\t\tmap.on(this._getEvents(), this);\r\n\r\n\t\tthis.update();\r\n\r\n\t\tif (animFade) {\r\n\t\t\tL.DomUtil.setOpacity(this._container, 1);\r\n\t\t}\r\n\r\n\t\tthis.fire('open');\r\n\r\n\t\tmap.fire('popupopen', {popup: this});\r\n\r\n\t\tif (this._source) {\r\n\t\t\tthis._source.fire('popupopen', {popup: this});\r\n\t\t}\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\topenOn: function (map) {\r\n\t\tmap.openPopup(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap._panes.popupPane.removeChild(this._container);\r\n\r\n\t\tL.Util.falseFn(this._container.offsetWidth); // force reflow\r\n\r\n\t\tmap.off(this._getEvents(), this);\r\n\r\n\t\tif (map.options.fadeAnimation) {\r\n\t\t\tL.DomUtil.setOpacity(this._container, 0);\r\n\t\t}\r\n\r\n\t\tthis._map = null;\r\n\r\n\t\tthis.fire('close');\r\n\r\n\t\tmap.fire('popupclose', {popup: this});\r\n\r\n\t\tif (this._source) {\r\n\t\t\tthis._source.fire('popupclose', {popup: this});\r\n\t\t}\r\n\t},\r\n\r\n\tgetLatLng: function () {\r\n\t\treturn this._latlng;\r\n\t},\r\n\r\n\tsetLatLng: function (latlng) {\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\t\tif (this._map) {\r\n\t\t\tthis._updatePosition();\r\n\t\t\tthis._adjustPan();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetContent: function () {\r\n\t\treturn this._content;\r\n\t},\r\n\r\n\tsetContent: function (content) {\r\n\t\tthis._content = content;\r\n\t\tthis.update();\r\n\t\treturn this;\r\n\t},\r\n\r\n\tupdate: function () {\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tthis._container.style.visibility = 'hidden';\r\n\r\n\t\tthis._updateContent();\r\n\t\tthis._updateLayout();\r\n\t\tthis._updatePosition();\r\n\r\n\t\tthis._container.style.visibility = '';\r\n\r\n\t\tthis._adjustPan();\r\n\t},\r\n\r\n\t_getEvents: function () {\r\n\t\tvar events = {\r\n\t\t\tviewreset: this._updatePosition\r\n\t\t};\r\n\r\n\t\tif (this._animated) {\r\n\t\t\tevents.zoomanim = this._zoomAnimation;\r\n\t\t}\r\n\t\tif ('closeOnClick' in this.options ? this.options.closeOnClick : this._map.options.closePopupOnClick) {\r\n\t\t\tevents.preclick = this._close;\r\n\t\t}\r\n\t\tif (this.options.keepInView) {\r\n\t\t\tevents.moveend = this._adjustPan;\r\n\t\t}\r\n\r\n\t\treturn events;\r\n\t},\r\n\r\n\t_close: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis._map.closePopup(this);\r\n\t\t}\r\n\t},\r\n\r\n\t_initLayout: function () {\r\n\t\tvar prefix = 'leaflet-popup',\r\n\t\t\tcontainerClass = prefix + ' ' + this.options.className + ' leaflet-zoom-' +\r\n\t\t\t        (this._animated ? 'animated' : 'hide'),\r\n\t\t\tcontainer = this._container = L.DomUtil.create('div', containerClass),\r\n\t\t\tcloseButton;\r\n\r\n\t\tif (this.options.closeButton) {\r\n\t\t\tcloseButton = this._closeButton =\r\n\t\t\t        L.DomUtil.create('a', prefix + '-close-button', container);\r\n\t\t\tcloseButton.href = '#close';\r\n\t\t\tcloseButton.innerHTML = '&#215;';\r\n\t\t\tL.DomEvent.disableClickPropagation(closeButton);\r\n\r\n\t\t\tL.DomEvent.on(closeButton, 'click', this._onCloseButtonClick, this);\r\n\t\t}\r\n\r\n\t\tvar wrapper = this._wrapper =\r\n\t\t        L.DomUtil.create('div', prefix + '-content-wrapper', container);\r\n\t\tL.DomEvent.disableClickPropagation(wrapper);\r\n\r\n\t\tthis._contentNode = L.DomUtil.create('div', prefix + '-content', wrapper);\r\n\r\n\t\tL.DomEvent.disableScrollPropagation(this._contentNode);\r\n\t\tL.DomEvent.on(wrapper, 'contextmenu', L.DomEvent.stopPropagation);\r\n\r\n\t\tthis._tipContainer = L.DomUtil.create('div', prefix + '-tip-container', container);\r\n\t\tthis._tip = L.DomUtil.create('div', prefix + '-tip', this._tipContainer);\r\n\t},\r\n\r\n\t_updateContent: function () {\r\n\t\tif (!this._content) { return; }\r\n\r\n\t\tif (typeof this._content === 'string') {\r\n\t\t\tthis._contentNode.innerHTML = this._content;\r\n\t\t} else {\r\n\t\t\twhile (this._contentNode.hasChildNodes()) {\r\n\t\t\t\tthis._contentNode.removeChild(this._contentNode.firstChild);\r\n\t\t\t}\r\n\t\t\tthis._contentNode.appendChild(this._content);\r\n\t\t}\r\n\t\tthis.fire('contentupdate');\r\n\t},\r\n\r\n\t_updateLayout: function () {\r\n\t\tvar container = this._contentNode,\r\n\t\t    style = container.style;\r\n\r\n\t\tstyle.width = '';\r\n\t\tstyle.whiteSpace = 'nowrap';\r\n\r\n\t\tvar width = container.offsetWidth;\r\n\t\twidth = Math.min(width, this.options.maxWidth);\r\n\t\twidth = Math.max(width, this.options.minWidth);\r\n\r\n\t\tstyle.width = (width + 1) + 'px';\r\n\t\tstyle.whiteSpace = '';\r\n\r\n\t\tstyle.height = '';\r\n\r\n\t\tvar height = container.offsetHeight,\r\n\t\t    maxHeight = this.options.maxHeight,\r\n\t\t    scrolledClass = 'leaflet-popup-scrolled';\r\n\r\n\t\tif (maxHeight && height > maxHeight) {\r\n\t\t\tstyle.height = maxHeight + 'px';\r\n\t\t\tL.DomUtil.addClass(container, scrolledClass);\r\n\t\t} else {\r\n\t\t\tL.DomUtil.removeClass(container, scrolledClass);\r\n\t\t}\r\n\r\n\t\tthis._containerWidth = this._container.offsetWidth;\r\n\t},\r\n\r\n\t_updatePosition: function () {\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tvar pos = this._map.latLngToLayerPoint(this._latlng),\r\n\t\t    animated = this._animated,\r\n\t\t    offset = L.point(this.options.offset);\r\n\r\n\t\tif (animated) {\r\n\t\t\tL.DomUtil.setPosition(this._container, pos);\r\n\t\t}\r\n\r\n\t\tthis._containerBottom = -offset.y - (animated ? 0 : pos.y);\r\n\t\tthis._containerLeft = -Math.round(this._containerWidth / 2) + offset.x + (animated ? 0 : pos.x);\r\n\r\n\t\t// bottom position the popup in case the height of the popup changes (images loading etc)\r\n\t\tthis._container.style.bottom = this._containerBottom + 'px';\r\n\t\tthis._container.style.left = this._containerLeft + 'px';\r\n\t},\r\n\r\n\t_zoomAnimation: function (opt) {\r\n\t\tvar pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center);\r\n\r\n\t\tL.DomUtil.setPosition(this._container, pos);\r\n\t},\r\n\r\n\t_adjustPan: function () {\r\n\t\tif (!this.options.autoPan) { return; }\r\n\r\n\t\tvar map = this._map,\r\n\t\t    containerHeight = this._container.offsetHeight,\r\n\t\t    containerWidth = this._containerWidth,\r\n\r\n\t\t    layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);\r\n\r\n\t\tif (this._animated) {\r\n\t\t\tlayerPos._add(L.DomUtil.getPosition(this._container));\r\n\t\t}\r\n\r\n\t\tvar containerPos = map.layerPointToContainerPoint(layerPos),\r\n\t\t    padding = L.point(this.options.autoPanPadding),\r\n\t\t    paddingTL = L.point(this.options.autoPanPaddingTopLeft || padding),\r\n\t\t    paddingBR = L.point(this.options.autoPanPaddingBottomRight || padding),\r\n\t\t    size = map.getSize(),\r\n\t\t    dx = 0,\r\n\t\t    dy = 0;\r\n\r\n\t\tif (containerPos.x + containerWidth + paddingBR.x > size.x) { // right\r\n\t\t\tdx = containerPos.x + containerWidth - size.x + paddingBR.x;\r\n\t\t}\r\n\t\tif (containerPos.x - dx - paddingTL.x < 0) { // left\r\n\t\t\tdx = containerPos.x - paddingTL.x;\r\n\t\t}\r\n\t\tif (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom\r\n\t\t\tdy = containerPos.y + containerHeight - size.y + paddingBR.y;\r\n\t\t}\r\n\t\tif (containerPos.y - dy - paddingTL.y < 0) { // top\r\n\t\t\tdy = containerPos.y - paddingTL.y;\r\n\t\t}\r\n\r\n\t\tif (dx || dy) {\r\n\t\t\tmap\r\n\t\t\t    .fire('autopanstart')\r\n\t\t\t    .panBy([dx, dy]);\r\n\t\t}\r\n\t},\r\n\r\n\t_onCloseButtonClick: function (e) {\r\n\t\tthis._close();\r\n\t\tL.DomEvent.stop(e);\r\n\t}\r\n});\r\n\r\nL.popup = function (options, source) {\r\n\treturn new L.Popup(options, source);\r\n};\r\n\r\n\r\nL.Map.include({\r\n\topenPopup: function (popup, latlng, options) { // (Popup) or (String || HTMLElement, LatLng[, Object])\r\n\t\tthis.closePopup();\r\n\r\n\t\tif (!(popup instanceof L.Popup)) {\r\n\t\t\tvar content = popup;\r\n\r\n\t\t\tpopup = new L.Popup(options)\r\n\t\t\t    .setLatLng(latlng)\r\n\t\t\t    .setContent(content);\r\n\t\t}\r\n\t\tpopup._isOpen = true;\r\n\r\n\t\tthis._popup = popup;\r\n\t\treturn this.addLayer(popup);\r\n\t},\r\n\r\n\tclosePopup: function (popup) {\r\n\t\tif (!popup || popup === this._popup) {\r\n\t\t\tpopup = this._popup;\r\n\t\t\tthis._popup = null;\r\n\t\t}\r\n\t\tif (popup) {\r\n\t\t\tthis.removeLayer(popup);\r\n\t\t\tpopup._isOpen = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n});\r\n\n\n/*\r\n * Popup extension to L.Marker, adding popup-related methods.\r\n */\r\n\r\nL.Marker.include({\r\n\topenPopup: function () {\r\n\t\tif (this._popup && this._map && !this._map.hasLayer(this._popup)) {\r\n\t\t\tthis._popup.setLatLng(this._latlng);\r\n\t\t\tthis._map.openPopup(this._popup);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tclosePopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup._close();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\ttogglePopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tif (this._popup._isOpen) {\r\n\t\t\t\tthis.closePopup();\r\n\t\t\t} else {\r\n\t\t\t\tthis.openPopup();\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tbindPopup: function (content, options) {\r\n\t\tvar anchor = L.point(this.options.icon.options.popupAnchor || [0, 0]);\r\n\r\n\t\tanchor = anchor.add(L.Popup.prototype.options.offset);\r\n\r\n\t\tif (options && options.offset) {\r\n\t\t\tanchor = anchor.add(options.offset);\r\n\t\t}\r\n\r\n\t\toptions = L.extend({offset: anchor}, options);\r\n\r\n\t\tif (!this._popupHandlersAdded) {\r\n\t\t\tthis\r\n\t\t\t    .on('click', this.togglePopup, this)\r\n\t\t\t    .on('remove', this.closePopup, this)\r\n\t\t\t    .on('move', this._movePopup, this);\r\n\t\t\tthis._popupHandlersAdded = true;\r\n\t\t}\r\n\r\n\t\tif (content instanceof L.Popup) {\r\n\t\t\tL.setOptions(content, options);\r\n\t\t\tthis._popup = content;\r\n\t\t\tcontent._source = this;\r\n\t\t} else {\r\n\t\t\tthis._popup = new L.Popup(options, this)\r\n\t\t\t\t.setContent(content);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetPopupContent: function (content) {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup.setContent(content);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tunbindPopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup = null;\r\n\t\t\tthis\r\n\t\t\t    .off('click', this.togglePopup, this)\r\n\t\t\t    .off('remove', this.closePopup, this)\r\n\t\t\t    .off('move', this._movePopup, this);\r\n\t\t\tthis._popupHandlersAdded = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetPopup: function () {\r\n\t\treturn this._popup;\r\n\t},\r\n\r\n\t_movePopup: function (e) {\r\n\t\tthis._popup.setLatLng(e.latlng);\r\n\t}\r\n});\r\n\n\n/*\r\n * L.LayerGroup is a class to combine several layers into one so that\r\n * you can manipulate the group (e.g. add/remove it) as one layer.\r\n */\r\n\r\nL.LayerGroup = L.Class.extend({\r\n\tinitialize: function (layers) {\r\n\t\tthis._layers = {};\r\n\r\n\t\tvar i, len;\r\n\r\n\t\tif (layers) {\r\n\t\t\tfor (i = 0, len = layers.length; i < len; i++) {\r\n\t\t\t\tthis.addLayer(layers[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\taddLayer: function (layer) {\r\n\t\tvar id = this.getLayerId(layer);\r\n\r\n\t\tthis._layers[id] = layer;\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._map.addLayer(layer);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveLayer: function (layer) {\r\n\t\tvar id = layer in this._layers ? layer : this.getLayerId(layer);\r\n\r\n\t\tif (this._map && this._layers[id]) {\r\n\t\t\tthis._map.removeLayer(this._layers[id]);\r\n\t\t}\r\n\r\n\t\tdelete this._layers[id];\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\thasLayer: function (layer) {\r\n\t\tif (!layer) { return false; }\r\n\r\n\t\treturn (layer in this._layers || this.getLayerId(layer) in this._layers);\r\n\t},\r\n\r\n\tclearLayers: function () {\r\n\t\tthis.eachLayer(this.removeLayer, this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tinvoke: function (methodName) {\r\n\t\tvar args = Array.prototype.slice.call(arguments, 1),\r\n\t\t    i, layer;\r\n\r\n\t\tfor (i in this._layers) {\r\n\t\t\tlayer = this._layers[i];\r\n\r\n\t\t\tif (layer[methodName]) {\r\n\t\t\t\tlayer[methodName].apply(layer, args);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\t\tthis.eachLayer(map.addLayer, map);\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tthis.eachLayer(map.removeLayer, map);\r\n\t\tthis._map = null;\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\teachLayer: function (method, context) {\r\n\t\tfor (var i in this._layers) {\r\n\t\t\tmethod.call(context, this._layers[i]);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetLayer: function (id) {\r\n\t\treturn this._layers[id];\r\n\t},\r\n\r\n\tgetLayers: function () {\r\n\t\tvar layers = [];\r\n\r\n\t\tfor (var i in this._layers) {\r\n\t\t\tlayers.push(this._layers[i]);\r\n\t\t}\r\n\t\treturn layers;\r\n\t},\r\n\r\n\tsetZIndex: function (zIndex) {\r\n\t\treturn this.invoke('setZIndex', zIndex);\r\n\t},\r\n\r\n\tgetLayerId: function (layer) {\r\n\t\treturn L.stamp(layer);\r\n\t}\r\n});\r\n\r\nL.layerGroup = function (layers) {\r\n\treturn new L.LayerGroup(layers);\r\n};\r\n\n\n/*\r\n * L.FeatureGroup extends L.LayerGroup by introducing mouse events and additional methods\r\n * shared between a group of interactive layers (like vectors or markers).\r\n */\r\n\r\nL.FeatureGroup = L.LayerGroup.extend({\r\n\tincludes: L.Mixin.Events,\r\n\r\n\tstatics: {\r\n\t\tEVENTS: 'click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose'\r\n\t},\r\n\r\n\taddLayer: function (layer) {\r\n\t\tif (this.hasLayer(layer)) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tif ('on' in layer) {\r\n\t\t\tlayer.on(L.FeatureGroup.EVENTS, this._propagateEvent, this);\r\n\t\t}\r\n\r\n\t\tL.LayerGroup.prototype.addLayer.call(this, layer);\r\n\r\n\t\tif (this._popupContent && layer.bindPopup) {\r\n\t\t\tlayer.bindPopup(this._popupContent, this._popupOptions);\r\n\t\t}\r\n\r\n\t\treturn this.fire('layeradd', {layer: layer});\r\n\t},\r\n\r\n\tremoveLayer: function (layer) {\r\n\t\tif (!this.hasLayer(layer)) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\t\tif (layer in this._layers) {\r\n\t\t\tlayer = this._layers[layer];\r\n\t\t}\r\n\r\n\t\tif ('off' in layer) {\r\n\t\t\tlayer.off(L.FeatureGroup.EVENTS, this._propagateEvent, this);\r\n\t\t}\r\n\r\n\t\tL.LayerGroup.prototype.removeLayer.call(this, layer);\r\n\r\n\t\tif (this._popupContent) {\r\n\t\t\tthis.invoke('unbindPopup');\r\n\t\t}\r\n\r\n\t\treturn this.fire('layerremove', {layer: layer});\r\n\t},\r\n\r\n\tbindPopup: function (content, options) {\r\n\t\tthis._popupContent = content;\r\n\t\tthis._popupOptions = options;\r\n\t\treturn this.invoke('bindPopup', content, options);\r\n\t},\r\n\r\n\topenPopup: function (latlng) {\r\n\t\t// open popup on the first layer\r\n\t\tfor (var id in this._layers) {\r\n\t\t\tthis._layers[id].openPopup(latlng);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetStyle: function (style) {\r\n\t\treturn this.invoke('setStyle', style);\r\n\t},\r\n\r\n\tbringToFront: function () {\r\n\t\treturn this.invoke('bringToFront');\r\n\t},\r\n\r\n\tbringToBack: function () {\r\n\t\treturn this.invoke('bringToBack');\r\n\t},\r\n\r\n\tgetBounds: function () {\r\n\t\tvar bounds = new L.LatLngBounds();\r\n\r\n\t\tthis.eachLayer(function (layer) {\r\n\t\t\tbounds.extend(layer instanceof L.Marker ? layer.getLatLng() : layer.getBounds());\r\n\t\t});\r\n\r\n\t\treturn bounds;\r\n\t},\r\n\r\n\t_propagateEvent: function (e) {\r\n\t\te = L.extend({\r\n\t\t\tlayer: e.target,\r\n\t\t\ttarget: this\r\n\t\t}, e);\r\n\t\tthis.fire(e.type, e);\r\n\t}\r\n});\r\n\r\nL.featureGroup = function (layers) {\r\n\treturn new L.FeatureGroup(layers);\r\n};\r\n\n\n/*\r\n * L.Path is a base class for rendering vector paths on a map. Inherited by Polyline, Circle, etc.\r\n */\r\n\r\nL.Path = L.Class.extend({\r\n\tincludes: [L.Mixin.Events],\r\n\r\n\tstatics: {\r\n\t\t// how much to extend the clip area around the map view\r\n\t\t// (relative to its size, e.g. 0.5 is half the screen in each direction)\r\n\t\t// set it so that SVG element doesn't exceed 1280px (vectors flicker on dragend if it is)\r\n\t\tCLIP_PADDING: (function () {\r\n\t\t\tvar max = L.Browser.mobile ? 1280 : 2000,\r\n\t\t\t    target = (max / Math.max(window.outerWidth, window.outerHeight) - 1) / 2;\r\n\t\t\treturn Math.max(0, Math.min(0.5, target));\r\n\t\t})()\r\n\t},\r\n\r\n\toptions: {\r\n\t\tstroke: true,\r\n\t\tcolor: '#0033ff',\r\n\t\tdashArray: null,\r\n\t\tlineCap: null,\r\n\t\tlineJoin: null,\r\n\t\tweight: 5,\r\n\t\topacity: 0.5,\r\n\r\n\t\tfill: false,\r\n\t\tfillColor: null, //same as color by default\r\n\t\tfillOpacity: 0.2,\r\n\r\n\t\tclickable: true\r\n\t},\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\r\n\t\tif (!this._container) {\r\n\t\t\tthis._initElements();\r\n\t\t\tthis._initEvents();\r\n\t\t}\r\n\r\n\t\tthis.projectLatlngs();\r\n\t\tthis._updatePath();\r\n\r\n\t\tif (this._container) {\r\n\t\t\tthis._map._pathRoot.appendChild(this._container);\r\n\t\t}\r\n\r\n\t\tthis.fire('add');\r\n\r\n\t\tmap.on({\r\n\t\t\t'viewreset': this.projectLatlngs,\r\n\t\t\t'moveend': this._updatePath\r\n\t\t}, this);\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap._pathRoot.removeChild(this._container);\r\n\r\n\t\t// Need to fire remove event before we set _map to null as the event hooks might need the object\r\n\t\tthis.fire('remove');\r\n\t\tthis._map = null;\r\n\r\n\t\tif (L.Browser.vml) {\r\n\t\t\tthis._container = null;\r\n\t\t\tthis._stroke = null;\r\n\t\t\tthis._fill = null;\r\n\t\t}\r\n\r\n\t\tmap.off({\r\n\t\t\t'viewreset': this.projectLatlngs,\r\n\t\t\t'moveend': this._updatePath\r\n\t\t}, this);\r\n\t},\r\n\r\n\tprojectLatlngs: function () {\r\n\t\t// do all projection stuff here\r\n\t},\r\n\r\n\tsetStyle: function (style) {\r\n\t\tL.setOptions(this, style);\r\n\r\n\t\tif (this._container) {\r\n\t\t\tthis._updateStyle();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tredraw: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis.projectLatlngs();\r\n\t\t\tthis._updatePath();\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n});\r\n\r\nL.Map.include({\r\n\t_updatePathViewport: function () {\r\n\t\tvar p = L.Path.CLIP_PADDING,\r\n\t\t    size = this.getSize(),\r\n\t\t    panePos = L.DomUtil.getPosition(this._mapPane),\r\n\t\t    min = panePos.multiplyBy(-1)._subtract(size.multiplyBy(p)._round()),\r\n\t\t    max = min.add(size.multiplyBy(1 + p * 2)._round());\r\n\r\n\t\tthis._pathViewport = new L.Bounds(min, max);\r\n\t}\r\n});\r\n\n\n/*\r\n * Extends L.Path with SVG-specific rendering code.\r\n */\r\n\r\nL.Path.SVG_NS = 'http://www.w3.org/2000/svg';\r\n\r\nL.Browser.svg = !!(document.createElementNS && document.createElementNS(L.Path.SVG_NS, 'svg').createSVGRect);\r\n\r\nL.Path = L.Path.extend({\r\n\tstatics: {\r\n\t\tSVG: L.Browser.svg\r\n\t},\r\n\r\n\tbringToFront: function () {\r\n\t\tvar root = this._map._pathRoot,\r\n\t\t    path = this._container;\r\n\r\n\t\tif (path && root.lastChild !== path) {\r\n\t\t\troot.appendChild(path);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tbringToBack: function () {\r\n\t\tvar root = this._map._pathRoot,\r\n\t\t    path = this._container,\r\n\t\t    first = root.firstChild;\r\n\r\n\t\tif (path && first !== path) {\r\n\t\t\troot.insertBefore(path, first);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetPathString: function () {\r\n\t\t// form path string here\r\n\t},\r\n\r\n\t_createElement: function (name) {\r\n\t\treturn document.createElementNS(L.Path.SVG_NS, name);\r\n\t},\r\n\r\n\t_initElements: function () {\r\n\t\tthis._map._initPathRoot();\r\n\t\tthis._initPath();\r\n\t\tthis._initStyle();\r\n\t},\r\n\r\n\t_initPath: function () {\r\n\t\tthis._container = this._createElement('g');\r\n\r\n\t\tthis._path = this._createElement('path');\r\n\r\n\t\tif (this.options.className) {\r\n\t\t\tL.DomUtil.addClass(this._path, this.options.className);\r\n\t\t}\r\n\r\n\t\tthis._container.appendChild(this._path);\r\n\t},\r\n\r\n\t_initStyle: function () {\r\n\t\tif (this.options.stroke) {\r\n\t\t\tthis._path.setAttribute('stroke-linejoin', 'round');\r\n\t\t\tthis._path.setAttribute('stroke-linecap', 'round');\r\n\t\t}\r\n\t\tif (this.options.fill) {\r\n\t\t\tthis._path.setAttribute('fill-rule', 'evenodd');\r\n\t\t}\r\n\t\tif (this.options.pointerEvents) {\r\n\t\t\tthis._path.setAttribute('pointer-events', this.options.pointerEvents);\r\n\t\t}\r\n\t\tif (!this.options.clickable && !this.options.pointerEvents) {\r\n\t\t\tthis._path.setAttribute('pointer-events', 'none');\r\n\t\t}\r\n\t\tthis._updateStyle();\r\n\t},\r\n\r\n\t_updateStyle: function () {\r\n\t\tif (this.options.stroke) {\r\n\t\t\tthis._path.setAttribute('stroke', this.options.color);\r\n\t\t\tthis._path.setAttribute('stroke-opacity', this.options.opacity);\r\n\t\t\tthis._path.setAttribute('stroke-width', this.options.weight);\r\n\t\t\tif (this.options.dashArray) {\r\n\t\t\t\tthis._path.setAttribute('stroke-dasharray', this.options.dashArray);\r\n\t\t\t} else {\r\n\t\t\t\tthis._path.removeAttribute('stroke-dasharray');\r\n\t\t\t}\r\n\t\t\tif (this.options.lineCap) {\r\n\t\t\t\tthis._path.setAttribute('stroke-linecap', this.options.lineCap);\r\n\t\t\t}\r\n\t\t\tif (this.options.lineJoin) {\r\n\t\t\t\tthis._path.setAttribute('stroke-linejoin', this.options.lineJoin);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tthis._path.setAttribute('stroke', 'none');\r\n\t\t}\r\n\t\tif (this.options.fill) {\r\n\t\t\tthis._path.setAttribute('fill', this.options.fillColor || this.options.color);\r\n\t\t\tthis._path.setAttribute('fill-opacity', this.options.fillOpacity);\r\n\t\t} else {\r\n\t\t\tthis._path.setAttribute('fill', 'none');\r\n\t\t}\r\n\t},\r\n\r\n\t_updatePath: function () {\r\n\t\tvar str = this.getPathString();\r\n\t\tif (!str) {\r\n\t\t\t// fix webkit empty string parsing bug\r\n\t\t\tstr = 'M0 0';\r\n\t\t}\r\n\t\tthis._path.setAttribute('d', str);\r\n\t},\r\n\r\n\t// TODO remove duplication with L.Map\r\n\t_initEvents: function () {\r\n\t\tif (this.options.clickable) {\r\n\t\t\tif (L.Browser.svg || !L.Browser.vml) {\r\n\t\t\t\tL.DomUtil.addClass(this._path, 'leaflet-clickable');\r\n\t\t\t}\r\n\r\n\t\t\tL.DomEvent.on(this._container, 'click', this._onMouseClick, this);\r\n\r\n\t\t\tvar events = ['dblclick', 'mousedown', 'mouseover',\r\n\t\t\t              'mouseout', 'mousemove', 'contextmenu'];\r\n\t\t\tfor (var i = 0; i < events.length; i++) {\r\n\t\t\t\tL.DomEvent.on(this._container, events[i], this._fireMouseEvent, this);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_onMouseClick: function (e) {\r\n\t\tif (this._map.dragging && this._map.dragging.moved()) { return; }\r\n\r\n\t\tthis._fireMouseEvent(e);\r\n\t},\r\n\r\n\t_fireMouseEvent: function (e) {\r\n\t\tif (!this._map || !this.hasEventListeners(e.type)) { return; }\r\n\r\n\t\tvar map = this._map,\r\n\t\t    containerPoint = map.mouseEventToContainerPoint(e),\r\n\t\t    layerPoint = map.containerPointToLayerPoint(containerPoint),\r\n\t\t    latlng = map.layerPointToLatLng(layerPoint);\r\n\r\n\t\tthis.fire(e.type, {\r\n\t\t\tlatlng: latlng,\r\n\t\t\tlayerPoint: layerPoint,\r\n\t\t\tcontainerPoint: containerPoint,\r\n\t\t\toriginalEvent: e\r\n\t\t});\r\n\r\n\t\tif (e.type === 'contextmenu') {\r\n\t\t\tL.DomEvent.preventDefault(e);\r\n\t\t}\r\n\t\tif (e.type !== 'mousemove') {\r\n\t\t\tL.DomEvent.stopPropagation(e);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.Map.include({\r\n\t_initPathRoot: function () {\r\n\t\tif (!this._pathRoot) {\r\n\t\t\tthis._pathRoot = L.Path.prototype._createElement('svg');\r\n\t\t\tthis._panes.overlayPane.appendChild(this._pathRoot);\r\n\r\n\t\t\tif (this.options.zoomAnimation && L.Browser.any3d) {\r\n\t\t\t\tL.DomUtil.addClass(this._pathRoot, 'leaflet-zoom-animated');\r\n\r\n\t\t\t\tthis.on({\r\n\t\t\t\t\t'zoomanim': this._animatePathZoom,\r\n\t\t\t\t\t'zoomend': this._endPathZoom\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\tL.DomUtil.addClass(this._pathRoot, 'leaflet-zoom-hide');\r\n\t\t\t}\r\n\r\n\t\t\tthis.on('moveend', this._updateSvgViewport);\r\n\t\t\tthis._updateSvgViewport();\r\n\t\t}\r\n\t},\r\n\r\n\t_animatePathZoom: function (e) {\r\n\t\tvar scale = this.getZoomScale(e.zoom),\r\n\t\t    offset = this._getCenterOffset(e.center)._multiplyBy(-scale)._add(this._pathViewport.min);\r\n\r\n\t\tthis._pathRoot.style[L.DomUtil.TRANSFORM] =\r\n\t\t        L.DomUtil.getTranslateString(offset) + ' scale(' + scale + ') ';\r\n\r\n\t\tthis._pathZooming = true;\r\n\t},\r\n\r\n\t_endPathZoom: function () {\r\n\t\tthis._pathZooming = false;\r\n\t},\r\n\r\n\t_updateSvgViewport: function () {\r\n\r\n\t\tif (this._pathZooming) {\r\n\t\t\t// Do not update SVGs while a zoom animation is going on otherwise the animation will break.\r\n\t\t\t// When the zoom animation ends we will be updated again anyway\r\n\t\t\t// This fixes the case where you do a momentum move and zoom while the move is still ongoing.\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._updatePathViewport();\r\n\r\n\t\tvar vp = this._pathViewport,\r\n\t\t    min = vp.min,\r\n\t\t    max = vp.max,\r\n\t\t    width = max.x - min.x,\r\n\t\t    height = max.y - min.y,\r\n\t\t    root = this._pathRoot,\r\n\t\t    pane = this._panes.overlayPane;\r\n\r\n\t\t// Hack to make flicker on drag end on mobile webkit less irritating\r\n\t\tif (L.Browser.mobileWebkit) {\r\n\t\t\tpane.removeChild(root);\r\n\t\t}\r\n\r\n\t\tL.DomUtil.setPosition(root, min);\r\n\t\troot.setAttribute('width', width);\r\n\t\troot.setAttribute('height', height);\r\n\t\troot.setAttribute('viewBox', [min.x, min.y, width, height].join(' '));\r\n\r\n\t\tif (L.Browser.mobileWebkit) {\r\n\t\t\tpane.appendChild(root);\r\n\t\t}\r\n\t}\r\n});\r\n\n\n/*\r\n * Popup extension to L.Path (polylines, polygons, circles), adding popup-related methods.\r\n */\r\n\r\nL.Path.include({\r\n\r\n\tbindPopup: function (content, options) {\r\n\r\n\t\tif (content instanceof L.Popup) {\r\n\t\t\tthis._popup = content;\r\n\t\t} else {\r\n\t\t\tif (!this._popup || options) {\r\n\t\t\t\tthis._popup = new L.Popup(options, this);\r\n\t\t\t}\r\n\t\t\tthis._popup.setContent(content);\r\n\t\t}\r\n\r\n\t\tif (!this._popupHandlersAdded) {\r\n\t\t\tthis\r\n\t\t\t    .on('click', this._openPopup, this)\r\n\t\t\t    .on('remove', this.closePopup, this);\r\n\r\n\t\t\tthis._popupHandlersAdded = true;\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tunbindPopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup = null;\r\n\t\t\tthis\r\n\t\t\t    .off('click', this._openPopup)\r\n\t\t\t    .off('remove', this.closePopup);\r\n\r\n\t\t\tthis._popupHandlersAdded = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\topenPopup: function (latlng) {\r\n\r\n\t\tif (this._popup) {\r\n\t\t\t// open the popup from one of the path's points if not specified\r\n\t\t\tlatlng = latlng || this._latlng ||\r\n\t\t\t         this._latlngs[Math.floor(this._latlngs.length / 2)];\r\n\r\n\t\t\tthis._openPopup({latlng: latlng});\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tclosePopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup._close();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_openPopup: function (e) {\r\n\t\tthis._popup.setLatLng(e.latlng);\r\n\t\tthis._map.openPopup(this._popup);\r\n\t}\r\n});\r\n\n\n/*\r\n * Vector rendering for IE6-8 through VML.\r\n * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!\r\n */\r\n\r\nL.Browser.vml = !L.Browser.svg && (function () {\r\n\ttry {\r\n\t\tvar div = document.createElement('div');\r\n\t\tdiv.innerHTML = '<v:shape adj=\"1\"/>';\r\n\r\n\t\tvar shape = div.firstChild;\r\n\t\tshape.style.behavior = 'url(#default#VML)';\r\n\r\n\t\treturn shape && (typeof shape.adj === 'object');\r\n\r\n\t} catch (e) {\r\n\t\treturn false;\r\n\t}\r\n}());\r\n\r\nL.Path = L.Browser.svg || !L.Browser.vml ? L.Path : L.Path.extend({\r\n\tstatics: {\r\n\t\tVML: true,\r\n\t\tCLIP_PADDING: 0.02\r\n\t},\r\n\r\n\t_createElement: (function () {\r\n\t\ttry {\r\n\t\t\tdocument.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');\r\n\t\t\treturn function (name) {\r\n\t\t\t\treturn document.createElement('<lvml:' + name + ' class=\"lvml\">');\r\n\t\t\t};\r\n\t\t} catch (e) {\r\n\t\t\treturn function (name) {\r\n\t\t\t\treturn document.createElement(\r\n\t\t\t\t        '<' + name + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"lvml\">');\r\n\t\t\t};\r\n\t\t}\r\n\t}()),\r\n\r\n\t_initPath: function () {\r\n\t\tvar container = this._container = this._createElement('shape');\r\n\r\n\t\tL.DomUtil.addClass(container, 'leaflet-vml-shape' +\r\n\t\t\t(this.options.className ? ' ' + this.options.className : ''));\r\n\r\n\t\tif (this.options.clickable) {\r\n\t\t\tL.DomUtil.addClass(container, 'leaflet-clickable');\r\n\t\t}\r\n\r\n\t\tcontainer.coordsize = '1 1';\r\n\r\n\t\tthis._path = this._createElement('path');\r\n\t\tcontainer.appendChild(this._path);\r\n\r\n\t\tthis._map._pathRoot.appendChild(container);\r\n\t},\r\n\r\n\t_initStyle: function () {\r\n\t\tthis._updateStyle();\r\n\t},\r\n\r\n\t_updateStyle: function () {\r\n\t\tvar stroke = this._stroke,\r\n\t\t    fill = this._fill,\r\n\t\t    options = this.options,\r\n\t\t    container = this._container;\r\n\r\n\t\tcontainer.stroked = options.stroke;\r\n\t\tcontainer.filled = options.fill;\r\n\r\n\t\tif (options.stroke) {\r\n\t\t\tif (!stroke) {\r\n\t\t\t\tstroke = this._stroke = this._createElement('stroke');\r\n\t\t\t\tstroke.endcap = 'round';\r\n\t\t\t\tcontainer.appendChild(stroke);\r\n\t\t\t}\r\n\t\t\tstroke.weight = options.weight + 'px';\r\n\t\t\tstroke.color = options.color;\r\n\t\t\tstroke.opacity = options.opacity;\r\n\r\n\t\t\tif (options.dashArray) {\r\n\t\t\t\tstroke.dashStyle = L.Util.isArray(options.dashArray) ?\r\n\t\t\t\t    options.dashArray.join(' ') :\r\n\t\t\t\t    options.dashArray.replace(/( *, *)/g, ' ');\r\n\t\t\t} else {\r\n\t\t\t\tstroke.dashStyle = '';\r\n\t\t\t}\r\n\t\t\tif (options.lineCap) {\r\n\t\t\t\tstroke.endcap = options.lineCap.replace('butt', 'flat');\r\n\t\t\t}\r\n\t\t\tif (options.lineJoin) {\r\n\t\t\t\tstroke.joinstyle = options.lineJoin;\r\n\t\t\t}\r\n\r\n\t\t} else if (stroke) {\r\n\t\t\tcontainer.removeChild(stroke);\r\n\t\t\tthis._stroke = null;\r\n\t\t}\r\n\r\n\t\tif (options.fill) {\r\n\t\t\tif (!fill) {\r\n\t\t\t\tfill = this._fill = this._createElement('fill');\r\n\t\t\t\tcontainer.appendChild(fill);\r\n\t\t\t}\r\n\t\t\tfill.color = options.fillColor || options.color;\r\n\t\t\tfill.opacity = options.fillOpacity;\r\n\r\n\t\t} else if (fill) {\r\n\t\t\tcontainer.removeChild(fill);\r\n\t\t\tthis._fill = null;\r\n\t\t}\r\n\t},\r\n\r\n\t_updatePath: function () {\r\n\t\tvar style = this._container.style;\r\n\r\n\t\tstyle.display = 'none';\r\n\t\tthis._path.v = this.getPathString() + ' '; // the space fixes IE empty path string bug\r\n\t\tstyle.display = '';\r\n\t}\r\n});\r\n\r\nL.Map.include(L.Browser.svg || !L.Browser.vml ? {} : {\r\n\t_initPathRoot: function () {\r\n\t\tif (this._pathRoot) { return; }\r\n\r\n\t\tvar root = this._pathRoot = document.createElement('div');\r\n\t\troot.className = 'leaflet-vml-container';\r\n\t\tthis._panes.overlayPane.appendChild(root);\r\n\r\n\t\tthis.on('moveend', this._updatePathViewport);\r\n\t\tthis._updatePathViewport();\r\n\t}\r\n});\r\n\n\n/*\r\n * Vector rendering for all browsers that support canvas.\r\n */\r\n\r\nL.Browser.canvas = (function () {\r\n\treturn !!document.createElement('canvas').getContext;\r\n}());\r\n\r\nL.Path = (L.Path.SVG && !window.L_PREFER_CANVAS) || !L.Browser.canvas ? L.Path : L.Path.extend({\r\n\tstatics: {\r\n\t\t//CLIP_PADDING: 0.02, // not sure if there's a need to set it to a small value\r\n\t\tCANVAS: true,\r\n\t\tSVG: false\r\n\t},\r\n\r\n\tredraw: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis.projectLatlngs();\r\n\t\t\tthis._requestUpdate();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetStyle: function (style) {\r\n\t\tL.setOptions(this, style);\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._updateStyle();\r\n\t\t\tthis._requestUpdate();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap\r\n\t\t    .off('viewreset', this.projectLatlngs, this)\r\n\t\t    .off('moveend', this._updatePath, this);\r\n\r\n\t\tif (this.options.clickable) {\r\n\t\t\tthis._map.off('click', this._onClick, this);\r\n\t\t\tthis._map.off('mousemove', this._onMouseMove, this);\r\n\t\t}\r\n\r\n\t\tthis._requestUpdate();\r\n\t\t\r\n\t\tthis.fire('remove');\r\n\t\tthis._map = null;\r\n\t},\r\n\r\n\t_requestUpdate: function () {\r\n\t\tif (this._map && !L.Path._updateRequest) {\r\n\t\t\tL.Path._updateRequest = L.Util.requestAnimFrame(this._fireMapMoveEnd, this._map);\r\n\t\t}\r\n\t},\r\n\r\n\t_fireMapMoveEnd: function () {\r\n\t\tL.Path._updateRequest = null;\r\n\t\tthis.fire('moveend');\r\n\t},\r\n\r\n\t_initElements: function () {\r\n\t\tthis._map._initPathRoot();\r\n\t\tthis._ctx = this._map._canvasCtx;\r\n\t},\r\n\r\n\t_updateStyle: function () {\r\n\t\tvar options = this.options;\r\n\r\n\t\tif (options.stroke) {\r\n\t\t\tthis._ctx.lineWidth = options.weight;\r\n\t\t\tthis._ctx.strokeStyle = options.color;\r\n\t\t}\r\n\t\tif (options.fill) {\r\n\t\t\tthis._ctx.fillStyle = options.fillColor || options.color;\r\n\t\t}\r\n\r\n\t\tif (options.lineCap) {\r\n\t\t\tthis._ctx.lineCap = options.lineCap;\r\n\t\t}\r\n\t\tif (options.lineJoin) {\r\n\t\t\tthis._ctx.lineJoin = options.lineJoin;\r\n\t\t}\r\n\t},\r\n\r\n\t_drawPath: function () {\r\n\t\tvar i, j, len, len2, point, drawMethod;\r\n\r\n\t\tthis._ctx.beginPath();\r\n\r\n\t\tfor (i = 0, len = this._parts.length; i < len; i++) {\r\n\t\t\tfor (j = 0, len2 = this._parts[i].length; j < len2; j++) {\r\n\t\t\t\tpoint = this._parts[i][j];\r\n\t\t\t\tdrawMethod = (j === 0 ? 'move' : 'line') + 'To';\r\n\r\n\t\t\t\tthis._ctx[drawMethod](point.x, point.y);\r\n\t\t\t}\r\n\t\t\t// TODO refactor ugly hack\r\n\t\t\tif (this instanceof L.Polygon) {\r\n\t\t\t\tthis._ctx.closePath();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_checkIfEmpty: function () {\r\n\t\treturn !this._parts.length;\r\n\t},\r\n\r\n\t_updatePath: function () {\r\n\t\tif (this._checkIfEmpty()) { return; }\r\n\r\n\t\tvar ctx = this._ctx,\r\n\t\t    options = this.options;\r\n\r\n\t\tthis._drawPath();\r\n\t\tctx.save();\r\n\t\tthis._updateStyle();\r\n\r\n\t\tif (options.fill) {\r\n\t\t\tctx.globalAlpha = options.fillOpacity;\r\n\t\t\tctx.fill(options.fillRule || 'evenodd');\r\n\t\t}\r\n\r\n\t\tif (options.stroke) {\r\n\t\t\tctx.globalAlpha = options.opacity;\r\n\t\t\tctx.stroke();\r\n\t\t}\r\n\r\n\t\tctx.restore();\r\n\r\n\t\t// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature\r\n\t},\r\n\r\n\t_initEvents: function () {\r\n\t\tif (this.options.clickable) {\r\n\t\t\tthis._map.on('mousemove', this._onMouseMove, this);\r\n\t\t\tthis._map.on('click dblclick contextmenu', this._fireMouseEvent, this);\r\n\t\t}\r\n\t},\r\n\r\n\t_fireMouseEvent: function (e) {\r\n\t\tif (this._containsPoint(e.layerPoint)) {\r\n\t\t\tthis.fire(e.type, e);\r\n\t\t}\r\n\t},\r\n\r\n\t_onMouseMove: function (e) {\r\n\t\tif (!this._map || this._map._animatingZoom) { return; }\r\n\r\n\t\t// TODO don't do on each move\r\n\t\tif (this._containsPoint(e.layerPoint)) {\r\n\t\t\tthis._ctx.canvas.style.cursor = 'pointer';\r\n\t\t\tthis._mouseInside = true;\r\n\t\t\tthis.fire('mouseover', e);\r\n\r\n\t\t} else if (this._mouseInside) {\r\n\t\t\tthis._ctx.canvas.style.cursor = '';\r\n\t\t\tthis._mouseInside = false;\r\n\t\t\tthis.fire('mouseout', e);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.Map.include((L.Path.SVG && !window.L_PREFER_CANVAS) || !L.Browser.canvas ? {} : {\r\n\t_initPathRoot: function () {\r\n\t\tvar root = this._pathRoot,\r\n\t\t    ctx;\r\n\r\n\t\tif (!root) {\r\n\t\t\troot = this._pathRoot = document.createElement('canvas');\r\n\t\t\troot.style.position = 'absolute';\r\n\t\t\tctx = this._canvasCtx = root.getContext('2d');\r\n\r\n\t\t\tctx.lineCap = 'round';\r\n\t\t\tctx.lineJoin = 'round';\r\n\r\n\t\t\tthis._panes.overlayPane.appendChild(root);\r\n\r\n\t\t\tif (this.options.zoomAnimation) {\r\n\t\t\t\tthis._pathRoot.className = 'leaflet-zoom-animated';\r\n\t\t\t\tthis.on('zoomanim', this._animatePathZoom);\r\n\t\t\t\tthis.on('zoomend', this._endPathZoom);\r\n\t\t\t}\r\n\t\t\tthis.on('moveend', this._updateCanvasViewport);\r\n\t\t\tthis._updateCanvasViewport();\r\n\t\t}\r\n\t},\r\n\r\n\t_updateCanvasViewport: function () {\r\n\t\t// don't redraw while zooming. See _updateSvgViewport for more details\r\n\t\tif (this._pathZooming) { return; }\r\n\t\tthis._updatePathViewport();\r\n\r\n\t\tvar vp = this._pathViewport,\r\n\t\t    min = vp.min,\r\n\t\t    size = vp.max.subtract(min),\r\n\t\t    root = this._pathRoot;\r\n\r\n\t\t//TODO check if this works properly on mobile webkit\r\n\t\tL.DomUtil.setPosition(root, min);\r\n\t\troot.width = size.x;\r\n\t\troot.height = size.y;\r\n\t\troot.getContext('2d').translate(-min.x, -min.y);\r\n\t}\r\n});\r\n\n\n/*\r\n * L.LineUtil contains different utility functions for line segments\r\n * and polylines (clipping, simplification, distances, etc.)\r\n */\r\n\r\n/*jshint bitwise:false */ // allow bitwise operations for this file\r\n\r\nL.LineUtil = {\r\n\r\n\t// Simplify polyline with vertex reduction and Douglas-Peucker simplification.\r\n\t// Improves rendering performance dramatically by lessening the number of points to draw.\r\n\r\n\tsimplify: function (/*Point[]*/ points, /*Number*/ tolerance) {\r\n\t\tif (!tolerance || !points.length) {\r\n\t\t\treturn points.slice();\r\n\t\t}\r\n\r\n\t\tvar sqTolerance = tolerance * tolerance;\r\n\r\n\t\t// stage 1: vertex reduction\r\n\t\tpoints = this._reducePoints(points, sqTolerance);\r\n\r\n\t\t// stage 2: Douglas-Peucker simplification\r\n\t\tpoints = this._simplifyDP(points, sqTolerance);\r\n\r\n\t\treturn points;\r\n\t},\r\n\r\n\t// distance from a point to a segment between two points\r\n\tpointToSegmentDistance:  function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {\r\n\t\treturn Math.sqrt(this._sqClosestPointOnSegment(p, p1, p2, true));\r\n\t},\r\n\r\n\tclosestPointOnSegment: function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {\r\n\t\treturn this._sqClosestPointOnSegment(p, p1, p2);\r\n\t},\r\n\r\n\t// Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm\r\n\t_simplifyDP: function (points, sqTolerance) {\r\n\r\n\t\tvar len = points.length,\r\n\t\t    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,\r\n\t\t    markers = new ArrayConstructor(len);\r\n\r\n\t\tmarkers[0] = markers[len - 1] = 1;\r\n\r\n\t\tthis._simplifyDPStep(points, markers, sqTolerance, 0, len - 1);\r\n\r\n\t\tvar i,\r\n\t\t    newPoints = [];\r\n\r\n\t\tfor (i = 0; i < len; i++) {\r\n\t\t\tif (markers[i]) {\r\n\t\t\t\tnewPoints.push(points[i]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn newPoints;\r\n\t},\r\n\r\n\t_simplifyDPStep: function (points, markers, sqTolerance, first, last) {\r\n\r\n\t\tvar maxSqDist = 0,\r\n\t\t    index, i, sqDist;\r\n\r\n\t\tfor (i = first + 1; i <= last - 1; i++) {\r\n\t\t\tsqDist = this._sqClosestPointOnSegment(points[i], points[first], points[last], true);\r\n\r\n\t\t\tif (sqDist > maxSqDist) {\r\n\t\t\t\tindex = i;\r\n\t\t\t\tmaxSqDist = sqDist;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (maxSqDist > sqTolerance) {\r\n\t\t\tmarkers[index] = 1;\r\n\r\n\t\t\tthis._simplifyDPStep(points, markers, sqTolerance, first, index);\r\n\t\t\tthis._simplifyDPStep(points, markers, sqTolerance, index, last);\r\n\t\t}\r\n\t},\r\n\r\n\t// reduce points that are too close to each other to a single point\r\n\t_reducePoints: function (points, sqTolerance) {\r\n\t\tvar reducedPoints = [points[0]];\r\n\r\n\t\tfor (var i = 1, prev = 0, len = points.length; i < len; i++) {\r\n\t\t\tif (this._sqDist(points[i], points[prev]) > sqTolerance) {\r\n\t\t\t\treducedPoints.push(points[i]);\r\n\t\t\t\tprev = i;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (prev < len - 1) {\r\n\t\t\treducedPoints.push(points[len - 1]);\r\n\t\t}\r\n\t\treturn reducedPoints;\r\n\t},\r\n\r\n\t// Cohen-Sutherland line clipping algorithm.\r\n\t// Used to avoid rendering parts of a polyline that are not currently visible.\r\n\r\n\tclipSegment: function (a, b, bounds, useLastCode) {\r\n\t\tvar codeA = useLastCode ? this._lastCode : this._getBitCode(a, bounds),\r\n\t\t    codeB = this._getBitCode(b, bounds),\r\n\r\n\t\t    codeOut, p, newCode;\r\n\r\n\t\t// save 2nd code to avoid calculating it on the next segment\r\n\t\tthis._lastCode = codeB;\r\n\r\n\t\twhile (true) {\r\n\t\t\t// if a,b is inside the clip window (trivial accept)\r\n\t\t\tif (!(codeA | codeB)) {\r\n\t\t\t\treturn [a, b];\r\n\t\t\t// if a,b is outside the clip window (trivial reject)\r\n\t\t\t} else if (codeA & codeB) {\r\n\t\t\t\treturn false;\r\n\t\t\t// other cases\r\n\t\t\t} else {\r\n\t\t\t\tcodeOut = codeA || codeB;\r\n\t\t\t\tp = this._getEdgeIntersection(a, b, codeOut, bounds);\r\n\t\t\t\tnewCode = this._getBitCode(p, bounds);\r\n\r\n\t\t\t\tif (codeOut === codeA) {\r\n\t\t\t\t\ta = p;\r\n\t\t\t\t\tcodeA = newCode;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tb = p;\r\n\t\t\t\t\tcodeB = newCode;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_getEdgeIntersection: function (a, b, code, bounds) {\r\n\t\tvar dx = b.x - a.x,\r\n\t\t    dy = b.y - a.y,\r\n\t\t    min = bounds.min,\r\n\t\t    max = bounds.max;\r\n\r\n\t\tif (code & 8) { // top\r\n\t\t\treturn new L.Point(a.x + dx * (max.y - a.y) / dy, max.y);\r\n\t\t} else if (code & 4) { // bottom\r\n\t\t\treturn new L.Point(a.x + dx * (min.y - a.y) / dy, min.y);\r\n\t\t} else if (code & 2) { // right\r\n\t\t\treturn new L.Point(max.x, a.y + dy * (max.x - a.x) / dx);\r\n\t\t} else if (code & 1) { // left\r\n\t\t\treturn new L.Point(min.x, a.y + dy * (min.x - a.x) / dx);\r\n\t\t}\r\n\t},\r\n\r\n\t_getBitCode: function (/*Point*/ p, bounds) {\r\n\t\tvar code = 0;\r\n\r\n\t\tif (p.x < bounds.min.x) { // left\r\n\t\t\tcode |= 1;\r\n\t\t} else if (p.x > bounds.max.x) { // right\r\n\t\t\tcode |= 2;\r\n\t\t}\r\n\t\tif (p.y < bounds.min.y) { // bottom\r\n\t\t\tcode |= 4;\r\n\t\t} else if (p.y > bounds.max.y) { // top\r\n\t\t\tcode |= 8;\r\n\t\t}\r\n\r\n\t\treturn code;\r\n\t},\r\n\r\n\t// square distance (to avoid unnecessary Math.sqrt calls)\r\n\t_sqDist: function (p1, p2) {\r\n\t\tvar dx = p2.x - p1.x,\r\n\t\t    dy = p2.y - p1.y;\r\n\t\treturn dx * dx + dy * dy;\r\n\t},\r\n\r\n\t// return closest point on segment or distance to that point\r\n\t_sqClosestPointOnSegment: function (p, p1, p2, sqDist) {\r\n\t\tvar x = p1.x,\r\n\t\t    y = p1.y,\r\n\t\t    dx = p2.x - x,\r\n\t\t    dy = p2.y - y,\r\n\t\t    dot = dx * dx + dy * dy,\r\n\t\t    t;\r\n\r\n\t\tif (dot > 0) {\r\n\t\t\tt = ((p.x - x) * dx + (p.y - y) * dy) / dot;\r\n\r\n\t\t\tif (t > 1) {\r\n\t\t\t\tx = p2.x;\r\n\t\t\t\ty = p2.y;\r\n\t\t\t} else if (t > 0) {\r\n\t\t\t\tx += dx * t;\r\n\t\t\t\ty += dy * t;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tdx = p.x - x;\r\n\t\tdy = p.y - y;\r\n\r\n\t\treturn sqDist ? dx * dx + dy * dy : new L.Point(x, y);\r\n\t}\r\n};\r\n\n\n/*\r\n * L.Polyline is used to display polylines on a map.\r\n */\r\n\r\nL.Polyline = L.Path.extend({\r\n\tinitialize: function (latlngs, options) {\r\n\t\tL.Path.prototype.initialize.call(this, options);\r\n\r\n\t\tthis._latlngs = this._convertLatLngs(latlngs);\r\n\t},\r\n\r\n\toptions: {\r\n\t\t// how much to simplify the polyline on each zoom level\r\n\t\t// more = better performance and smoother look, less = more accurate\r\n\t\tsmoothFactor: 1.0,\r\n\t\tnoClip: false\r\n\t},\r\n\r\n\tprojectLatlngs: function () {\r\n\t\tthis._originalPoints = [];\r\n\r\n\t\tfor (var i = 0, len = this._latlngs.length; i < len; i++) {\r\n\t\t\tthis._originalPoints[i] = this._map.latLngToLayerPoint(this._latlngs[i]);\r\n\t\t}\r\n\t},\r\n\r\n\tgetPathString: function () {\r\n\t\tfor (var i = 0, len = this._parts.length, str = ''; i < len; i++) {\r\n\t\t\tstr += this._getPathPartStr(this._parts[i]);\r\n\t\t}\r\n\t\treturn str;\r\n\t},\r\n\r\n\tgetLatLngs: function () {\r\n\t\treturn this._latlngs;\r\n\t},\r\n\r\n\tsetLatLngs: function (latlngs) {\r\n\t\tthis._latlngs = this._convertLatLngs(latlngs);\r\n\t\treturn this.redraw();\r\n\t},\r\n\r\n\taddLatLng: function (latlng) {\r\n\t\tthis._latlngs.push(L.latLng(latlng));\r\n\t\treturn this.redraw();\r\n\t},\r\n\r\n\tspliceLatLngs: function () { // (Number index, Number howMany)\r\n\t\tvar removed = [].splice.apply(this._latlngs, arguments);\r\n\t\tthis._convertLatLngs(this._latlngs, true);\r\n\t\tthis.redraw();\r\n\t\treturn removed;\r\n\t},\r\n\r\n\tclosestLayerPoint: function (p) {\r\n\t\tvar minDistance = Infinity, parts = this._parts, p1, p2, minPoint = null;\r\n\r\n\t\tfor (var j = 0, jLen = parts.length; j < jLen; j++) {\r\n\t\t\tvar points = parts[j];\r\n\t\t\tfor (var i = 1, len = points.length; i < len; i++) {\r\n\t\t\t\tp1 = points[i - 1];\r\n\t\t\t\tp2 = points[i];\r\n\t\t\t\tvar sqDist = L.LineUtil._sqClosestPointOnSegment(p, p1, p2, true);\r\n\t\t\t\tif (sqDist < minDistance) {\r\n\t\t\t\t\tminDistance = sqDist;\r\n\t\t\t\t\tminPoint = L.LineUtil._sqClosestPointOnSegment(p, p1, p2);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (minPoint) {\r\n\t\t\tminPoint.distance = Math.sqrt(minDistance);\r\n\t\t}\r\n\t\treturn minPoint;\r\n\t},\r\n\r\n\tgetBounds: function () {\r\n\t\treturn new L.LatLngBounds(this.getLatLngs());\r\n\t},\r\n\r\n\t_convertLatLngs: function (latlngs, overwrite) {\r\n\t\tvar i, len, target = overwrite ? latlngs : [];\r\n\r\n\t\tfor (i = 0, len = latlngs.length; i < len; i++) {\r\n\t\t\tif (L.Util.isArray(latlngs[i]) && typeof latlngs[i][0] !== 'number') {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\ttarget[i] = L.latLng(latlngs[i]);\r\n\t\t}\r\n\t\treturn target;\r\n\t},\r\n\r\n\t_initEvents: function () {\r\n\t\tL.Path.prototype._initEvents.call(this);\r\n\t},\r\n\r\n\t_getPathPartStr: function (points) {\r\n\t\tvar round = L.Path.VML;\r\n\r\n\t\tfor (var j = 0, len2 = points.length, str = '', p; j < len2; j++) {\r\n\t\t\tp = points[j];\r\n\t\t\tif (round) {\r\n\t\t\t\tp._round();\r\n\t\t\t}\r\n\t\t\tstr += (j ? 'L' : 'M') + p.x + ' ' + p.y;\r\n\t\t}\r\n\t\treturn str;\r\n\t},\r\n\r\n\t_clipPoints: function () {\r\n\t\tvar points = this._originalPoints,\r\n\t\t    len = points.length,\r\n\t\t    i, k, segment;\r\n\r\n\t\tif (this.options.noClip) {\r\n\t\t\tthis._parts = [points];\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._parts = [];\r\n\r\n\t\tvar parts = this._parts,\r\n\t\t    vp = this._map._pathViewport,\r\n\t\t    lu = L.LineUtil;\r\n\r\n\t\tfor (i = 0, k = 0; i < len - 1; i++) {\r\n\t\t\tsegment = lu.clipSegment(points[i], points[i + 1], vp, i);\r\n\t\t\tif (!segment) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tparts[k] = parts[k] || [];\r\n\t\t\tparts[k].push(segment[0]);\r\n\r\n\t\t\t// if segment goes out of screen, or it's the last one, it's the end of the line part\r\n\t\t\tif ((segment[1] !== points[i + 1]) || (i === len - 2)) {\r\n\t\t\t\tparts[k].push(segment[1]);\r\n\t\t\t\tk++;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t// simplify each clipped part of the polyline\r\n\t_simplifyPoints: function () {\r\n\t\tvar parts = this._parts,\r\n\t\t    lu = L.LineUtil;\r\n\r\n\t\tfor (var i = 0, len = parts.length; i < len; i++) {\r\n\t\t\tparts[i] = lu.simplify(parts[i], this.options.smoothFactor);\r\n\t\t}\r\n\t},\r\n\r\n\t_updatePath: function () {\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tthis._clipPoints();\r\n\t\tthis._simplifyPoints();\r\n\r\n\t\tL.Path.prototype._updatePath.call(this);\r\n\t}\r\n});\r\n\r\nL.polyline = function (latlngs, options) {\r\n\treturn new L.Polyline(latlngs, options);\r\n};\r\n\n\n/*\r\n * L.PolyUtil contains utility functions for polygons (clipping, etc.).\r\n */\r\n\r\n/*jshint bitwise:false */ // allow bitwise operations here\r\n\r\nL.PolyUtil = {};\r\n\r\n/*\r\n * Sutherland-Hodgeman polygon clipping algorithm.\r\n * Used to avoid rendering parts of a polygon that are not currently visible.\r\n */\r\nL.PolyUtil.clipPolygon = function (points, bounds) {\r\n\tvar clippedPoints,\r\n\t    edges = [1, 4, 2, 8],\r\n\t    i, j, k,\r\n\t    a, b,\r\n\t    len, edge, p,\r\n\t    lu = L.LineUtil;\r\n\r\n\tfor (i = 0, len = points.length; i < len; i++) {\r\n\t\tpoints[i]._code = lu._getBitCode(points[i], bounds);\r\n\t}\r\n\r\n\t// for each edge (left, bottom, right, top)\r\n\tfor (k = 0; k < 4; k++) {\r\n\t\tedge = edges[k];\r\n\t\tclippedPoints = [];\r\n\r\n\t\tfor (i = 0, len = points.length, j = len - 1; i < len; j = i++) {\r\n\t\t\ta = points[i];\r\n\t\t\tb = points[j];\r\n\r\n\t\t\t// if a is inside the clip window\r\n\t\t\tif (!(a._code & edge)) {\r\n\t\t\t\t// if b is outside the clip window (a->b goes out of screen)\r\n\t\t\t\tif (b._code & edge) {\r\n\t\t\t\t\tp = lu._getEdgeIntersection(b, a, edge, bounds);\r\n\t\t\t\t\tp._code = lu._getBitCode(p, bounds);\r\n\t\t\t\t\tclippedPoints.push(p);\r\n\t\t\t\t}\r\n\t\t\t\tclippedPoints.push(a);\r\n\r\n\t\t\t// else if b is inside the clip window (a->b enters the screen)\r\n\t\t\t} else if (!(b._code & edge)) {\r\n\t\t\t\tp = lu._getEdgeIntersection(b, a, edge, bounds);\r\n\t\t\t\tp._code = lu._getBitCode(p, bounds);\r\n\t\t\t\tclippedPoints.push(p);\r\n\t\t\t}\r\n\t\t}\r\n\t\tpoints = clippedPoints;\r\n\t}\r\n\r\n\treturn points;\r\n};\r\n\n\n/*\r\n * L.Polygon is used to display polygons on a map.\r\n */\r\n\r\nL.Polygon = L.Polyline.extend({\r\n\toptions: {\r\n\t\tfill: true\r\n\t},\r\n\r\n\tinitialize: function (latlngs, options) {\r\n\t\tL.Polyline.prototype.initialize.call(this, latlngs, options);\r\n\t\tthis._initWithHoles(latlngs);\r\n\t},\r\n\r\n\t_initWithHoles: function (latlngs) {\r\n\t\tvar i, len, hole;\r\n\t\tif (latlngs && L.Util.isArray(latlngs[0]) && (typeof latlngs[0][0] !== 'number')) {\r\n\t\t\tthis._latlngs = this._convertLatLngs(latlngs[0]);\r\n\t\t\tthis._holes = latlngs.slice(1);\r\n\r\n\t\t\tfor (i = 0, len = this._holes.length; i < len; i++) {\r\n\t\t\t\thole = this._holes[i] = this._convertLatLngs(this._holes[i]);\r\n\t\t\t\tif (hole[0].equals(hole[hole.length - 1])) {\r\n\t\t\t\t\thole.pop();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// filter out last point if its equal to the first one\r\n\t\tlatlngs = this._latlngs;\r\n\r\n\t\tif (latlngs.length >= 2 && latlngs[0].equals(latlngs[latlngs.length - 1])) {\r\n\t\t\tlatlngs.pop();\r\n\t\t}\r\n\t},\r\n\r\n\tprojectLatlngs: function () {\r\n\t\tL.Polyline.prototype.projectLatlngs.call(this);\r\n\r\n\t\t// project polygon holes points\r\n\t\t// TODO move this logic to Polyline to get rid of duplication\r\n\t\tthis._holePoints = [];\r\n\r\n\t\tif (!this._holes) { return; }\r\n\r\n\t\tvar i, j, len, len2;\r\n\r\n\t\tfor (i = 0, len = this._holes.length; i < len; i++) {\r\n\t\t\tthis._holePoints[i] = [];\r\n\r\n\t\t\tfor (j = 0, len2 = this._holes[i].length; j < len2; j++) {\r\n\t\t\t\tthis._holePoints[i][j] = this._map.latLngToLayerPoint(this._holes[i][j]);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tsetLatLngs: function (latlngs) {\r\n\t\tif (latlngs && L.Util.isArray(latlngs[0]) && (typeof latlngs[0][0] !== 'number')) {\r\n\t\t\tthis._initWithHoles(latlngs);\r\n\t\t\treturn this.redraw();\r\n\t\t} else {\r\n\t\t\treturn L.Polyline.prototype.setLatLngs.call(this, latlngs);\r\n\t\t}\r\n\t},\r\n\r\n\t_clipPoints: function () {\r\n\t\tvar points = this._originalPoints,\r\n\t\t    newParts = [];\r\n\r\n\t\tthis._parts = [points].concat(this._holePoints);\r\n\r\n\t\tif (this.options.noClip) { return; }\r\n\r\n\t\tfor (var i = 0, len = this._parts.length; i < len; i++) {\r\n\t\t\tvar clipped = L.PolyUtil.clipPolygon(this._parts[i], this._map._pathViewport);\r\n\t\t\tif (clipped.length) {\r\n\t\t\t\tnewParts.push(clipped);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._parts = newParts;\r\n\t},\r\n\r\n\t_getPathPartStr: function (points) {\r\n\t\tvar str = L.Polyline.prototype._getPathPartStr.call(this, points);\r\n\t\treturn str + (L.Browser.svg ? 'z' : 'x');\r\n\t}\r\n});\r\n\r\nL.polygon = function (latlngs, options) {\r\n\treturn new L.Polygon(latlngs, options);\r\n};\r\n\n\n/*\r\n * Contains L.MultiPolyline and L.MultiPolygon layers.\r\n */\r\n\r\n(function () {\r\n\tfunction createMulti(Klass) {\r\n\r\n\t\treturn L.FeatureGroup.extend({\r\n\r\n\t\t\tinitialize: function (latlngs, options) {\r\n\t\t\t\tthis._layers = {};\r\n\t\t\t\tthis._options = options;\r\n\t\t\t\tthis.setLatLngs(latlngs);\r\n\t\t\t},\r\n\r\n\t\t\tsetLatLngs: function (latlngs) {\r\n\t\t\t\tvar i = 0,\r\n\t\t\t\t    len = latlngs.length;\r\n\r\n\t\t\t\tthis.eachLayer(function (layer) {\r\n\t\t\t\t\tif (i < len) {\r\n\t\t\t\t\t\tlayer.setLatLngs(latlngs[i++]);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.removeLayer(layer);\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this);\r\n\r\n\t\t\t\twhile (i < len) {\r\n\t\t\t\t\tthis.addLayer(new Klass(latlngs[i++], this._options));\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\r\n\t\t\tgetLatLngs: function () {\r\n\t\t\t\tvar latlngs = [];\r\n\r\n\t\t\t\tthis.eachLayer(function (layer) {\r\n\t\t\t\t\tlatlngs.push(layer.getLatLngs());\r\n\t\t\t\t});\r\n\r\n\t\t\t\treturn latlngs;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tL.MultiPolyline = createMulti(L.Polyline);\r\n\tL.MultiPolygon = createMulti(L.Polygon);\r\n\r\n\tL.multiPolyline = function (latlngs, options) {\r\n\t\treturn new L.MultiPolyline(latlngs, options);\r\n\t};\r\n\r\n\tL.multiPolygon = function (latlngs, options) {\r\n\t\treturn new L.MultiPolygon(latlngs, options);\r\n\t};\r\n}());\r\n\n\n/*\r\n * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.\r\n */\r\n\r\nL.Rectangle = L.Polygon.extend({\r\n\tinitialize: function (latLngBounds, options) {\r\n\t\tL.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);\r\n\t},\r\n\r\n\tsetBounds: function (latLngBounds) {\r\n\t\tthis.setLatLngs(this._boundsToLatLngs(latLngBounds));\r\n\t},\r\n\r\n\t_boundsToLatLngs: function (latLngBounds) {\r\n\t\tlatLngBounds = L.latLngBounds(latLngBounds);\r\n\t\treturn [\r\n\t\t\tlatLngBounds.getSouthWest(),\r\n\t\t\tlatLngBounds.getNorthWest(),\r\n\t\t\tlatLngBounds.getNorthEast(),\r\n\t\t\tlatLngBounds.getSouthEast()\r\n\t\t];\r\n\t}\r\n});\r\n\r\nL.rectangle = function (latLngBounds, options) {\r\n\treturn new L.Rectangle(latLngBounds, options);\r\n};\r\n\n\n/*\r\n * L.Circle is a circle overlay (with a certain radius in meters).\r\n */\r\n\r\nL.Circle = L.Path.extend({\r\n\tinitialize: function (latlng, radius, options) {\r\n\t\tL.Path.prototype.initialize.call(this, options);\r\n\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\t\tthis._mRadius = radius;\r\n\t},\r\n\r\n\toptions: {\r\n\t\tfill: true\r\n\t},\r\n\r\n\tsetLatLng: function (latlng) {\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\t\treturn this.redraw();\r\n\t},\r\n\r\n\tsetRadius: function (radius) {\r\n\t\tthis._mRadius = radius;\r\n\t\treturn this.redraw();\r\n\t},\r\n\r\n\tprojectLatlngs: function () {\r\n\t\tvar lngRadius = this._getLngRadius(),\r\n\t\t    latlng = this._latlng,\r\n\t\t    pointLeft = this._map.latLngToLayerPoint([latlng.lat, latlng.lng - lngRadius]);\r\n\r\n\t\tthis._point = this._map.latLngToLayerPoint(latlng);\r\n\t\tthis._radius = Math.max(this._point.x - pointLeft.x, 1);\r\n\t},\r\n\r\n\tgetBounds: function () {\r\n\t\tvar lngRadius = this._getLngRadius(),\r\n\t\t    latRadius = (this._mRadius / 40075017) * 360,\r\n\t\t    latlng = this._latlng;\r\n\r\n\t\treturn new L.LatLngBounds(\r\n\t\t        [latlng.lat - latRadius, latlng.lng - lngRadius],\r\n\t\t        [latlng.lat + latRadius, latlng.lng + lngRadius]);\r\n\t},\r\n\r\n\tgetLatLng: function () {\r\n\t\treturn this._latlng;\r\n\t},\r\n\r\n\tgetPathString: function () {\r\n\t\tvar p = this._point,\r\n\t\t    r = this._radius;\r\n\r\n\t\tif (this._checkIfEmpty()) {\r\n\t\t\treturn '';\r\n\t\t}\r\n\r\n\t\tif (L.Browser.svg) {\r\n\t\t\treturn 'M' + p.x + ',' + (p.y - r) +\r\n\t\t\t       'A' + r + ',' + r + ',0,1,1,' +\r\n\t\t\t       (p.x - 0.1) + ',' + (p.y - r) + ' z';\r\n\t\t} else {\r\n\t\t\tp._round();\r\n\t\t\tr = Math.round(r);\r\n\t\t\treturn 'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r + ' 0,' + (65535 * 360);\r\n\t\t}\r\n\t},\r\n\r\n\tgetRadius: function () {\r\n\t\treturn this._mRadius;\r\n\t},\r\n\r\n\t// TODO Earth hardcoded, move into projection code!\r\n\r\n\t_getLatRadius: function () {\r\n\t\treturn (this._mRadius / 40075017) * 360;\r\n\t},\r\n\r\n\t_getLngRadius: function () {\r\n\t\treturn this._getLatRadius() / Math.cos(L.LatLng.DEG_TO_RAD * this._latlng.lat);\r\n\t},\r\n\r\n\t_checkIfEmpty: function () {\r\n\t\tif (!this._map) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tvar vp = this._map._pathViewport,\r\n\t\t    r = this._radius,\r\n\t\t    p = this._point;\r\n\r\n\t\treturn p.x - r > vp.max.x || p.y - r > vp.max.y ||\r\n\t\t       p.x + r < vp.min.x || p.y + r < vp.min.y;\r\n\t}\r\n});\r\n\r\nL.circle = function (latlng, radius, options) {\r\n\treturn new L.Circle(latlng, radius, options);\r\n};\r\n\n\n/*\r\n * L.CircleMarker is a circle overlay with a permanent pixel radius.\r\n */\r\n\r\nL.CircleMarker = L.Circle.extend({\r\n\toptions: {\r\n\t\tradius: 10,\r\n\t\tweight: 2\r\n\t},\r\n\r\n\tinitialize: function (latlng, options) {\r\n\t\tL.Circle.prototype.initialize.call(this, latlng, null, options);\r\n\t\tthis._radius = this.options.radius;\r\n\t},\r\n\r\n\tprojectLatlngs: function () {\r\n\t\tthis._point = this._map.latLngToLayerPoint(this._latlng);\r\n\t},\r\n\r\n\t_updateStyle : function () {\r\n\t\tL.Circle.prototype._updateStyle.call(this);\r\n\t\tthis.setRadius(this.options.radius);\r\n\t},\r\n\r\n\tsetLatLng: function (latlng) {\r\n\t\tL.Circle.prototype.setLatLng.call(this, latlng);\r\n\t\tif (this._popup && this._popup._isOpen) {\r\n\t\t\tthis._popup.setLatLng(latlng);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetRadius: function (radius) {\r\n\t\tthis.options.radius = this._radius = radius;\r\n\t\treturn this.redraw();\r\n\t},\r\n\r\n\tgetRadius: function () {\r\n\t\treturn this._radius;\r\n\t}\r\n});\r\n\r\nL.circleMarker = function (latlng, options) {\r\n\treturn new L.CircleMarker(latlng, options);\r\n};\r\n\n\n/*\r\n * Extends L.Polyline to be able to manually detect clicks on Canvas-rendered polylines.\r\n */\r\n\r\nL.Polyline.include(!L.Path.CANVAS ? {} : {\r\n\t_containsPoint: function (p, closed) {\r\n\t\tvar i, j, k, len, len2, dist, part,\r\n\t\t    w = this.options.weight / 2;\r\n\r\n\t\tif (L.Browser.touch) {\r\n\t\t\tw += 10; // polyline click tolerance on touch devices\r\n\t\t}\r\n\r\n\t\tfor (i = 0, len = this._parts.length; i < len; i++) {\r\n\t\t\tpart = this._parts[i];\r\n\t\t\tfor (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\r\n\t\t\t\tif (!closed && (j === 0)) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdist = L.LineUtil.pointToSegmentDistance(p, part[k], part[j]);\r\n\r\n\t\t\t\tif (dist <= w) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n});\r\n\n\n/*\r\n * Extends L.Polygon to be able to manually detect clicks on Canvas-rendered polygons.\r\n */\r\n\r\nL.Polygon.include(!L.Path.CANVAS ? {} : {\r\n\t_containsPoint: function (p) {\r\n\t\tvar inside = false,\r\n\t\t    part, p1, p2,\r\n\t\t    i, j, k,\r\n\t\t    len, len2;\r\n\r\n\t\t// TODO optimization: check if within bounds first\r\n\r\n\t\tif (L.Polyline.prototype._containsPoint.call(this, p, true)) {\r\n\t\t\t// click on polygon border\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// ray casting algorithm for detecting if point is in polygon\r\n\r\n\t\tfor (i = 0, len = this._parts.length; i < len; i++) {\r\n\t\t\tpart = this._parts[i];\r\n\r\n\t\t\tfor (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\r\n\t\t\t\tp1 = part[j];\r\n\t\t\t\tp2 = part[k];\r\n\r\n\t\t\t\tif (((p1.y > p.y) !== (p2.y > p.y)) &&\r\n\t\t\t\t\t\t(p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {\r\n\t\t\t\t\tinside = !inside;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn inside;\r\n\t}\r\n});\r\n\n\n/*\r\n * Extends L.Circle with Canvas-specific code.\r\n */\r\n\r\nL.Circle.include(!L.Path.CANVAS ? {} : {\r\n\t_drawPath: function () {\r\n\t\tvar p = this._point;\r\n\t\tthis._ctx.beginPath();\r\n\t\tthis._ctx.arc(p.x, p.y, this._radius, 0, Math.PI * 2, false);\r\n\t},\r\n\r\n\t_containsPoint: function (p) {\r\n\t\tvar center = this._point,\r\n\t\t    w2 = this.options.stroke ? this.options.weight / 2 : 0;\r\n\r\n\t\treturn (p.distanceTo(center) <= this._radius + w2);\r\n\t}\r\n});\r\n\n\n/*\n * CircleMarker canvas specific drawing parts.\n */\n\nL.CircleMarker.include(!L.Path.CANVAS ? {} : {\n\t_updateStyle: function () {\n\t\tL.Path.prototype._updateStyle.call(this);\n\t}\n});\n\n\n/*\r\n * L.GeoJSON turns any GeoJSON data into a Leaflet layer.\r\n */\r\n\r\nL.GeoJSON = L.FeatureGroup.extend({\r\n\r\n\tinitialize: function (geojson, options) {\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tthis._layers = {};\r\n\r\n\t\tif (geojson) {\r\n\t\t\tthis.addData(geojson);\r\n\t\t}\r\n\t},\r\n\r\n\taddData: function (geojson) {\r\n\t\tvar features = L.Util.isArray(geojson) ? geojson : geojson.features,\r\n\t\t    i, len, feature;\r\n\r\n\t\tif (features) {\r\n\t\t\tfor (i = 0, len = features.length; i < len; i++) {\r\n\t\t\t\t// Only add this if geometry or geometries are set and not null\r\n\t\t\t\tfeature = features[i];\r\n\t\t\t\tif (feature.geometries || feature.geometry || feature.features || feature.coordinates) {\r\n\t\t\t\t\tthis.addData(features[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tvar options = this.options;\r\n\r\n\t\tif (options.filter && !options.filter(geojson)) { return; }\r\n\r\n\t\tvar layer = L.GeoJSON.geometryToLayer(geojson, options.pointToLayer, options.coordsToLatLng, options);\r\n\t\tlayer.feature = L.GeoJSON.asFeature(geojson);\r\n\r\n\t\tlayer.defaultOptions = layer.options;\r\n\t\tthis.resetStyle(layer);\r\n\r\n\t\tif (options.onEachFeature) {\r\n\t\t\toptions.onEachFeature(geojson, layer);\r\n\t\t}\r\n\r\n\t\treturn this.addLayer(layer);\r\n\t},\r\n\r\n\tresetStyle: function (layer) {\r\n\t\tvar style = this.options.style;\r\n\t\tif (style) {\r\n\t\t\t// reset any custom styles\r\n\t\t\tL.Util.extend(layer.options, layer.defaultOptions);\r\n\r\n\t\t\tthis._setLayerStyle(layer, style);\r\n\t\t}\r\n\t},\r\n\r\n\tsetStyle: function (style) {\r\n\t\tthis.eachLayer(function (layer) {\r\n\t\t\tthis._setLayerStyle(layer, style);\r\n\t\t}, this);\r\n\t},\r\n\r\n\t_setLayerStyle: function (layer, style) {\r\n\t\tif (typeof style === 'function') {\r\n\t\t\tstyle = style(layer.feature);\r\n\t\t}\r\n\t\tif (layer.setStyle) {\r\n\t\t\tlayer.setStyle(style);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.extend(L.GeoJSON, {\r\n\tgeometryToLayer: function (geojson, pointToLayer, coordsToLatLng, vectorOptions) {\r\n\t\tvar geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,\r\n\t\t    coords = geometry.coordinates,\r\n\t\t    layers = [],\r\n\t\t    latlng, latlngs, i, len;\r\n\r\n\t\tcoordsToLatLng = coordsToLatLng || this.coordsToLatLng;\r\n\r\n\t\tswitch (geometry.type) {\r\n\t\tcase 'Point':\r\n\t\t\tlatlng = coordsToLatLng(coords);\r\n\t\t\treturn pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng);\r\n\r\n\t\tcase 'MultiPoint':\r\n\t\t\tfor (i = 0, len = coords.length; i < len; i++) {\r\n\t\t\t\tlatlng = coordsToLatLng(coords[i]);\r\n\t\t\t\tlayers.push(pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng));\r\n\t\t\t}\r\n\t\t\treturn new L.FeatureGroup(layers);\r\n\r\n\t\tcase 'LineString':\r\n\t\t\tlatlngs = this.coordsToLatLngs(coords, 0, coordsToLatLng);\r\n\t\t\treturn new L.Polyline(latlngs, vectorOptions);\r\n\r\n\t\tcase 'Polygon':\r\n\t\t\tif (coords.length === 2 && !coords[1].length) {\r\n\t\t\t\tthrow new Error('Invalid GeoJSON object.');\r\n\t\t\t}\r\n\t\t\tlatlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);\r\n\t\t\treturn new L.Polygon(latlngs, vectorOptions);\r\n\r\n\t\tcase 'MultiLineString':\r\n\t\t\tlatlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);\r\n\t\t\treturn new L.MultiPolyline(latlngs, vectorOptions);\r\n\r\n\t\tcase 'MultiPolygon':\r\n\t\t\tlatlngs = this.coordsToLatLngs(coords, 2, coordsToLatLng);\r\n\t\t\treturn new L.MultiPolygon(latlngs, vectorOptions);\r\n\r\n\t\tcase 'GeometryCollection':\r\n\t\t\tfor (i = 0, len = geometry.geometries.length; i < len; i++) {\r\n\r\n\t\t\t\tlayers.push(this.geometryToLayer({\r\n\t\t\t\t\tgeometry: geometry.geometries[i],\r\n\t\t\t\t\ttype: 'Feature',\r\n\t\t\t\t\tproperties: geojson.properties\r\n\t\t\t\t}, pointToLayer, coordsToLatLng, vectorOptions));\r\n\t\t\t}\r\n\t\t\treturn new L.FeatureGroup(layers);\r\n\r\n\t\tdefault:\r\n\t\t\tthrow new Error('Invalid GeoJSON object.');\r\n\t\t}\r\n\t},\r\n\r\n\tcoordsToLatLng: function (coords) { // (Array[, Boolean]) -> LatLng\r\n\t\treturn new L.LatLng(coords[1], coords[0], coords[2]);\r\n\t},\r\n\r\n\tcoordsToLatLngs: function (coords, levelsDeep, coordsToLatLng) { // (Array[, Number, Function]) -> Array\r\n\t\tvar latlng, i, len,\r\n\t\t    latlngs = [];\r\n\r\n\t\tfor (i = 0, len = coords.length; i < len; i++) {\r\n\t\t\tlatlng = levelsDeep ?\r\n\t\t\t        this.coordsToLatLngs(coords[i], levelsDeep - 1, coordsToLatLng) :\r\n\t\t\t        (coordsToLatLng || this.coordsToLatLng)(coords[i]);\r\n\r\n\t\t\tlatlngs.push(latlng);\r\n\t\t}\r\n\r\n\t\treturn latlngs;\r\n\t},\r\n\r\n\tlatLngToCoords: function (latlng) {\r\n\t\tvar coords = [latlng.lng, latlng.lat];\r\n\r\n\t\tif (latlng.alt !== undefined) {\r\n\t\t\tcoords.push(latlng.alt);\r\n\t\t}\r\n\t\treturn coords;\r\n\t},\r\n\r\n\tlatLngsToCoords: function (latLngs) {\r\n\t\tvar coords = [];\r\n\r\n\t\tfor (var i = 0, len = latLngs.length; i < len; i++) {\r\n\t\t\tcoords.push(L.GeoJSON.latLngToCoords(latLngs[i]));\r\n\t\t}\r\n\r\n\t\treturn coords;\r\n\t},\r\n\r\n\tgetFeature: function (layer, newGeometry) {\r\n\t\treturn layer.feature ? L.extend({}, layer.feature, {geometry: newGeometry}) : L.GeoJSON.asFeature(newGeometry);\r\n\t},\r\n\r\n\tasFeature: function (geoJSON) {\r\n\t\tif (geoJSON.type === 'Feature') {\r\n\t\t\treturn geoJSON;\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\ttype: 'Feature',\r\n\t\t\tproperties: {},\r\n\t\t\tgeometry: geoJSON\r\n\t\t};\r\n\t}\r\n});\r\n\r\nvar PointToGeoJSON = {\r\n\ttoGeoJSON: function () {\r\n\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\ttype: 'Point',\r\n\t\t\tcoordinates: L.GeoJSON.latLngToCoords(this.getLatLng())\r\n\t\t});\r\n\t}\r\n};\r\n\r\nL.Marker.include(PointToGeoJSON);\r\nL.Circle.include(PointToGeoJSON);\r\nL.CircleMarker.include(PointToGeoJSON);\r\n\r\nL.Polyline.include({\r\n\ttoGeoJSON: function () {\r\n\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\ttype: 'LineString',\r\n\t\t\tcoordinates: L.GeoJSON.latLngsToCoords(this.getLatLngs())\r\n\t\t});\r\n\t}\r\n});\r\n\r\nL.Polygon.include({\r\n\ttoGeoJSON: function () {\r\n\t\tvar coords = [L.GeoJSON.latLngsToCoords(this.getLatLngs())],\r\n\t\t    i, len, hole;\r\n\r\n\t\tcoords[0].push(coords[0][0]);\r\n\r\n\t\tif (this._holes) {\r\n\t\t\tfor (i = 0, len = this._holes.length; i < len; i++) {\r\n\t\t\t\thole = L.GeoJSON.latLngsToCoords(this._holes[i]);\r\n\t\t\t\thole.push(hole[0]);\r\n\t\t\t\tcoords.push(hole);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\ttype: 'Polygon',\r\n\t\t\tcoordinates: coords\r\n\t\t});\r\n\t}\r\n});\r\n\r\n(function () {\r\n\tfunction multiToGeoJSON(type) {\r\n\t\treturn function () {\r\n\t\t\tvar coords = [];\r\n\r\n\t\t\tthis.eachLayer(function (layer) {\r\n\t\t\t\tcoords.push(layer.toGeoJSON().geometry.coordinates);\r\n\t\t\t});\r\n\r\n\t\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\t\ttype: type,\r\n\t\t\t\tcoordinates: coords\r\n\t\t\t});\r\n\t\t};\r\n\t}\r\n\r\n\tL.MultiPolyline.include({toGeoJSON: multiToGeoJSON('MultiLineString')});\r\n\tL.MultiPolygon.include({toGeoJSON: multiToGeoJSON('MultiPolygon')});\r\n\r\n\tL.LayerGroup.include({\r\n\t\ttoGeoJSON: function () {\r\n\r\n\t\t\tvar geometry = this.feature && this.feature.geometry,\r\n\t\t\t\tjsons = [],\r\n\t\t\t\tjson;\r\n\r\n\t\t\tif (geometry && geometry.type === 'MultiPoint') {\r\n\t\t\t\treturn multiToGeoJSON('MultiPoint').call(this);\r\n\t\t\t}\r\n\r\n\t\t\tvar isGeometryCollection = geometry && geometry.type === 'GeometryCollection';\r\n\r\n\t\t\tthis.eachLayer(function (layer) {\r\n\t\t\t\tif (layer.toGeoJSON) {\r\n\t\t\t\t\tjson = layer.toGeoJSON();\r\n\t\t\t\t\tjsons.push(isGeometryCollection ? json.geometry : L.GeoJSON.asFeature(json));\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tif (isGeometryCollection) {\r\n\t\t\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\t\t\tgeometries: jsons,\r\n\t\t\t\t\ttype: 'GeometryCollection'\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\treturn {\r\n\t\t\t\ttype: 'FeatureCollection',\r\n\t\t\t\tfeatures: jsons\r\n\t\t\t};\r\n\t\t}\r\n\t});\r\n}());\r\n\r\nL.geoJson = function (geojson, options) {\r\n\treturn new L.GeoJSON(geojson, options);\r\n};\r\n\n\n/*\r\n * L.DomEvent contains functions for working with DOM events.\r\n */\r\n\r\nL.DomEvent = {\r\n\t/* inspired by John Resig, Dean Edwards and YUI addEvent implementations */\r\n\taddListener: function (obj, type, fn, context) { // (HTMLElement, String, Function[, Object])\r\n\r\n\t\tvar id = L.stamp(fn),\r\n\t\t    key = '_leaflet_' + type + id,\r\n\t\t    handler, originalHandler, newType;\r\n\r\n\t\tif (obj[key]) { return this; }\r\n\r\n\t\thandler = function (e) {\r\n\t\t\treturn fn.call(context || obj, e || L.DomEvent._getEvent());\r\n\t\t};\r\n\r\n\t\tif (L.Browser.pointer && type.indexOf('touch') === 0) {\r\n\t\t\treturn this.addPointerListener(obj, type, handler, id);\r\n\t\t}\r\n\t\tif (L.Browser.touch && (type === 'dblclick') && this.addDoubleTapListener) {\r\n\t\t\tthis.addDoubleTapListener(obj, handler, id);\r\n\t\t}\r\n\r\n\t\tif ('addEventListener' in obj) {\r\n\r\n\t\t\tif (type === 'mousewheel') {\r\n\t\t\t\tobj.addEventListener('DOMMouseScroll', handler, false);\r\n\t\t\t\tobj.addEventListener(type, handler, false);\r\n\r\n\t\t\t} else if ((type === 'mouseenter') || (type === 'mouseleave')) {\r\n\r\n\t\t\t\toriginalHandler = handler;\r\n\t\t\t\tnewType = (type === 'mouseenter' ? 'mouseover' : 'mouseout');\r\n\r\n\t\t\t\thandler = function (e) {\r\n\t\t\t\t\tif (!L.DomEvent._checkMouse(obj, e)) { return; }\r\n\t\t\t\t\treturn originalHandler(e);\r\n\t\t\t\t};\r\n\r\n\t\t\t\tobj.addEventListener(newType, handler, false);\r\n\r\n\t\t\t} else if (type === 'click' && L.Browser.android) {\r\n\t\t\t\toriginalHandler = handler;\r\n\t\t\t\thandler = function (e) {\r\n\t\t\t\t\treturn L.DomEvent._filterClick(e, originalHandler);\r\n\t\t\t\t};\r\n\r\n\t\t\t\tobj.addEventListener(type, handler, false);\r\n\t\t\t} else {\r\n\t\t\t\tobj.addEventListener(type, handler, false);\r\n\t\t\t}\r\n\r\n\t\t} else if ('attachEvent' in obj) {\r\n\t\t\tobj.attachEvent('on' + type, handler);\r\n\t\t}\r\n\r\n\t\tobj[key] = handler;\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveListener: function (obj, type, fn) {  // (HTMLElement, String, Function)\r\n\r\n\t\tvar id = L.stamp(fn),\r\n\t\t    key = '_leaflet_' + type + id,\r\n\t\t    handler = obj[key];\r\n\r\n\t\tif (!handler) { return this; }\r\n\r\n\t\tif (L.Browser.pointer && type.indexOf('touch') === 0) {\r\n\t\t\tthis.removePointerListener(obj, type, id);\r\n\t\t} else if (L.Browser.touch && (type === 'dblclick') && this.removeDoubleTapListener) {\r\n\t\t\tthis.removeDoubleTapListener(obj, id);\r\n\r\n\t\t} else if ('removeEventListener' in obj) {\r\n\r\n\t\t\tif (type === 'mousewheel') {\r\n\t\t\t\tobj.removeEventListener('DOMMouseScroll', handler, false);\r\n\t\t\t\tobj.removeEventListener(type, handler, false);\r\n\r\n\t\t\t} else if ((type === 'mouseenter') || (type === 'mouseleave')) {\r\n\t\t\t\tobj.removeEventListener((type === 'mouseenter' ? 'mouseover' : 'mouseout'), handler, false);\r\n\t\t\t} else {\r\n\t\t\t\tobj.removeEventListener(type, handler, false);\r\n\t\t\t}\r\n\t\t} else if ('detachEvent' in obj) {\r\n\t\t\tobj.detachEvent('on' + type, handler);\r\n\t\t}\r\n\r\n\t\tobj[key] = null;\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tstopPropagation: function (e) {\r\n\r\n\t\tif (e.stopPropagation) {\r\n\t\t\te.stopPropagation();\r\n\t\t} else {\r\n\t\t\te.cancelBubble = true;\r\n\t\t}\r\n\t\tL.DomEvent._skipped(e);\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tdisableScrollPropagation: function (el) {\r\n\t\tvar stop = L.DomEvent.stopPropagation;\r\n\r\n\t\treturn L.DomEvent\r\n\t\t\t.on(el, 'mousewheel', stop)\r\n\t\t\t.on(el, 'MozMousePixelScroll', stop);\r\n\t},\r\n\r\n\tdisableClickPropagation: function (el) {\r\n\t\tvar stop = L.DomEvent.stopPropagation;\r\n\r\n\t\tfor (var i = L.Draggable.START.length - 1; i >= 0; i--) {\r\n\t\t\tL.DomEvent.on(el, L.Draggable.START[i], stop);\r\n\t\t}\r\n\r\n\t\treturn L.DomEvent\r\n\t\t\t.on(el, 'click', L.DomEvent._fakeStop)\r\n\t\t\t.on(el, 'dblclick', stop);\r\n\t},\r\n\r\n\tpreventDefault: function (e) {\r\n\r\n\t\tif (e.preventDefault) {\r\n\t\t\te.preventDefault();\r\n\t\t} else {\r\n\t\t\te.returnValue = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tstop: function (e) {\r\n\t\treturn L.DomEvent\r\n\t\t\t.preventDefault(e)\r\n\t\t\t.stopPropagation(e);\r\n\t},\r\n\r\n\tgetMousePosition: function (e, container) {\r\n\t\tif (!container) {\r\n\t\t\treturn new L.Point(e.clientX, e.clientY);\r\n\t\t}\r\n\r\n\t\tvar rect = container.getBoundingClientRect();\r\n\r\n\t\treturn new L.Point(\r\n\t\t\te.clientX - rect.left - container.clientLeft,\r\n\t\t\te.clientY - rect.top - container.clientTop);\r\n\t},\r\n\r\n\tgetWheelDelta: function (e) {\r\n\r\n\t\tvar delta = 0;\r\n\r\n\t\tif (e.wheelDelta) {\r\n\t\t\tdelta = e.wheelDelta / 120;\r\n\t\t}\r\n\t\tif (e.detail) {\r\n\t\t\tdelta = -e.detail / 3;\r\n\t\t}\r\n\t\treturn delta;\r\n\t},\r\n\r\n\t_skipEvents: {},\r\n\r\n\t_fakeStop: function (e) {\r\n\t\t// fakes stopPropagation by setting a special event flag, checked/reset with L.DomEvent._skipped(e)\r\n\t\tL.DomEvent._skipEvents[e.type] = true;\r\n\t},\r\n\r\n\t_skipped: function (e) {\r\n\t\tvar skipped = this._skipEvents[e.type];\r\n\t\t// reset when checking, as it's only used in map container and propagates outside of the map\r\n\t\tthis._skipEvents[e.type] = false;\r\n\t\treturn skipped;\r\n\t},\r\n\r\n\t// check if element really left/entered the event target (for mouseenter/mouseleave)\r\n\t_checkMouse: function (el, e) {\r\n\r\n\t\tvar related = e.relatedTarget;\r\n\r\n\t\tif (!related) { return true; }\r\n\r\n\t\ttry {\r\n\t\t\twhile (related && (related !== el)) {\r\n\t\t\t\trelated = related.parentNode;\r\n\t\t\t}\r\n\t\t} catch (err) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn (related !== el);\r\n\t},\r\n\r\n\t_getEvent: function () { // evil magic for IE\r\n\t\t/*jshint noarg:false */\r\n\t\tvar e = window.event;\r\n\t\tif (!e) {\r\n\t\t\tvar caller = arguments.callee.caller;\r\n\t\t\twhile (caller) {\r\n\t\t\t\te = caller['arguments'][0];\r\n\t\t\t\tif (e && window.Event === e.constructor) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcaller = caller.caller;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn e;\r\n\t},\r\n\r\n\t// this is a horrible workaround for a bug in Android where a single touch triggers two click events\r\n\t_filterClick: function (e, handler) {\r\n\t\tvar timeStamp = (e.timeStamp || e.originalEvent.timeStamp),\r\n\t\t\telapsed = L.DomEvent._lastClick && (timeStamp - L.DomEvent._lastClick);\r\n\r\n\t\t// are they closer together than 500ms yet more than 100ms?\r\n\t\t// Android typically triggers them ~300ms apart while multiple listeners\r\n\t\t// on the same event should be triggered far faster;\r\n\t\t// or check if click is simulated on the element, and if it is, reject any non-simulated events\r\n\r\n\t\tif ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {\r\n\t\t\tL.DomEvent.stop(e);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tL.DomEvent._lastClick = timeStamp;\r\n\r\n\t\treturn handler(e);\r\n\t}\r\n};\r\n\r\nL.DomEvent.on = L.DomEvent.addListener;\r\nL.DomEvent.off = L.DomEvent.removeListener;\r\n\n\n/*\r\n * L.Draggable allows you to add dragging capabilities to any element. Supports mobile devices too.\r\n */\r\n\r\nL.Draggable = L.Class.extend({\r\n\tincludes: L.Mixin.Events,\r\n\r\n\tstatics: {\r\n\t\tSTART: L.Browser.touch ? ['touchstart', 'mousedown'] : ['mousedown'],\r\n\t\tEND: {\r\n\t\t\tmousedown: 'mouseup',\r\n\t\t\ttouchstart: 'touchend',\r\n\t\t\tpointerdown: 'touchend',\r\n\t\t\tMSPointerDown: 'touchend'\r\n\t\t},\r\n\t\tMOVE: {\r\n\t\t\tmousedown: 'mousemove',\r\n\t\t\ttouchstart: 'touchmove',\r\n\t\t\tpointerdown: 'touchmove',\r\n\t\t\tMSPointerDown: 'touchmove'\r\n\t\t}\r\n\t},\r\n\r\n\tinitialize: function (element, dragStartTarget) {\r\n\t\tthis._element = element;\r\n\t\tthis._dragStartTarget = dragStartTarget || element;\r\n\t},\r\n\r\n\tenable: function () {\r\n\t\tif (this._enabled) { return; }\r\n\r\n\t\tfor (var i = L.Draggable.START.length - 1; i >= 0; i--) {\r\n\t\t\tL.DomEvent.on(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);\r\n\t\t}\r\n\r\n\t\tthis._enabled = true;\r\n\t},\r\n\r\n\tdisable: function () {\r\n\t\tif (!this._enabled) { return; }\r\n\r\n\t\tfor (var i = L.Draggable.START.length - 1; i >= 0; i--) {\r\n\t\t\tL.DomEvent.off(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);\r\n\t\t}\r\n\r\n\t\tthis._enabled = false;\r\n\t\tthis._moved = false;\r\n\t},\r\n\r\n\t_onDown: function (e) {\r\n\t\tthis._moved = false;\r\n\r\n\t\tif (e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) { return; }\r\n\r\n\t\tL.DomEvent.stopPropagation(e);\r\n\r\n\t\tif (L.Draggable._disabled) { return; }\r\n\r\n\t\tL.DomUtil.disableImageDrag();\r\n\t\tL.DomUtil.disableTextSelection();\r\n\r\n\t\tif (this._moving) { return; }\r\n\r\n\t\tvar first = e.touches ? e.touches[0] : e;\r\n\r\n\t\tthis._startPoint = new L.Point(first.clientX, first.clientY);\r\n\t\tthis._startPos = this._newPos = L.DomUtil.getPosition(this._element);\r\n\r\n\t\tL.DomEvent\r\n\t\t    .on(document, L.Draggable.MOVE[e.type], this._onMove, this)\r\n\t\t    .on(document, L.Draggable.END[e.type], this._onUp, this);\r\n\t},\r\n\r\n\t_onMove: function (e) {\r\n\t\tif (e.touches && e.touches.length > 1) {\r\n\t\t\tthis._moved = true;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),\r\n\t\t    newPoint = new L.Point(first.clientX, first.clientY),\r\n\t\t    offset = newPoint.subtract(this._startPoint);\r\n\r\n\t\tif (!offset.x && !offset.y) { return; }\r\n\t\tif (L.Browser.touch && Math.abs(offset.x) + Math.abs(offset.y) < 3) { return; }\r\n\r\n\t\tL.DomEvent.preventDefault(e);\r\n\r\n\t\tif (!this._moved) {\r\n\t\t\tthis.fire('dragstart');\r\n\r\n\t\t\tthis._moved = true;\r\n\t\t\tthis._startPos = L.DomUtil.getPosition(this._element).subtract(offset);\r\n\r\n\t\t\tL.DomUtil.addClass(document.body, 'leaflet-dragging');\r\n\t\t\tthis._lastTarget = e.target || e.srcElement;\r\n\t\t\tL.DomUtil.addClass(this._lastTarget, 'leaflet-drag-target');\r\n\t\t}\r\n\r\n\t\tthis._newPos = this._startPos.add(offset);\r\n\t\tthis._moving = true;\r\n\r\n\t\tL.Util.cancelAnimFrame(this._animRequest);\r\n\t\tthis._animRequest = L.Util.requestAnimFrame(this._updatePosition, this, true, this._dragStartTarget);\r\n\t},\r\n\r\n\t_updatePosition: function () {\r\n\t\tthis.fire('predrag');\r\n\t\tL.DomUtil.setPosition(this._element, this._newPos);\r\n\t\tthis.fire('drag');\r\n\t},\r\n\r\n\t_onUp: function () {\r\n\t\tL.DomUtil.removeClass(document.body, 'leaflet-dragging');\r\n\r\n\t\tif (this._lastTarget) {\r\n\t\t\tL.DomUtil.removeClass(this._lastTarget, 'leaflet-drag-target');\r\n\t\t\tthis._lastTarget = null;\r\n\t\t}\r\n\r\n\t\tfor (var i in L.Draggable.MOVE) {\r\n\t\t\tL.DomEvent\r\n\t\t\t    .off(document, L.Draggable.MOVE[i], this._onMove)\r\n\t\t\t    .off(document, L.Draggable.END[i], this._onUp);\r\n\t\t}\r\n\r\n\t\tL.DomUtil.enableImageDrag();\r\n\t\tL.DomUtil.enableTextSelection();\r\n\r\n\t\tif (this._moved && this._moving) {\r\n\t\t\t// ensure drag is not fired after dragend\r\n\t\t\tL.Util.cancelAnimFrame(this._animRequest);\r\n\r\n\t\t\tthis.fire('dragend', {\r\n\t\t\t\tdistance: this._newPos.distanceTo(this._startPos)\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tthis._moving = false;\r\n\t}\r\n});\r\n\n\n/*\n\tL.Handler is a base class for handler classes that are used internally to inject\n\tinteraction features like dragging to classes like Map and Marker.\n*/\n\nL.Handler = L.Class.extend({\n\tinitialize: function (map) {\n\t\tthis._map = map;\n\t},\n\n\tenable: function () {\n\t\tif (this._enabled) { return; }\n\n\t\tthis._enabled = true;\n\t\tthis.addHooks();\n\t},\n\n\tdisable: function () {\n\t\tif (!this._enabled) { return; }\n\n\t\tthis._enabled = false;\n\t\tthis.removeHooks();\n\t},\n\n\tenabled: function () {\n\t\treturn !!this._enabled;\n\t}\n});\n\n\n/*\n * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.\n */\n\nL.Map.mergeOptions({\n\tdragging: true,\n\n\tinertia: !L.Browser.android23,\n\tinertiaDeceleration: 3400, // px/s^2\n\tinertiaMaxSpeed: Infinity, // px/s\n\tinertiaThreshold: L.Browser.touch ? 32 : 18, // ms\n\teaseLinearity: 0.25,\n\n\t// TODO refactor, move to CRS\n\tworldCopyJump: false\n});\n\nL.Map.Drag = L.Handler.extend({\n\taddHooks: function () {\n\t\tif (!this._draggable) {\n\t\t\tvar map = this._map;\n\n\t\t\tthis._draggable = new L.Draggable(map._mapPane, map._container);\n\n\t\t\tthis._draggable.on({\n\t\t\t\t'dragstart': this._onDragStart,\n\t\t\t\t'drag': this._onDrag,\n\t\t\t\t'dragend': this._onDragEnd\n\t\t\t}, this);\n\n\t\t\tif (map.options.worldCopyJump) {\n\t\t\t\tthis._draggable.on('predrag', this._onPreDrag, this);\n\t\t\t\tmap.on('viewreset', this._onViewReset, this);\n\n\t\t\t\tmap.whenReady(this._onViewReset, this);\n\t\t\t}\n\t\t}\n\t\tthis._draggable.enable();\n\t},\n\n\tremoveHooks: function () {\n\t\tthis._draggable.disable();\n\t},\n\n\tmoved: function () {\n\t\treturn this._draggable && this._draggable._moved;\n\t},\n\n\t_onDragStart: function () {\n\t\tvar map = this._map;\n\n\t\tif (map._panAnim) {\n\t\t\tmap._panAnim.stop();\n\t\t}\n\n\t\tmap\n\t\t    .fire('movestart')\n\t\t    .fire('dragstart');\n\n\t\tif (map.options.inertia) {\n\t\t\tthis._positions = [];\n\t\t\tthis._times = [];\n\t\t}\n\t},\n\n\t_onDrag: function () {\n\t\tif (this._map.options.inertia) {\n\t\t\tvar time = this._lastTime = +new Date(),\n\t\t\t    pos = this._lastPos = this._draggable._newPos;\n\n\t\t\tthis._positions.push(pos);\n\t\t\tthis._times.push(time);\n\n\t\t\tif (time - this._times[0] > 200) {\n\t\t\t\tthis._positions.shift();\n\t\t\t\tthis._times.shift();\n\t\t\t}\n\t\t}\n\n\t\tthis._map\n\t\t    .fire('move')\n\t\t    .fire('drag');\n\t},\n\n\t_onViewReset: function () {\n\t\t// TODO fix hardcoded Earth values\n\t\tvar pxCenter = this._map.getSize()._divideBy(2),\n\t\t    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);\n\n\t\tthis._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;\n\t\tthis._worldWidth = this._map.project([0, 180]).x;\n\t},\n\n\t_onPreDrag: function () {\n\t\t// TODO refactor to be able to adjust map pane position after zoom\n\t\tvar worldWidth = this._worldWidth,\n\t\t    halfWidth = Math.round(worldWidth / 2),\n\t\t    dx = this._initialWorldOffset,\n\t\t    x = this._draggable._newPos.x,\n\t\t    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,\n\t\t    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,\n\t\t    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;\n\n\t\tthis._draggable._newPos.x = newX;\n\t},\n\n\t_onDragEnd: function (e) {\n\t\tvar map = this._map,\n\t\t    options = map.options,\n\t\t    delay = +new Date() - this._lastTime,\n\n\t\t    noInertia = !options.inertia || delay > options.inertiaThreshold || !this._positions[0];\n\n\t\tmap.fire('dragend', e);\n\n\t\tif (noInertia) {\n\t\t\tmap.fire('moveend');\n\n\t\t} else {\n\n\t\t\tvar direction = this._lastPos.subtract(this._positions[0]),\n\t\t\t    duration = (this._lastTime + delay - this._times[0]) / 1000,\n\t\t\t    ease = options.easeLinearity,\n\n\t\t\t    speedVector = direction.multiplyBy(ease / duration),\n\t\t\t    speed = speedVector.distanceTo([0, 0]),\n\n\t\t\t    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),\n\t\t\t    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),\n\n\t\t\t    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),\n\t\t\t    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();\n\n\t\t\tif (!offset.x || !offset.y) {\n\t\t\t\tmap.fire('moveend');\n\n\t\t\t} else {\n\t\t\t\toffset = map._limitOffset(offset, map.options.maxBounds);\n\n\t\t\t\tL.Util.requestAnimFrame(function () {\n\t\t\t\t\tmap.panBy(offset, {\n\t\t\t\t\t\tduration: decelerationDuration,\n\t\t\t\t\t\teaseLinearity: ease,\n\t\t\t\t\t\tnoMoveStart: true\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'dragging', L.Map.Drag);\n\n\n/*\n * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.\n */\n\nL.Map.mergeOptions({\n\tdoubleClickZoom: true\n});\n\nL.Map.DoubleClickZoom = L.Handler.extend({\n\taddHooks: function () {\n\t\tthis._map.on('dblclick', this._onDoubleClick, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tthis._map.off('dblclick', this._onDoubleClick, this);\n\t},\n\n\t_onDoubleClick: function (e) {\n\t\tvar map = this._map,\n\t\t    zoom = map.getZoom() + (e.originalEvent.shiftKey ? -1 : 1);\n\n\t\tif (map.options.doubleClickZoom === 'center') {\n\t\t\tmap.setZoom(zoom);\n\t\t} else {\n\t\t\tmap.setZoomAround(e.containerPoint, zoom);\n\t\t}\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'doubleClickZoom', L.Map.DoubleClickZoom);\n\n\n/*\n * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.\n */\n\nL.Map.mergeOptions({\n\tscrollWheelZoom: true\n});\n\nL.Map.ScrollWheelZoom = L.Handler.extend({\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._map._container, 'mousewheel', this._onWheelScroll, this);\n\t\tL.DomEvent.on(this._map._container, 'MozMousePixelScroll', L.DomEvent.preventDefault);\n\t\tthis._delta = 0;\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._map._container, 'mousewheel', this._onWheelScroll);\n\t\tL.DomEvent.off(this._map._container, 'MozMousePixelScroll', L.DomEvent.preventDefault);\n\t},\n\n\t_onWheelScroll: function (e) {\n\t\tvar delta = L.DomEvent.getWheelDelta(e);\n\n\t\tthis._delta += delta;\n\t\tthis._lastMousePos = this._map.mouseEventToContainerPoint(e);\n\n\t\tif (!this._startTime) {\n\t\t\tthis._startTime = +new Date();\n\t\t}\n\n\t\tvar left = Math.max(40 - (+new Date() - this._startTime), 0);\n\n\t\tclearTimeout(this._timer);\n\t\tthis._timer = setTimeout(L.bind(this._performZoom, this), left);\n\n\t\tL.DomEvent.preventDefault(e);\n\t\tL.DomEvent.stopPropagation(e);\n\t},\n\n\t_performZoom: function () {\n\t\tvar map = this._map,\n\t\t    delta = this._delta,\n\t\t    zoom = map.getZoom();\n\n\t\tdelta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);\n\t\tdelta = Math.max(Math.min(delta, 4), -4);\n\t\tdelta = map._limitZoom(zoom + delta) - zoom;\n\n\t\tthis._delta = 0;\n\t\tthis._startTime = null;\n\n\t\tif (!delta) { return; }\n\n\t\tif (map.options.scrollWheelZoom === 'center') {\n\t\t\tmap.setZoom(zoom + delta);\n\t\t} else {\n\t\t\tmap.setZoomAround(this._lastMousePos, zoom + delta);\n\t\t}\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'scrollWheelZoom', L.Map.ScrollWheelZoom);\n\n\n/*\r\n * Extends the event handling code with double tap support for mobile browsers.\r\n */\r\n\r\nL.extend(L.DomEvent, {\r\n\r\n\t_touchstart: L.Browser.msPointer ? 'MSPointerDown' : L.Browser.pointer ? 'pointerdown' : 'touchstart',\r\n\t_touchend: L.Browser.msPointer ? 'MSPointerUp' : L.Browser.pointer ? 'pointerup' : 'touchend',\r\n\r\n\t// inspired by Zepto touch code by Thomas Fuchs\r\n\taddDoubleTapListener: function (obj, handler, id) {\r\n\t\tvar last,\r\n\t\t    doubleTap = false,\r\n\t\t    delay = 250,\r\n\t\t    touch,\r\n\t\t    pre = '_leaflet_',\r\n\t\t    touchstart = this._touchstart,\r\n\t\t    touchend = this._touchend,\r\n\t\t    trackedTouches = [];\r\n\r\n\t\tfunction onTouchStart(e) {\r\n\t\t\tvar count;\r\n\r\n\t\t\tif (L.Browser.pointer) {\r\n\t\t\t\ttrackedTouches.push(e.pointerId);\r\n\t\t\t\tcount = trackedTouches.length;\r\n\t\t\t} else {\r\n\t\t\t\tcount = e.touches.length;\r\n\t\t\t}\r\n\t\t\tif (count > 1) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tvar now = Date.now(),\r\n\t\t\t\tdelta = now - (last || now);\r\n\r\n\t\t\ttouch = e.touches ? e.touches[0] : e;\r\n\t\t\tdoubleTap = (delta > 0 && delta <= delay);\r\n\t\t\tlast = now;\r\n\t\t}\r\n\r\n\t\tfunction onTouchEnd(e) {\r\n\t\t\tif (L.Browser.pointer) {\r\n\t\t\t\tvar idx = trackedTouches.indexOf(e.pointerId);\r\n\t\t\t\tif (idx === -1) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\ttrackedTouches.splice(idx, 1);\r\n\t\t\t}\r\n\r\n\t\t\tif (doubleTap) {\r\n\t\t\t\tif (L.Browser.pointer) {\r\n\t\t\t\t\t// work around .type being readonly with MSPointer* events\r\n\t\t\t\t\tvar newTouch = { },\r\n\t\t\t\t\t\tprop;\r\n\r\n\t\t\t\t\t// jshint forin:false\r\n\t\t\t\t\tfor (var i in touch) {\r\n\t\t\t\t\t\tprop = touch[i];\r\n\t\t\t\t\t\tif (typeof prop === 'function') {\r\n\t\t\t\t\t\t\tnewTouch[i] = prop.bind(touch);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tnewTouch[i] = prop;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttouch = newTouch;\r\n\t\t\t\t}\r\n\t\t\t\ttouch.type = 'dblclick';\r\n\t\t\t\thandler(touch);\r\n\t\t\t\tlast = null;\r\n\t\t\t}\r\n\t\t}\r\n\t\tobj[pre + touchstart + id] = onTouchStart;\r\n\t\tobj[pre + touchend + id] = onTouchEnd;\r\n\r\n\t\t// on pointer we need to listen on the document, otherwise a drag starting on the map and moving off screen\r\n\t\t// will not come through to us, so we will lose track of how many touches are ongoing\r\n\t\tvar endElement = L.Browser.pointer ? document.documentElement : obj;\r\n\r\n\t\tobj.addEventListener(touchstart, onTouchStart, false);\r\n\t\tendElement.addEventListener(touchend, onTouchEnd, false);\r\n\r\n\t\tif (L.Browser.pointer) {\r\n\t\t\tendElement.addEventListener(L.DomEvent.POINTER_CANCEL, onTouchEnd, false);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveDoubleTapListener: function (obj, id) {\r\n\t\tvar pre = '_leaflet_';\r\n\r\n\t\tobj.removeEventListener(this._touchstart, obj[pre + this._touchstart + id], false);\r\n\t\t(L.Browser.pointer ? document.documentElement : obj).removeEventListener(\r\n\t\t        this._touchend, obj[pre + this._touchend + id], false);\r\n\r\n\t\tif (L.Browser.pointer) {\r\n\t\t\tdocument.documentElement.removeEventListener(L.DomEvent.POINTER_CANCEL, obj[pre + this._touchend + id],\r\n\t\t\t\tfalse);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n});\r\n\n\n/*\n * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.\n */\n\nL.extend(L.DomEvent, {\n\n\t//static\n\tPOINTER_DOWN: L.Browser.msPointer ? 'MSPointerDown' : 'pointerdown',\n\tPOINTER_MOVE: L.Browser.msPointer ? 'MSPointerMove' : 'pointermove',\n\tPOINTER_UP: L.Browser.msPointer ? 'MSPointerUp' : 'pointerup',\n\tPOINTER_CANCEL: L.Browser.msPointer ? 'MSPointerCancel' : 'pointercancel',\n\n\t_pointers: [],\n\t_pointerDocumentListener: false,\n\n\t// Provides a touch events wrapper for (ms)pointer events.\n\t// Based on changes by veproza https://github.com/CloudMade/Leaflet/pull/1019\n\t//ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890\n\n\taddPointerListener: function (obj, type, handler, id) {\n\n\t\tswitch (type) {\n\t\tcase 'touchstart':\n\t\t\treturn this.addPointerListenerStart(obj, type, handler, id);\n\t\tcase 'touchend':\n\t\t\treturn this.addPointerListenerEnd(obj, type, handler, id);\n\t\tcase 'touchmove':\n\t\t\treturn this.addPointerListenerMove(obj, type, handler, id);\n\t\tdefault:\n\t\t\tthrow 'Unknown touch event type';\n\t\t}\n\t},\n\n\taddPointerListenerStart: function (obj, type, handler, id) {\n\t\tvar pre = '_leaflet_',\n\t\t    pointers = this._pointers;\n\n\t\tvar cb = function (e) {\n\t\t\tif (e.pointerType !== 'mouse' && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {\n\t\t\t\tL.DomEvent.preventDefault(e);\n\t\t\t}\n\n\t\t\tvar alreadyInArray = false;\n\t\t\tfor (var i = 0; i < pointers.length; i++) {\n\t\t\t\tif (pointers[i].pointerId === e.pointerId) {\n\t\t\t\t\talreadyInArray = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!alreadyInArray) {\n\t\t\t\tpointers.push(e);\n\t\t\t}\n\n\t\t\te.touches = pointers.slice();\n\t\t\te.changedTouches = [e];\n\n\t\t\thandler(e);\n\t\t};\n\n\t\tobj[pre + 'touchstart' + id] = cb;\n\t\tobj.addEventListener(this.POINTER_DOWN, cb, false);\n\n\t\t// need to also listen for end events to keep the _pointers list accurate\n\t\t// this needs to be on the body and never go away\n\t\tif (!this._pointerDocumentListener) {\n\t\t\tvar internalCb = function (e) {\n\t\t\t\tfor (var i = 0; i < pointers.length; i++) {\n\t\t\t\t\tif (pointers[i].pointerId === e.pointerId) {\n\t\t\t\t\t\tpointers.splice(i, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\t//We listen on the documentElement as any drags that end by moving the touch off the screen get fired there\n\t\t\tdocument.documentElement.addEventListener(this.POINTER_UP, internalCb, false);\n\t\t\tdocument.documentElement.addEventListener(this.POINTER_CANCEL, internalCb, false);\n\n\t\t\tthis._pointerDocumentListener = true;\n\t\t}\n\n\t\treturn this;\n\t},\n\n\taddPointerListenerMove: function (obj, type, handler, id) {\n\t\tvar pre = '_leaflet_',\n\t\t    touches = this._pointers;\n\n\t\tfunction cb(e) {\n\n\t\t\t// don't fire touch moves when mouse isn't down\n\t\t\tif ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) { return; }\n\n\t\t\tfor (var i = 0; i < touches.length; i++) {\n\t\t\t\tif (touches[i].pointerId === e.pointerId) {\n\t\t\t\t\ttouches[i] = e;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\te.touches = touches.slice();\n\t\t\te.changedTouches = [e];\n\n\t\t\thandler(e);\n\t\t}\n\n\t\tobj[pre + 'touchmove' + id] = cb;\n\t\tobj.addEventListener(this.POINTER_MOVE, cb, false);\n\n\t\treturn this;\n\t},\n\n\taddPointerListenerEnd: function (obj, type, handler, id) {\n\t\tvar pre = '_leaflet_',\n\t\t    touches = this._pointers;\n\n\t\tvar cb = function (e) {\n\t\t\tfor (var i = 0; i < touches.length; i++) {\n\t\t\t\tif (touches[i].pointerId === e.pointerId) {\n\t\t\t\t\ttouches.splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\te.touches = touches.slice();\n\t\t\te.changedTouches = [e];\n\n\t\t\thandler(e);\n\t\t};\n\n\t\tobj[pre + 'touchend' + id] = cb;\n\t\tobj.addEventListener(this.POINTER_UP, cb, false);\n\t\tobj.addEventListener(this.POINTER_CANCEL, cb, false);\n\n\t\treturn this;\n\t},\n\n\tremovePointerListener: function (obj, type, id) {\n\t\tvar pre = '_leaflet_',\n\t\t    cb = obj[pre + type + id];\n\n\t\tswitch (type) {\n\t\tcase 'touchstart':\n\t\t\tobj.removeEventListener(this.POINTER_DOWN, cb, false);\n\t\t\tbreak;\n\t\tcase 'touchmove':\n\t\t\tobj.removeEventListener(this.POINTER_MOVE, cb, false);\n\t\t\tbreak;\n\t\tcase 'touchend':\n\t\t\tobj.removeEventListener(this.POINTER_UP, cb, false);\n\t\t\tobj.removeEventListener(this.POINTER_CANCEL, cb, false);\n\t\t\tbreak;\n\t\t}\n\n\t\treturn this;\n\t}\n});\n\n\n/*\n * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.\n */\n\nL.Map.mergeOptions({\n\ttouchZoom: L.Browser.touch && !L.Browser.android23,\n\tbounceAtZoomLimits: true\n});\n\nL.Map.TouchZoom = L.Handler.extend({\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._map._container, 'touchstart', this._onTouchStart, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._map._container, 'touchstart', this._onTouchStart, this);\n\t},\n\n\t_onTouchStart: function (e) {\n\t\tvar map = this._map;\n\n\t\tif (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }\n\n\t\tvar p1 = map.mouseEventToLayerPoint(e.touches[0]),\n\t\t    p2 = map.mouseEventToLayerPoint(e.touches[1]),\n\t\t    viewCenter = map._getCenterLayerPoint();\n\n\t\tthis._startCenter = p1.add(p2)._divideBy(2);\n\t\tthis._startDist = p1.distanceTo(p2);\n\n\t\tthis._moved = false;\n\t\tthis._zooming = true;\n\n\t\tthis._centerOffset = viewCenter.subtract(this._startCenter);\n\n\t\tif (map._panAnim) {\n\t\t\tmap._panAnim.stop();\n\t\t}\n\n\t\tL.DomEvent\n\t\t    .on(document, 'touchmove', this._onTouchMove, this)\n\t\t    .on(document, 'touchend', this._onTouchEnd, this);\n\n\t\tL.DomEvent.preventDefault(e);\n\t},\n\n\t_onTouchMove: function (e) {\n\t\tvar map = this._map;\n\n\t\tif (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }\n\n\t\tvar p1 = map.mouseEventToLayerPoint(e.touches[0]),\n\t\t    p2 = map.mouseEventToLayerPoint(e.touches[1]);\n\n\t\tthis._scale = p1.distanceTo(p2) / this._startDist;\n\t\tthis._delta = p1._add(p2)._divideBy(2)._subtract(this._startCenter);\n\n\t\tif (this._scale === 1) { return; }\n\n\t\tif (!map.options.bounceAtZoomLimits) {\n\t\t\tif ((map.getZoom() === map.getMinZoom() && this._scale < 1) ||\n\t\t\t    (map.getZoom() === map.getMaxZoom() && this._scale > 1)) { return; }\n\t\t}\n\n\t\tif (!this._moved) {\n\t\t\tL.DomUtil.addClass(map._mapPane, 'leaflet-touching');\n\n\t\t\tmap\n\t\t\t    .fire('movestart')\n\t\t\t    .fire('zoomstart');\n\n\t\t\tthis._moved = true;\n\t\t}\n\n\t\tL.Util.cancelAnimFrame(this._animRequest);\n\t\tthis._animRequest = L.Util.requestAnimFrame(\n\t\t        this._updateOnMove, this, true, this._map._container);\n\n\t\tL.DomEvent.preventDefault(e);\n\t},\n\n\t_updateOnMove: function () {\n\t\tvar map = this._map,\n\t\t    origin = this._getScaleOrigin(),\n\t\t    center = map.layerPointToLatLng(origin),\n\t\t    zoom = map.getScaleZoom(this._scale);\n\n\t\tmap._animateZoom(center, zoom, this._startCenter, this._scale, this._delta, false, true);\n\t},\n\n\t_onTouchEnd: function () {\n\t\tif (!this._moved || !this._zooming) {\n\t\t\tthis._zooming = false;\n\t\t\treturn;\n\t\t}\n\n\t\tvar map = this._map;\n\n\t\tthis._zooming = false;\n\t\tL.DomUtil.removeClass(map._mapPane, 'leaflet-touching');\n\t\tL.Util.cancelAnimFrame(this._animRequest);\n\n\t\tL.DomEvent\n\t\t    .off(document, 'touchmove', this._onTouchMove)\n\t\t    .off(document, 'touchend', this._onTouchEnd);\n\n\t\tvar origin = this._getScaleOrigin(),\n\t\t    center = map.layerPointToLatLng(origin),\n\n\t\t    oldZoom = map.getZoom(),\n\t\t    floatZoomDelta = map.getScaleZoom(this._scale) - oldZoom,\n\t\t    roundZoomDelta = (floatZoomDelta > 0 ?\n\t\t            Math.ceil(floatZoomDelta) : Math.floor(floatZoomDelta)),\n\n\t\t    zoom = map._limitZoom(oldZoom + roundZoomDelta),\n\t\t    scale = map.getZoomScale(zoom) / this._scale;\n\n\t\tmap._animateZoom(center, zoom, origin, scale);\n\t},\n\n\t_getScaleOrigin: function () {\n\t\tvar centerOffset = this._centerOffset.subtract(this._delta).divideBy(this._scale);\n\t\treturn this._startCenter.add(centerOffset);\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'touchZoom', L.Map.TouchZoom);\n\n\n/*\n * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.\n */\n\nL.Map.mergeOptions({\n\ttap: true,\n\ttapTolerance: 15\n});\n\nL.Map.Tap = L.Handler.extend({\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._map._container, 'touchstart', this._onDown, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._map._container, 'touchstart', this._onDown, this);\n\t},\n\n\t_onDown: function (e) {\n\t\tif (!e.touches) { return; }\n\n\t\tL.DomEvent.preventDefault(e);\n\n\t\tthis._fireClick = true;\n\n\t\t// don't simulate click or track longpress if more than 1 touch\n\t\tif (e.touches.length > 1) {\n\t\t\tthis._fireClick = false;\n\t\t\tclearTimeout(this._holdTimeout);\n\t\t\treturn;\n\t\t}\n\n\t\tvar first = e.touches[0],\n\t\t    el = first.target;\n\n\t\tthis._startPos = this._newPos = new L.Point(first.clientX, first.clientY);\n\n\t\t// if touching a link, highlight it\n\t\tif (el.tagName && el.tagName.toLowerCase() === 'a') {\n\t\t\tL.DomUtil.addClass(el, 'leaflet-active');\n\t\t}\n\n\t\t// simulate long hold but setting a timeout\n\t\tthis._holdTimeout = setTimeout(L.bind(function () {\n\t\t\tif (this._isTapValid()) {\n\t\t\t\tthis._fireClick = false;\n\t\t\t\tthis._onUp();\n\t\t\t\tthis._simulateEvent('contextmenu', first);\n\t\t\t}\n\t\t}, this), 1000);\n\n\t\tL.DomEvent\n\t\t\t.on(document, 'touchmove', this._onMove, this)\n\t\t\t.on(document, 'touchend', this._onUp, this);\n\t},\n\n\t_onUp: function (e) {\n\t\tclearTimeout(this._holdTimeout);\n\n\t\tL.DomEvent\n\t\t\t.off(document, 'touchmove', this._onMove, this)\n\t\t\t.off(document, 'touchend', this._onUp, this);\n\n\t\tif (this._fireClick && e && e.changedTouches) {\n\n\t\t\tvar first = e.changedTouches[0],\n\t\t\t    el = first.target;\n\n\t\t\tif (el && el.tagName && el.tagName.toLowerCase() === 'a') {\n\t\t\t\tL.DomUtil.removeClass(el, 'leaflet-active');\n\t\t\t}\n\n\t\t\t// simulate click if the touch didn't move too much\n\t\t\tif (this._isTapValid()) {\n\t\t\t\tthis._simulateEvent('click', first);\n\t\t\t}\n\t\t}\n\t},\n\n\t_isTapValid: function () {\n\t\treturn this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;\n\t},\n\n\t_onMove: function (e) {\n\t\tvar first = e.touches[0];\n\t\tthis._newPos = new L.Point(first.clientX, first.clientY);\n\t},\n\n\t_simulateEvent: function (type, e) {\n\t\tvar simulatedEvent = document.createEvent('MouseEvents');\n\n\t\tsimulatedEvent._simulated = true;\n\t\te.target._simulatedClick = true;\n\n\t\tsimulatedEvent.initMouseEvent(\n\t\t        type, true, true, window, 1,\n\t\t        e.screenX, e.screenY,\n\t\t        e.clientX, e.clientY,\n\t\t        false, false, false, false, 0, null);\n\n\t\te.target.dispatchEvent(simulatedEvent);\n\t}\n});\n\nif (L.Browser.touch && !L.Browser.pointer) {\n\tL.Map.addInitHook('addHandler', 'tap', L.Map.Tap);\n}\n\n\n/*\n * L.Handler.ShiftDragZoom is used to add shift-drag zoom interaction to the map\n  * (zoom to a selected bounding box), enabled by default.\n */\n\nL.Map.mergeOptions({\n\tboxZoom: true\n});\n\nL.Map.BoxZoom = L.Handler.extend({\n\tinitialize: function (map) {\n\t\tthis._map = map;\n\t\tthis._container = map._container;\n\t\tthis._pane = map._panes.overlayPane;\n\t\tthis._moved = false;\n\t},\n\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._container, 'mousedown', this._onMouseDown, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._container, 'mousedown', this._onMouseDown);\n\t\tthis._moved = false;\n\t},\n\n\tmoved: function () {\n\t\treturn this._moved;\n\t},\n\n\t_onMouseDown: function (e) {\n\t\tthis._moved = false;\n\n\t\tif (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }\n\n\t\tL.DomUtil.disableTextSelection();\n\t\tL.DomUtil.disableImageDrag();\n\n\t\tthis._startLayerPoint = this._map.mouseEventToLayerPoint(e);\n\n\t\tL.DomEvent\n\t\t    .on(document, 'mousemove', this._onMouseMove, this)\n\t\t    .on(document, 'mouseup', this._onMouseUp, this)\n\t\t    .on(document, 'keydown', this._onKeyDown, this);\n\t},\n\n\t_onMouseMove: function (e) {\n\t\tif (!this._moved) {\n\t\t\tthis._box = L.DomUtil.create('div', 'leaflet-zoom-box', this._pane);\n\t\t\tL.DomUtil.setPosition(this._box, this._startLayerPoint);\n\n\t\t\t//TODO refactor: move cursor to styles\n\t\t\tthis._container.style.cursor = 'crosshair';\n\t\t\tthis._map.fire('boxzoomstart');\n\t\t}\n\n\t\tvar startPoint = this._startLayerPoint,\n\t\t    box = this._box,\n\n\t\t    layerPoint = this._map.mouseEventToLayerPoint(e),\n\t\t    offset = layerPoint.subtract(startPoint),\n\n\t\t    newPos = new L.Point(\n\t\t        Math.min(layerPoint.x, startPoint.x),\n\t\t        Math.min(layerPoint.y, startPoint.y));\n\n\t\tL.DomUtil.setPosition(box, newPos);\n\n\t\tthis._moved = true;\n\n\t\t// TODO refactor: remove hardcoded 4 pixels\n\t\tbox.style.width  = (Math.max(0, Math.abs(offset.x) - 4)) + 'px';\n\t\tbox.style.height = (Math.max(0, Math.abs(offset.y) - 4)) + 'px';\n\t},\n\n\t_finish: function () {\n\t\tif (this._moved) {\n\t\t\tthis._pane.removeChild(this._box);\n\t\t\tthis._container.style.cursor = '';\n\t\t}\n\n\t\tL.DomUtil.enableTextSelection();\n\t\tL.DomUtil.enableImageDrag();\n\n\t\tL.DomEvent\n\t\t    .off(document, 'mousemove', this._onMouseMove)\n\t\t    .off(document, 'mouseup', this._onMouseUp)\n\t\t    .off(document, 'keydown', this._onKeyDown);\n\t},\n\n\t_onMouseUp: function (e) {\n\n\t\tthis._finish();\n\n\t\tvar map = this._map,\n\t\t    layerPoint = map.mouseEventToLayerPoint(e);\n\n\t\tif (this._startLayerPoint.equals(layerPoint)) { return; }\n\n\t\tvar bounds = new L.LatLngBounds(\n\t\t        map.layerPointToLatLng(this._startLayerPoint),\n\t\t        map.layerPointToLatLng(layerPoint));\n\n\t\tmap.fitBounds(bounds);\n\n\t\tmap.fire('boxzoomend', {\n\t\t\tboxZoomBounds: bounds\n\t\t});\n\t},\n\n\t_onKeyDown: function (e) {\n\t\tif (e.keyCode === 27) {\n\t\t\tthis._finish();\n\t\t}\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'boxZoom', L.Map.BoxZoom);\n\n\n/*\n * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.\n */\n\nL.Map.mergeOptions({\n\tkeyboard: true,\n\tkeyboardPanOffset: 80,\n\tkeyboardZoomOffset: 1\n});\n\nL.Map.Keyboard = L.Handler.extend({\n\n\tkeyCodes: {\n\t\tleft:    [37],\n\t\tright:   [39],\n\t\tdown:    [40],\n\t\tup:      [38],\n\t\tzoomIn:  [187, 107, 61, 171],\n\t\tzoomOut: [189, 109, 173]\n\t},\n\n\tinitialize: function (map) {\n\t\tthis._map = map;\n\n\t\tthis._setPanOffset(map.options.keyboardPanOffset);\n\t\tthis._setZoomOffset(map.options.keyboardZoomOffset);\n\t},\n\n\taddHooks: function () {\n\t\tvar container = this._map._container;\n\n\t\t// make the container focusable by tabbing\n\t\tif (container.tabIndex === -1) {\n\t\t\tcontainer.tabIndex = '0';\n\t\t}\n\n\t\tL.DomEvent\n\t\t    .on(container, 'focus', this._onFocus, this)\n\t\t    .on(container, 'blur', this._onBlur, this)\n\t\t    .on(container, 'mousedown', this._onMouseDown, this);\n\n\t\tthis._map\n\t\t    .on('focus', this._addHooks, this)\n\t\t    .on('blur', this._removeHooks, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tthis._removeHooks();\n\n\t\tvar container = this._map._container;\n\n\t\tL.DomEvent\n\t\t    .off(container, 'focus', this._onFocus, this)\n\t\t    .off(container, 'blur', this._onBlur, this)\n\t\t    .off(container, 'mousedown', this._onMouseDown, this);\n\n\t\tthis._map\n\t\t    .off('focus', this._addHooks, this)\n\t\t    .off('blur', this._removeHooks, this);\n\t},\n\n\t_onMouseDown: function () {\n\t\tif (this._focused) { return; }\n\n\t\tvar body = document.body,\n\t\t    docEl = document.documentElement,\n\t\t    top = body.scrollTop || docEl.scrollTop,\n\t\t    left = body.scrollLeft || docEl.scrollLeft;\n\n\t\tthis._map._container.focus();\n\n\t\twindow.scrollTo(left, top);\n\t},\n\n\t_onFocus: function () {\n\t\tthis._focused = true;\n\t\tthis._map.fire('focus');\n\t},\n\n\t_onBlur: function () {\n\t\tthis._focused = false;\n\t\tthis._map.fire('blur');\n\t},\n\n\t_setPanOffset: function (pan) {\n\t\tvar keys = this._panKeys = {},\n\t\t    codes = this.keyCodes,\n\t\t    i, len;\n\n\t\tfor (i = 0, len = codes.left.length; i < len; i++) {\n\t\t\tkeys[codes.left[i]] = [-1 * pan, 0];\n\t\t}\n\t\tfor (i = 0, len = codes.right.length; i < len; i++) {\n\t\t\tkeys[codes.right[i]] = [pan, 0];\n\t\t}\n\t\tfor (i = 0, len = codes.down.length; i < len; i++) {\n\t\t\tkeys[codes.down[i]] = [0, pan];\n\t\t}\n\t\tfor (i = 0, len = codes.up.length; i < len; i++) {\n\t\t\tkeys[codes.up[i]] = [0, -1 * pan];\n\t\t}\n\t},\n\n\t_setZoomOffset: function (zoom) {\n\t\tvar keys = this._zoomKeys = {},\n\t\t    codes = this.keyCodes,\n\t\t    i, len;\n\n\t\tfor (i = 0, len = codes.zoomIn.length; i < len; i++) {\n\t\t\tkeys[codes.zoomIn[i]] = zoom;\n\t\t}\n\t\tfor (i = 0, len = codes.zoomOut.length; i < len; i++) {\n\t\t\tkeys[codes.zoomOut[i]] = -zoom;\n\t\t}\n\t},\n\n\t_addHooks: function () {\n\t\tL.DomEvent.on(document, 'keydown', this._onKeyDown, this);\n\t},\n\n\t_removeHooks: function () {\n\t\tL.DomEvent.off(document, 'keydown', this._onKeyDown, this);\n\t},\n\n\t_onKeyDown: function (e) {\n\t\tvar key = e.keyCode,\n\t\t    map = this._map;\n\n\t\tif (key in this._panKeys) {\n\n\t\t\tif (map._panAnim && map._panAnim._inProgress) { return; }\n\n\t\t\tmap.panBy(this._panKeys[key]);\n\n\t\t\tif (map.options.maxBounds) {\n\t\t\t\tmap.panInsideBounds(map.options.maxBounds);\n\t\t\t}\n\n\t\t} else if (key in this._zoomKeys) {\n\t\t\tmap.setZoom(map.getZoom() + this._zoomKeys[key]);\n\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\n\t\tL.DomEvent.stop(e);\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'keyboard', L.Map.Keyboard);\n\n\n/*\n * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.\n */\n\nL.Handler.MarkerDrag = L.Handler.extend({\n\tinitialize: function (marker) {\n\t\tthis._marker = marker;\n\t},\n\n\taddHooks: function () {\n\t\tvar icon = this._marker._icon;\n\t\tif (!this._draggable) {\n\t\t\tthis._draggable = new L.Draggable(icon, icon);\n\t\t}\n\n\t\tthis._draggable\n\t\t\t.on('dragstart', this._onDragStart, this)\n\t\t\t.on('drag', this._onDrag, this)\n\t\t\t.on('dragend', this._onDragEnd, this);\n\t\tthis._draggable.enable();\n\t\tL.DomUtil.addClass(this._marker._icon, 'leaflet-marker-draggable');\n\t},\n\n\tremoveHooks: function () {\n\t\tthis._draggable\n\t\t\t.off('dragstart', this._onDragStart, this)\n\t\t\t.off('drag', this._onDrag, this)\n\t\t\t.off('dragend', this._onDragEnd, this);\n\n\t\tthis._draggable.disable();\n\t\tL.DomUtil.removeClass(this._marker._icon, 'leaflet-marker-draggable');\n\t},\n\n\tmoved: function () {\n\t\treturn this._draggable && this._draggable._moved;\n\t},\n\n\t_onDragStart: function () {\n\t\tthis._marker\n\t\t    .closePopup()\n\t\t    .fire('movestart')\n\t\t    .fire('dragstart');\n\t},\n\n\t_onDrag: function () {\n\t\tvar marker = this._marker,\n\t\t    shadow = marker._shadow,\n\t\t    iconPos = L.DomUtil.getPosition(marker._icon),\n\t\t    latlng = marker._map.layerPointToLatLng(iconPos);\n\n\t\t// update shadow position\n\t\tif (shadow) {\n\t\t\tL.DomUtil.setPosition(shadow, iconPos);\n\t\t}\n\n\t\tmarker._latlng = latlng;\n\n\t\tmarker\n\t\t    .fire('move', {latlng: latlng})\n\t\t    .fire('drag');\n\t},\n\n\t_onDragEnd: function (e) {\n\t\tthis._marker\n\t\t    .fire('moveend')\n\t\t    .fire('dragend', e);\n\t}\n});\n\n\n/*\r\n * L.Control is a base class for implementing map controls. Handles positioning.\r\n * All other controls extend from this class.\r\n */\r\n\r\nL.Control = L.Class.extend({\r\n\toptions: {\r\n\t\tposition: 'topright'\r\n\t},\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tgetPosition: function () {\r\n\t\treturn this.options.position;\r\n\t},\r\n\r\n\tsetPosition: function (position) {\r\n\t\tvar map = this._map;\r\n\r\n\t\tif (map) {\r\n\t\t\tmap.removeControl(this);\r\n\t\t}\r\n\r\n\t\tthis.options.position = position;\r\n\r\n\t\tif (map) {\r\n\t\t\tmap.addControl(this);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetContainer: function () {\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tthis._map = map;\r\n\r\n\t\tvar container = this._container = this.onAdd(map),\r\n\t\t    pos = this.getPosition(),\r\n\t\t    corner = map._controlCorners[pos];\r\n\r\n\t\tL.DomUtil.addClass(container, 'leaflet-control');\r\n\r\n\t\tif (pos.indexOf('bottom') !== -1) {\r\n\t\t\tcorner.insertBefore(container, corner.firstChild);\r\n\t\t} else {\r\n\t\t\tcorner.appendChild(container);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveFrom: function (map) {\r\n\t\tvar pos = this.getPosition(),\r\n\t\t    corner = map._controlCorners[pos];\r\n\r\n\t\tcorner.removeChild(this._container);\r\n\t\tthis._map = null;\r\n\r\n\t\tif (this.onRemove) {\r\n\t\t\tthis.onRemove(map);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_refocusOnMap: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis._map.getContainer().focus();\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.control = function (options) {\r\n\treturn new L.Control(options);\r\n};\r\n\r\n\r\n// adds control-related methods to L.Map\r\n\r\nL.Map.include({\r\n\taddControl: function (control) {\r\n\t\tcontrol.addTo(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveControl: function (control) {\r\n\t\tcontrol.removeFrom(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_initControlPos: function () {\r\n\t\tvar corners = this._controlCorners = {},\r\n\t\t    l = 'leaflet-',\r\n\t\t    container = this._controlContainer =\r\n\t\t            L.DomUtil.create('div', l + 'control-container', this._container);\r\n\r\n\t\tfunction createCorner(vSide, hSide) {\r\n\t\t\tvar className = l + vSide + ' ' + l + hSide;\r\n\r\n\t\t\tcorners[vSide + hSide] = L.DomUtil.create('div', className, container);\r\n\t\t}\r\n\r\n\t\tcreateCorner('top', 'left');\r\n\t\tcreateCorner('top', 'right');\r\n\t\tcreateCorner('bottom', 'left');\r\n\t\tcreateCorner('bottom', 'right');\r\n\t},\r\n\r\n\t_clearControlPos: function () {\r\n\t\tthis._container.removeChild(this._controlContainer);\r\n\t}\r\n});\r\n\n\n/*\r\n * L.Control.Zoom is used for the default zoom buttons on the map.\r\n */\r\n\r\nL.Control.Zoom = L.Control.extend({\r\n\toptions: {\r\n\t\tposition: 'topleft',\r\n\t\tzoomInText: '+',\r\n\t\tzoomInTitle: 'Zoom in',\r\n\t\tzoomOutText: '-',\r\n\t\tzoomOutTitle: 'Zoom out'\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tvar zoomName = 'leaflet-control-zoom',\r\n\t\t    container = L.DomUtil.create('div', zoomName + ' leaflet-bar');\r\n\r\n\t\tthis._map = map;\r\n\r\n\t\tthis._zoomInButton  = this._createButton(\r\n\t\t        this.options.zoomInText, this.options.zoomInTitle,\r\n\t\t        zoomName + '-in',  container, this._zoomIn,  this);\r\n\t\tthis._zoomOutButton = this._createButton(\r\n\t\t        this.options.zoomOutText, this.options.zoomOutTitle,\r\n\t\t        zoomName + '-out', container, this._zoomOut, this);\r\n\r\n\t\tthis._updateDisabled();\r\n\t\tmap.on('zoomend zoomlevelschange', this._updateDisabled, this);\r\n\r\n\t\treturn container;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap.off('zoomend zoomlevelschange', this._updateDisabled, this);\r\n\t},\r\n\r\n\t_zoomIn: function (e) {\r\n\t\tthis._map.zoomIn(e.shiftKey ? 3 : 1);\r\n\t},\r\n\r\n\t_zoomOut: function (e) {\r\n\t\tthis._map.zoomOut(e.shiftKey ? 3 : 1);\r\n\t},\r\n\r\n\t_createButton: function (html, title, className, container, fn, context) {\r\n\t\tvar link = L.DomUtil.create('a', className, container);\r\n\t\tlink.innerHTML = html;\r\n\t\tlink.href = '#';\r\n\t\tlink.title = title;\r\n\r\n\t\tvar stop = L.DomEvent.stopPropagation;\r\n\r\n\t\tL.DomEvent\r\n\t\t    .on(link, 'click', stop)\r\n\t\t    .on(link, 'mousedown', stop)\r\n\t\t    .on(link, 'dblclick', stop)\r\n\t\t    .on(link, 'click', L.DomEvent.preventDefault)\r\n\t\t    .on(link, 'click', fn, context)\r\n\t\t    .on(link, 'click', this._refocusOnMap, context);\r\n\r\n\t\treturn link;\r\n\t},\r\n\r\n\t_updateDisabled: function () {\r\n\t\tvar map = this._map,\r\n\t\t\tclassName = 'leaflet-disabled';\r\n\r\n\t\tL.DomUtil.removeClass(this._zoomInButton, className);\r\n\t\tL.DomUtil.removeClass(this._zoomOutButton, className);\r\n\r\n\t\tif (map._zoom === map.getMinZoom()) {\r\n\t\t\tL.DomUtil.addClass(this._zoomOutButton, className);\r\n\t\t}\r\n\t\tif (map._zoom === map.getMaxZoom()) {\r\n\t\t\tL.DomUtil.addClass(this._zoomInButton, className);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.Map.mergeOptions({\r\n\tzoomControl: true\r\n});\r\n\r\nL.Map.addInitHook(function () {\r\n\tif (this.options.zoomControl) {\r\n\t\tthis.zoomControl = new L.Control.Zoom();\r\n\t\tthis.addControl(this.zoomControl);\r\n\t}\r\n});\r\n\r\nL.control.zoom = function (options) {\r\n\treturn new L.Control.Zoom(options);\r\n};\r\n\r\n\n\n/*\r\n * L.Control.Attribution is used for displaying attribution on the map (added by default).\r\n */\r\n\r\nL.Control.Attribution = L.Control.extend({\r\n\toptions: {\r\n\t\tposition: 'bottomright',\r\n\t\tprefix: '<a href=\"http://leafletjs.com\" title=\"A JS library for interactive maps\">Leaflet</a>'\r\n\t},\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tthis._attributions = {};\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._container = L.DomUtil.create('div', 'leaflet-control-attribution');\r\n\t\tL.DomEvent.disableClickPropagation(this._container);\r\n\r\n\t\tfor (var i in map._layers) {\r\n\t\t\tif (map._layers[i].getAttribution) {\r\n\t\t\t\tthis.addAttribution(map._layers[i].getAttribution());\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tmap\r\n\t\t    .on('layeradd', this._onLayerAdd, this)\r\n\t\t    .on('layerremove', this._onLayerRemove, this);\r\n\r\n\t\tthis._update();\r\n\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap\r\n\t\t    .off('layeradd', this._onLayerAdd)\r\n\t\t    .off('layerremove', this._onLayerRemove);\r\n\r\n\t},\r\n\r\n\tsetPrefix: function (prefix) {\r\n\t\tthis.options.prefix = prefix;\r\n\t\tthis._update();\r\n\t\treturn this;\r\n\t},\r\n\r\n\taddAttribution: function (text) {\r\n\t\tif (!text) { return; }\r\n\r\n\t\tif (!this._attributions[text]) {\r\n\t\t\tthis._attributions[text] = 0;\r\n\t\t}\r\n\t\tthis._attributions[text]++;\r\n\r\n\t\tthis._update();\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveAttribution: function (text) {\r\n\t\tif (!text) { return; }\r\n\r\n\t\tif (this._attributions[text]) {\r\n\t\t\tthis._attributions[text]--;\r\n\t\t\tthis._update();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_update: function () {\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tvar attribs = [];\r\n\r\n\t\tfor (var i in this._attributions) {\r\n\t\t\tif (this._attributions[i]) {\r\n\t\t\t\tattribs.push(i);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar prefixAndAttribs = [];\r\n\r\n\t\tif (this.options.prefix) {\r\n\t\t\tprefixAndAttribs.push(this.options.prefix);\r\n\t\t}\r\n\t\tif (attribs.length) {\r\n\t\t\tprefixAndAttribs.push(attribs.join(', '));\r\n\t\t}\r\n\r\n\t\tthis._container.innerHTML = prefixAndAttribs.join(' | ');\r\n\t},\r\n\r\n\t_onLayerAdd: function (e) {\r\n\t\tif (e.layer.getAttribution) {\r\n\t\t\tthis.addAttribution(e.layer.getAttribution());\r\n\t\t}\r\n\t},\r\n\r\n\t_onLayerRemove: function (e) {\r\n\t\tif (e.layer.getAttribution) {\r\n\t\t\tthis.removeAttribution(e.layer.getAttribution());\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.Map.mergeOptions({\r\n\tattributionControl: true\r\n});\r\n\r\nL.Map.addInitHook(function () {\r\n\tif (this.options.attributionControl) {\r\n\t\tthis.attributionControl = (new L.Control.Attribution()).addTo(this);\r\n\t}\r\n});\r\n\r\nL.control.attribution = function (options) {\r\n\treturn new L.Control.Attribution(options);\r\n};\r\n\n\n/*\n * L.Control.Scale is used for displaying metric/imperial scale on the map.\n */\n\nL.Control.Scale = L.Control.extend({\n\toptions: {\n\t\tposition: 'bottomleft',\n\t\tmaxWidth: 100,\n\t\tmetric: true,\n\t\timperial: true,\n\t\tupdateWhenIdle: false\n\t},\n\n\tonAdd: function (map) {\n\t\tthis._map = map;\n\n\t\tvar className = 'leaflet-control-scale',\n\t\t    container = L.DomUtil.create('div', className),\n\t\t    options = this.options;\n\n\t\tthis._addScales(options, className, container);\n\n\t\tmap.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n\t\tmap.whenReady(this._update, this);\n\n\t\treturn container;\n\t},\n\n\tonRemove: function (map) {\n\t\tmap.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n\t},\n\n\t_addScales: function (options, className, container) {\n\t\tif (options.metric) {\n\t\t\tthis._mScale = L.DomUtil.create('div', className + '-line', container);\n\t\t}\n\t\tif (options.imperial) {\n\t\t\tthis._iScale = L.DomUtil.create('div', className + '-line', container);\n\t\t}\n\t},\n\n\t_update: function () {\n\t\tvar bounds = this._map.getBounds(),\n\t\t    centerLat = bounds.getCenter().lat,\n\t\t    halfWorldMeters = 6378137 * Math.PI * Math.cos(centerLat * Math.PI / 180),\n\t\t    dist = halfWorldMeters * (bounds.getNorthEast().lng - bounds.getSouthWest().lng) / 180,\n\n\t\t    size = this._map.getSize(),\n\t\t    options = this.options,\n\t\t    maxMeters = 0;\n\n\t\tif (size.x > 0) {\n\t\t\tmaxMeters = dist * (options.maxWidth / size.x);\n\t\t}\n\n\t\tthis._updateScales(options, maxMeters);\n\t},\n\n\t_updateScales: function (options, maxMeters) {\n\t\tif (options.metric && maxMeters) {\n\t\t\tthis._updateMetric(maxMeters);\n\t\t}\n\n\t\tif (options.imperial && maxMeters) {\n\t\t\tthis._updateImperial(maxMeters);\n\t\t}\n\t},\n\n\t_updateMetric: function (maxMeters) {\n\t\tvar meters = this._getRoundNum(maxMeters);\n\n\t\tthis._mScale.style.width = this._getScaleWidth(meters / maxMeters) + 'px';\n\t\tthis._mScale.innerHTML = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';\n\t},\n\n\t_updateImperial: function (maxMeters) {\n\t\tvar maxFeet = maxMeters * 3.2808399,\n\t\t    scale = this._iScale,\n\t\t    maxMiles, miles, feet;\n\n\t\tif (maxFeet > 5280) {\n\t\t\tmaxMiles = maxFeet / 5280;\n\t\t\tmiles = this._getRoundNum(maxMiles);\n\n\t\t\tscale.style.width = this._getScaleWidth(miles / maxMiles) + 'px';\n\t\t\tscale.innerHTML = miles + ' mi';\n\n\t\t} else {\n\t\t\tfeet = this._getRoundNum(maxFeet);\n\n\t\t\tscale.style.width = this._getScaleWidth(feet / maxFeet) + 'px';\n\t\t\tscale.innerHTML = feet + ' ft';\n\t\t}\n\t},\n\n\t_getScaleWidth: function (ratio) {\n\t\treturn Math.round(this.options.maxWidth * ratio) - 10;\n\t},\n\n\t_getRoundNum: function (num) {\n\t\tvar pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),\n\t\t    d = num / pow10;\n\n\t\td = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;\n\n\t\treturn pow10 * d;\n\t}\n});\n\nL.control.scale = function (options) {\n\treturn new L.Control.Scale(options);\n};\n\n\n/*\r\n * L.Control.Layers is a control to allow users to switch between different layers on the map.\r\n */\r\n\r\nL.Control.Layers = L.Control.extend({\r\n\toptions: {\r\n\t\tcollapsed: true,\r\n\t\tposition: 'topright',\r\n\t\tautoZIndex: true\r\n\t},\r\n\r\n\tinitialize: function (baseLayers, overlays, options) {\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tthis._layers = {};\r\n\t\tthis._lastZIndex = 0;\r\n\t\tthis._handlingClick = false;\r\n\r\n\t\tfor (var i in baseLayers) {\r\n\t\t\tthis._addLayer(baseLayers[i], i);\r\n\t\t}\r\n\r\n\t\tfor (i in overlays) {\r\n\t\t\tthis._addLayer(overlays[i], i, true);\r\n\t\t}\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._initLayout();\r\n\t\tthis._update();\r\n\r\n\t\tmap\r\n\t\t    .on('layeradd', this._onLayerChange, this)\r\n\t\t    .on('layerremove', this._onLayerChange, this);\r\n\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap\r\n\t\t    .off('layeradd', this._onLayerChange, this)\r\n\t\t    .off('layerremove', this._onLayerChange, this);\r\n\t},\r\n\r\n\taddBaseLayer: function (layer, name) {\r\n\t\tthis._addLayer(layer, name);\r\n\t\tthis._update();\r\n\t\treturn this;\r\n\t},\r\n\r\n\taddOverlay: function (layer, name) {\r\n\t\tthis._addLayer(layer, name, true);\r\n\t\tthis._update();\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveLayer: function (layer) {\r\n\t\tvar id = L.stamp(layer);\r\n\t\tdelete this._layers[id];\r\n\t\tthis._update();\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_initLayout: function () {\r\n\t\tvar className = 'leaflet-control-layers',\r\n\t\t    container = this._container = L.DomUtil.create('div', className);\r\n\r\n\t\t//Makes this work on IE10 Touch devices by stopping it from firing a mouseout event when the touch is released\r\n\t\tcontainer.setAttribute('aria-haspopup', true);\r\n\r\n\t\tif (!L.Browser.touch) {\r\n\t\t\tL.DomEvent\r\n\t\t\t\t.disableClickPropagation(container)\r\n\t\t\t\t.disableScrollPropagation(container);\r\n\t\t} else {\r\n\t\t\tL.DomEvent.on(container, 'click', L.DomEvent.stopPropagation);\r\n\t\t}\r\n\r\n\t\tvar form = this._form = L.DomUtil.create('form', className + '-list');\r\n\r\n\t\tif (this.options.collapsed) {\r\n\t\t\tif (!L.Browser.android) {\r\n\t\t\t\tL.DomEvent\r\n\t\t\t\t    .on(container, 'mouseover', this._expand, this)\r\n\t\t\t\t    .on(container, 'mouseout', this._collapse, this);\r\n\t\t\t}\r\n\t\t\tvar link = this._layersLink = L.DomUtil.create('a', className + '-toggle', container);\r\n\t\t\tlink.href = '#';\r\n\t\t\tlink.title = 'Layers';\r\n\r\n\t\t\tif (L.Browser.touch) {\r\n\t\t\t\tL.DomEvent\r\n\t\t\t\t    .on(link, 'click', L.DomEvent.stop)\r\n\t\t\t\t    .on(link, 'click', this._expand, this);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tL.DomEvent.on(link, 'focus', this._expand, this);\r\n\t\t\t}\r\n\t\t\t//Work around for Firefox android issue https://github.com/Leaflet/Leaflet/issues/2033\r\n\t\t\tL.DomEvent.on(form, 'click', function () {\r\n\t\t\t\tsetTimeout(L.bind(this._onInputClick, this), 0);\r\n\t\t\t}, this);\r\n\r\n\t\t\tthis._map.on('click', this._collapse, this);\r\n\t\t\t// TODO keyboard accessibility\r\n\t\t} else {\r\n\t\t\tthis._expand();\r\n\t\t}\r\n\r\n\t\tthis._baseLayersList = L.DomUtil.create('div', className + '-base', form);\r\n\t\tthis._separator = L.DomUtil.create('div', className + '-separator', form);\r\n\t\tthis._overlaysList = L.DomUtil.create('div', className + '-overlays', form);\r\n\r\n\t\tcontainer.appendChild(form);\r\n\t},\r\n\r\n\t_addLayer: function (layer, name, overlay) {\r\n\t\tvar id = L.stamp(layer);\r\n\r\n\t\tthis._layers[id] = {\r\n\t\t\tlayer: layer,\r\n\t\t\tname: name,\r\n\t\t\toverlay: overlay\r\n\t\t};\r\n\r\n\t\tif (this.options.autoZIndex && layer.setZIndex) {\r\n\t\t\tthis._lastZIndex++;\r\n\t\t\tlayer.setZIndex(this._lastZIndex);\r\n\t\t}\r\n\t},\r\n\r\n\t_update: function () {\r\n\t\tif (!this._container) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._baseLayersList.innerHTML = '';\r\n\t\tthis._overlaysList.innerHTML = '';\r\n\r\n\t\tvar baseLayersPresent = false,\r\n\t\t    overlaysPresent = false,\r\n\t\t    i, obj;\r\n\r\n\t\tfor (i in this._layers) {\r\n\t\t\tobj = this._layers[i];\r\n\t\t\tthis._addItem(obj);\r\n\t\t\toverlaysPresent = overlaysPresent || obj.overlay;\r\n\t\t\tbaseLayersPresent = baseLayersPresent || !obj.overlay;\r\n\t\t}\r\n\r\n\t\tthis._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';\r\n\t},\r\n\r\n\t_onLayerChange: function (e) {\r\n\t\tvar obj = this._layers[L.stamp(e.layer)];\r\n\r\n\t\tif (!obj) { return; }\r\n\r\n\t\tif (!this._handlingClick) {\r\n\t\t\tthis._update();\r\n\t\t}\r\n\r\n\t\tvar type = obj.overlay ?\r\n\t\t\t(e.type === 'layeradd' ? 'overlayadd' : 'overlayremove') :\r\n\t\t\t(e.type === 'layeradd' ? 'baselayerchange' : null);\r\n\r\n\t\tif (type) {\r\n\t\t\tthis._map.fire(type, obj);\r\n\t\t}\r\n\t},\r\n\r\n\t// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)\r\n\t_createRadioElement: function (name, checked) {\r\n\r\n\t\tvar radioHtml = '<input type=\"radio\" class=\"leaflet-control-layers-selector\" name=\"' + name + '\"';\r\n\t\tif (checked) {\r\n\t\t\tradioHtml += ' checked=\"checked\"';\r\n\t\t}\r\n\t\tradioHtml += '/>';\r\n\r\n\t\tvar radioFragment = document.createElement('div');\r\n\t\tradioFragment.innerHTML = radioHtml;\r\n\r\n\t\treturn radioFragment.firstChild;\r\n\t},\r\n\r\n\t_addItem: function (obj) {\r\n\t\tvar label = document.createElement('label'),\r\n\t\t    input,\r\n\t\t    checked = this._map.hasLayer(obj.layer);\r\n\r\n\t\tif (obj.overlay) {\r\n\t\t\tinput = document.createElement('input');\r\n\t\t\tinput.type = 'checkbox';\r\n\t\t\tinput.className = 'leaflet-control-layers-selector';\r\n\t\t\tinput.defaultChecked = checked;\r\n\t\t} else {\r\n\t\t\tinput = this._createRadioElement('leaflet-base-layers', checked);\r\n\t\t}\r\n\r\n\t\tinput.layerId = L.stamp(obj.layer);\r\n\r\n\t\tL.DomEvent.on(input, 'click', this._onInputClick, this);\r\n\r\n\t\tvar name = document.createElement('span');\r\n\t\tname.innerHTML = ' ' + obj.name;\r\n\r\n\t\tlabel.appendChild(input);\r\n\t\tlabel.appendChild(name);\r\n\r\n\t\tvar container = obj.overlay ? this._overlaysList : this._baseLayersList;\r\n\t\tcontainer.appendChild(label);\r\n\r\n\t\treturn label;\r\n\t},\r\n\r\n\t_onInputClick: function () {\r\n\t\tvar i, input, obj,\r\n\t\t    inputs = this._form.getElementsByTagName('input'),\r\n\t\t    inputsLen = inputs.length;\r\n\r\n\t\tthis._handlingClick = true;\r\n\r\n\t\tfor (i = 0; i < inputsLen; i++) {\r\n\t\t\tinput = inputs[i];\r\n\t\t\tobj = this._layers[input.layerId];\r\n\r\n\t\t\tif (input.checked && !this._map.hasLayer(obj.layer)) {\r\n\t\t\t\tthis._map.addLayer(obj.layer);\r\n\r\n\t\t\t} else if (!input.checked && this._map.hasLayer(obj.layer)) {\r\n\t\t\t\tthis._map.removeLayer(obj.layer);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._handlingClick = false;\r\n\r\n\t\tthis._refocusOnMap();\r\n\t},\r\n\r\n\t_expand: function () {\r\n\t\tL.DomUtil.addClass(this._container, 'leaflet-control-layers-expanded');\r\n\t},\r\n\r\n\t_collapse: function () {\r\n\t\tthis._container.className = this._container.className.replace(' leaflet-control-layers-expanded', '');\r\n\t}\r\n});\r\n\r\nL.control.layers = function (baseLayers, overlays, options) {\r\n\treturn new L.Control.Layers(baseLayers, overlays, options);\r\n};\r\n\n\n/*\n * L.PosAnimation is used by Leaflet internally for pan animations.\n */\n\nL.PosAnimation = L.Class.extend({\n\tincludes: L.Mixin.Events,\n\n\trun: function (el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])\n\t\tthis.stop();\n\n\t\tthis._el = el;\n\t\tthis._inProgress = true;\n\t\tthis._newPos = newPos;\n\n\t\tthis.fire('start');\n\n\t\tel.style[L.DomUtil.TRANSITION] = 'all ' + (duration || 0.25) +\n\t\t        's cubic-bezier(0,0,' + (easeLinearity || 0.5) + ',1)';\n\n\t\tL.DomEvent.on(el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);\n\t\tL.DomUtil.setPosition(el, newPos);\n\n\t\t// toggle reflow, Chrome flickers for some reason if you don't do this\n\t\tL.Util.falseFn(el.offsetWidth);\n\n\t\t// there's no native way to track value updates of transitioned properties, so we imitate this\n\t\tthis._stepTimer = setInterval(L.bind(this._onStep, this), 50);\n\t},\n\n\tstop: function () {\n\t\tif (!this._inProgress) { return; }\n\n\t\t// if we just removed the transition property, the element would jump to its final position,\n\t\t// so we need to make it stay at the current position\n\n\t\tL.DomUtil.setPosition(this._el, this._getPos());\n\t\tthis._onTransitionEnd();\n\t\tL.Util.falseFn(this._el.offsetWidth); // force reflow in case we are about to start a new animation\n\t},\n\n\t_onStep: function () {\n\t\tvar stepPos = this._getPos();\n\t\tif (!stepPos) {\n\t\t\tthis._onTransitionEnd();\n\t\t\treturn;\n\t\t}\n\t\t// jshint camelcase: false\n\t\t// make L.DomUtil.getPosition return intermediate position value during animation\n\t\tthis._el._leaflet_pos = stepPos;\n\n\t\tthis.fire('step');\n\t},\n\n\t// you can't easily get intermediate values of properties animated with CSS3 Transitions,\n\t// we need to parse computed style (in case of transform it returns matrix string)\n\n\t_transformRe: /([-+]?(?:\\d*\\.)?\\d+)\\D*, ([-+]?(?:\\d*\\.)?\\d+)\\D*\\)/,\n\n\t_getPos: function () {\n\t\tvar left, top, matches,\n\t\t    el = this._el,\n\t\t    style = window.getComputedStyle(el);\n\n\t\tif (L.Browser.any3d) {\n\t\t\tmatches = style[L.DomUtil.TRANSFORM].match(this._transformRe);\n\t\t\tif (!matches) { return; }\n\t\t\tleft = parseFloat(matches[1]);\n\t\t\ttop  = parseFloat(matches[2]);\n\t\t} else {\n\t\t\tleft = parseFloat(style.left);\n\t\t\ttop  = parseFloat(style.top);\n\t\t}\n\n\t\treturn new L.Point(left, top, true);\n\t},\n\n\t_onTransitionEnd: function () {\n\t\tL.DomEvent.off(this._el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);\n\n\t\tif (!this._inProgress) { return; }\n\t\tthis._inProgress = false;\n\n\t\tthis._el.style[L.DomUtil.TRANSITION] = '';\n\n\t\t// jshint camelcase: false\n\t\t// make sure L.DomUtil.getPosition returns the final position value after animation\n\t\tthis._el._leaflet_pos = this._newPos;\n\n\t\tclearInterval(this._stepTimer);\n\n\t\tthis.fire('step').fire('end');\n\t}\n\n});\n\n\n/*\n * Extends L.Map to handle panning animations.\n */\n\nL.Map.include({\n\n\tsetView: function (center, zoom, options) {\n\n\t\tzoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);\n\t\tcenter = this._limitCenter(L.latLng(center), zoom, this.options.maxBounds);\n\t\toptions = options || {};\n\n\t\tif (this._panAnim) {\n\t\t\tthis._panAnim.stop();\n\t\t}\n\n\t\tif (this._loaded && !options.reset && options !== true) {\n\n\t\t\tif (options.animate !== undefined) {\n\t\t\t\toptions.zoom = L.extend({animate: options.animate}, options.zoom);\n\t\t\t\toptions.pan = L.extend({animate: options.animate}, options.pan);\n\t\t\t}\n\n\t\t\t// try animating pan or zoom\n\t\t\tvar animated = (this._zoom !== zoom) ?\n\t\t\t\tthis._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :\n\t\t\t\tthis._tryAnimatedPan(center, options.pan);\n\n\t\t\tif (animated) {\n\t\t\t\t// prevent resize handler call, the view will refresh after animation anyway\n\t\t\t\tclearTimeout(this._sizeTimer);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\n\t\t// animation didn't start, just reset the map view\n\t\tthis._resetView(center, zoom);\n\n\t\treturn this;\n\t},\n\n\tpanBy: function (offset, options) {\n\t\toffset = L.point(offset).round();\n\t\toptions = options || {};\n\n\t\tif (!offset.x && !offset.y) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif (!this._panAnim) {\n\t\t\tthis._panAnim = new L.PosAnimation();\n\n\t\t\tthis._panAnim.on({\n\t\t\t\t'step': this._onPanTransitionStep,\n\t\t\t\t'end': this._onPanTransitionEnd\n\t\t\t}, this);\n\t\t}\n\n\t\t// don't fire movestart if animating inertia\n\t\tif (!options.noMoveStart) {\n\t\t\tthis.fire('movestart');\n\t\t}\n\n\t\t// animate pan unless animate: false specified\n\t\tif (options.animate !== false) {\n\t\t\tL.DomUtil.addClass(this._mapPane, 'leaflet-pan-anim');\n\n\t\t\tvar newPos = this._getMapPanePos().subtract(offset);\n\t\t\tthis._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);\n\t\t} else {\n\t\t\tthis._rawPanBy(offset);\n\t\t\tthis.fire('move').fire('moveend');\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t_onPanTransitionStep: function () {\n\t\tthis.fire('move');\n\t},\n\n\t_onPanTransitionEnd: function () {\n\t\tL.DomUtil.removeClass(this._mapPane, 'leaflet-pan-anim');\n\t\tthis.fire('moveend');\n\t},\n\n\t_tryAnimatedPan: function (center, options) {\n\t\t// difference between the new and current centers in pixels\n\t\tvar offset = this._getCenterOffset(center)._floor();\n\n\t\t// don't animate too far unless animate: true specified in options\n\t\tif ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }\n\n\t\tthis.panBy(offset, options);\n\n\t\treturn true;\n\t}\n});\n\n\n/*\n * L.PosAnimation fallback implementation that powers Leaflet pan animations\n * in browsers that don't support CSS3 Transitions.\n */\n\nL.PosAnimation = L.DomUtil.TRANSITION ? L.PosAnimation : L.PosAnimation.extend({\n\n\trun: function (el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])\n\t\tthis.stop();\n\n\t\tthis._el = el;\n\t\tthis._inProgress = true;\n\t\tthis._duration = duration || 0.25;\n\t\tthis._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);\n\n\t\tthis._startPos = L.DomUtil.getPosition(el);\n\t\tthis._offset = newPos.subtract(this._startPos);\n\t\tthis._startTime = +new Date();\n\n\t\tthis.fire('start');\n\n\t\tthis._animate();\n\t},\n\n\tstop: function () {\n\t\tif (!this._inProgress) { return; }\n\n\t\tthis._step();\n\t\tthis._complete();\n\t},\n\n\t_animate: function () {\n\t\t// animation loop\n\t\tthis._animId = L.Util.requestAnimFrame(this._animate, this);\n\t\tthis._step();\n\t},\n\n\t_step: function () {\n\t\tvar elapsed = (+new Date()) - this._startTime,\n\t\t    duration = this._duration * 1000;\n\n\t\tif (elapsed < duration) {\n\t\t\tthis._runFrame(this._easeOut(elapsed / duration));\n\t\t} else {\n\t\t\tthis._runFrame(1);\n\t\t\tthis._complete();\n\t\t}\n\t},\n\n\t_runFrame: function (progress) {\n\t\tvar pos = this._startPos.add(this._offset.multiplyBy(progress));\n\t\tL.DomUtil.setPosition(this._el, pos);\n\n\t\tthis.fire('step');\n\t},\n\n\t_complete: function () {\n\t\tL.Util.cancelAnimFrame(this._animId);\n\n\t\tthis._inProgress = false;\n\t\tthis.fire('end');\n\t},\n\n\t_easeOut: function (t) {\n\t\treturn 1 - Math.pow(1 - t, this._easeOutPower);\n\t}\n});\n\n\n/*\n * Extends L.Map to handle zoom animations.\n */\n\nL.Map.mergeOptions({\n\tzoomAnimation: true,\n\tzoomAnimationThreshold: 4\n});\n\nif (L.DomUtil.TRANSITION) {\n\n\tL.Map.addInitHook(function () {\n\t\t// don't animate on browsers without hardware-accelerated transitions or old Android/Opera\n\t\tthis._zoomAnimated = this.options.zoomAnimation && L.DomUtil.TRANSITION &&\n\t\t\t\tL.Browser.any3d && !L.Browser.android23 && !L.Browser.mobileOpera;\n\n\t\t// zoom transitions run with the same duration for all layers, so if one of transitionend events\n\t\t// happens after starting zoom animation (propagating to the map pane), we know that it ended globally\n\t\tif (this._zoomAnimated) {\n\t\t\tL.DomEvent.on(this._mapPane, L.DomUtil.TRANSITION_END, this._catchTransitionEnd, this);\n\t\t}\n\t});\n}\n\nL.Map.include(!L.DomUtil.TRANSITION ? {} : {\n\n\t_catchTransitionEnd: function (e) {\n\t\tif (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {\n\t\t\tthis._onZoomTransitionEnd();\n\t\t}\n\t},\n\n\t_nothingToAnimate: function () {\n\t\treturn !this._container.getElementsByClassName('leaflet-zoom-animated').length;\n\t},\n\n\t_tryAnimatedZoom: function (center, zoom, options) {\n\n\t\tif (this._animatingZoom) { return true; }\n\n\t\toptions = options || {};\n\n\t\t// don't animate if disabled, not supported or zoom difference is too large\n\t\tif (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||\n\t\t        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }\n\n\t\t// offset is the pixel coords of the zoom origin relative to the current center\n\t\tvar scale = this.getZoomScale(zoom),\n\t\t    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale),\n\t\t\torigin = this._getCenterLayerPoint()._add(offset);\n\n\t\t// don't animate if the zoom origin isn't within one screen from the current center, unless forced\n\t\tif (options.animate !== true && !this.getSize().contains(offset)) { return false; }\n\n\t\tthis\n\t\t    .fire('movestart')\n\t\t    .fire('zoomstart');\n\n\t\tthis._animateZoom(center, zoom, origin, scale, null, true);\n\n\t\treturn true;\n\t},\n\n\t_animateZoom: function (center, zoom, origin, scale, delta, backwards, forTouchZoom) {\n\n\t\tif (!forTouchZoom) {\n\t\t\tthis._animatingZoom = true;\n\t\t}\n\n\t\t// put transform transition on all layers with leaflet-zoom-animated class\n\t\tL.DomUtil.addClass(this._mapPane, 'leaflet-zoom-anim');\n\n\t\t// remember what center/zoom to set after animation\n\t\tthis._animateToCenter = center;\n\t\tthis._animateToZoom = zoom;\n\n\t\t// disable any dragging during animation\n\t\tif (L.Draggable) {\n\t\t\tL.Draggable._disabled = true;\n\t\t}\n\n\t\tL.Util.requestAnimFrame(function () {\n\t\t\tthis.fire('zoomanim', {\n\t\t\t\tcenter: center,\n\t\t\t\tzoom: zoom,\n\t\t\t\torigin: origin,\n\t\t\t\tscale: scale,\n\t\t\t\tdelta: delta,\n\t\t\t\tbackwards: backwards\n\t\t\t});\n\t\t\t// horrible hack to work around a Chrome bug https://github.com/Leaflet/Leaflet/issues/3689\n\t\t\tsetTimeout(L.bind(this._onZoomTransitionEnd, this), 250);\n\t\t}, this);\n\t},\n\n\t_onZoomTransitionEnd: function () {\n\t\tif (!this._animatingZoom) { return; }\n\n\t\tthis._animatingZoom = false;\n\n\t\tL.DomUtil.removeClass(this._mapPane, 'leaflet-zoom-anim');\n\n\t\tL.Util.requestAnimFrame(function () {\n\t\t\tthis._resetView(this._animateToCenter, this._animateToZoom, true, true);\n\n\t\t\tif (L.Draggable) {\n\t\t\t\tL.Draggable._disabled = false;\n\t\t\t}\n\t\t}, this);\n\t}\n});\n\n\n/*\n\tZoom animation logic for L.TileLayer.\n*/\n\nL.TileLayer.include({\n\t_animateZoom: function (e) {\n\t\tif (!this._animating) {\n\t\t\tthis._animating = true;\n\t\t\tthis._prepareBgBuffer();\n\t\t}\n\n\t\tvar bg = this._bgBuffer,\n\t\t    transform = L.DomUtil.TRANSFORM,\n\t\t    initialTransform = e.delta ? L.DomUtil.getTranslateString(e.delta) : bg.style[transform],\n\t\t    scaleStr = L.DomUtil.getScaleString(e.scale, e.origin);\n\n\t\tbg.style[transform] = e.backwards ?\n\t\t\t\tscaleStr + ' ' + initialTransform :\n\t\t\t\tinitialTransform + ' ' + scaleStr;\n\t},\n\n\t_endZoomAnim: function () {\n\t\tvar front = this._tileContainer,\n\t\t    bg = this._bgBuffer;\n\n\t\tfront.style.visibility = '';\n\t\tfront.parentNode.appendChild(front); // Bring to fore\n\n\t\t// force reflow\n\t\tL.Util.falseFn(bg.offsetWidth);\n\n\t\tvar zoom = this._map.getZoom();\n\t\tif (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\n\t\t\tthis._clearBgBuffer();\n\t\t}\n\n\t\tthis._animating = false;\n\t},\n\n\t_clearBgBuffer: function () {\n\t\tvar map = this._map;\n\n\t\tif (map && !map._animatingZoom && !map.touchZoom._zooming) {\n\t\t\tthis._bgBuffer.innerHTML = '';\n\t\t\tthis._bgBuffer.style[L.DomUtil.TRANSFORM] = '';\n\t\t}\n\t},\n\n\t_prepareBgBuffer: function () {\n\n\t\tvar front = this._tileContainer,\n\t\t    bg = this._bgBuffer;\n\n\t\t// if foreground layer doesn't have many tiles but bg layer does,\n\t\t// keep the existing bg layer and just zoom it some more\n\n\t\tvar bgLoaded = this._getLoadedTilesPercentage(bg),\n\t\t    frontLoaded = this._getLoadedTilesPercentage(front);\n\n\t\tif (bg && bgLoaded > 0.5 && frontLoaded < 0.5) {\n\n\t\t\tfront.style.visibility = 'hidden';\n\t\t\tthis._stopLoadingImages(front);\n\t\t\treturn;\n\t\t}\n\n\t\t// prepare the buffer to become the front tile pane\n\t\tbg.style.visibility = 'hidden';\n\t\tbg.style[L.DomUtil.TRANSFORM] = '';\n\n\t\t// switch out the current layer to be the new bg layer (and vice-versa)\n\t\tthis._tileContainer = bg;\n\t\tbg = this._bgBuffer = front;\n\n\t\tthis._stopLoadingImages(bg);\n\n\t\t//prevent bg buffer from clearing right after zoom\n\t\tclearTimeout(this._clearBgBufferTimer);\n\t},\n\n\t_getLoadedTilesPercentage: function (container) {\n\t\tvar tiles = container.getElementsByTagName('img'),\n\t\t    i, len, count = 0;\n\n\t\tfor (i = 0, len = tiles.length; i < len; i++) {\n\t\t\tif (tiles[i].complete) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count / len;\n\t},\n\n\t// stops loading all tiles in the background layer\n\t_stopLoadingImages: function (container) {\n\t\tvar tiles = Array.prototype.slice.call(container.getElementsByTagName('img')),\n\t\t    i, len, tile;\n\n\t\tfor (i = 0, len = tiles.length; i < len; i++) {\n\t\t\ttile = tiles[i];\n\n\t\t\tif (!tile.complete) {\n\t\t\t\ttile.onload = L.Util.falseFn;\n\t\t\t\ttile.onerror = L.Util.falseFn;\n\t\t\t\ttile.src = L.Util.emptyImageUrl;\n\n\t\t\t\ttile.parentNode.removeChild(tile);\n\t\t\t}\n\t\t}\n\t}\n});\n\n\n/*\r\n * Provides L.Map with convenient shortcuts for using browser geolocation features.\r\n */\r\n\r\nL.Map.include({\r\n\t_defaultLocateOptions: {\r\n\t\twatch: false,\r\n\t\tsetView: false,\r\n\t\tmaxZoom: Infinity,\r\n\t\ttimeout: 10000,\r\n\t\tmaximumAge: 0,\r\n\t\tenableHighAccuracy: false\r\n\t},\r\n\r\n\tlocate: function (/*Object*/ options) {\r\n\r\n\t\toptions = this._locateOptions = L.extend(this._defaultLocateOptions, options);\r\n\r\n\t\tif (!navigator.geolocation) {\r\n\t\t\tthis._handleGeolocationError({\r\n\t\t\t\tcode: 0,\r\n\t\t\t\tmessage: 'Geolocation not supported.'\r\n\t\t\t});\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tvar onResponse = L.bind(this._handleGeolocationResponse, this),\r\n\t\t\tonError = L.bind(this._handleGeolocationError, this);\r\n\r\n\t\tif (options.watch) {\r\n\t\t\tthis._locationWatchId =\r\n\t\t\t        navigator.geolocation.watchPosition(onResponse, onError, options);\r\n\t\t} else {\r\n\t\t\tnavigator.geolocation.getCurrentPosition(onResponse, onError, options);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tstopLocate: function () {\r\n\t\tif (navigator.geolocation) {\r\n\t\t\tnavigator.geolocation.clearWatch(this._locationWatchId);\r\n\t\t}\r\n\t\tif (this._locateOptions) {\r\n\t\t\tthis._locateOptions.setView = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_handleGeolocationError: function (error) {\r\n\t\tvar c = error.code,\r\n\t\t    message = error.message ||\r\n\t\t            (c === 1 ? 'permission denied' :\r\n\t\t            (c === 2 ? 'position unavailable' : 'timeout'));\r\n\r\n\t\tif (this._locateOptions.setView && !this._loaded) {\r\n\t\t\tthis.fitWorld();\r\n\t\t}\r\n\r\n\t\tthis.fire('locationerror', {\r\n\t\t\tcode: c,\r\n\t\t\tmessage: 'Geolocation error: ' + message + '.'\r\n\t\t});\r\n\t},\r\n\r\n\t_handleGeolocationResponse: function (pos) {\r\n\t\tvar lat = pos.coords.latitude,\r\n\t\t    lng = pos.coords.longitude,\r\n\t\t    latlng = new L.LatLng(lat, lng),\r\n\r\n\t\t    latAccuracy = 180 * pos.coords.accuracy / 40075017,\r\n\t\t    lngAccuracy = latAccuracy / Math.cos(L.LatLng.DEG_TO_RAD * lat),\r\n\r\n\t\t    bounds = L.latLngBounds(\r\n\t\t            [lat - latAccuracy, lng - lngAccuracy],\r\n\t\t            [lat + latAccuracy, lng + lngAccuracy]),\r\n\r\n\t\t    options = this._locateOptions;\r\n\r\n\t\tif (options.setView) {\r\n\t\t\tvar zoom = Math.min(this.getBoundsZoom(bounds), options.maxZoom);\r\n\t\t\tthis.setView(latlng, zoom);\r\n\t\t}\r\n\r\n\t\tvar data = {\r\n\t\t\tlatlng: latlng,\r\n\t\t\tbounds: bounds,\r\n\t\t\ttimestamp: pos.timestamp\r\n\t\t};\r\n\r\n\t\tfor (var i in pos.coords) {\r\n\t\t\tif (typeof pos.coords[i] === 'number') {\r\n\t\t\t\tdata[i] = pos.coords[i];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.fire('locationfound', data);\r\n\t}\r\n});\r\n\n\n}(window, document));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/leaflet/dist/leaflet-src.js\n ** module id = 19\n ** module chunks = 0\n **/","'use strict';\n\nvar $ = require('jquery');\n\nfunction FlyoutRenderer() {\n\n  var FLYOUT_WINDOW_PADDING = 22;\n  var FLYOUT_BOTTOM_PADDING = 1;\n  var FLYOUT_TOP_PADDING = 10;\n\n  var _window = $(window);\n  var _flyout;\n  var _flyoutContent;\n  var _flyoutHint;\n\n  _renderFlyoutTemplate();\n\n  _hideFlyout();\n\n  /**\n   * Public methods\n   */\n\n  this.render = function(options) {\n    _renderFlyoutData(options);\n  };\n\n  this.clear = function() {\n    _hideFlyout();\n  };\n\n  /**\n   * Private methods\n   */\n\n  function _renderFlyoutTemplate() {\n\n    var flyoutContent = $(\n      '<div>',\n      {\n        'class': 'socrata-flyout-content'\n      }\n    );\n\n    var flyoutHint = $(\n      '<div>',\n      {\n        'class': 'socrata-flyout-hint'\n      }\n    );\n\n    var flyout = $(\n      '<div>',\n      {\n        id: 'socrata-flyout'\n      }\n    ).append([\n      flyoutContent,\n      flyoutHint\n    ]);\n\n    _flyout = flyout;\n    _flyoutContent = flyoutContent;\n    _flyoutHint = flyoutHint;\n\n    $('body').append(flyout);\n  }\n\n  /**\n   * This is a jQuery event handler that responds to `.trigger()`, so the\n   * second argument is expected and contains the payload of the event.\n   */\n  function _renderFlyoutData(options) {\n\n    var content = options.content;\n    var flyoutOffset = options.flyoutOffset;\n    var belowTarget = options.belowTarget;\n    var rightSideHint = options.rightSideHint;\n    var windowWidth;\n    var flyoutWidth;\n    var flyoutHeight;\n    var flyoutHintHeight;\n    var flyoutStyles = {\n      left: '',\n      top: ''\n    };\n    var flyoutHintStyles = {\n      left: '',\n      top: ''\n    };\n    var flyoutTargetBoundingClientRect;\n    var flyoutRightEdge;\n    var windowRightEdgeMinusPadding;\n\n    // Reset the left position so that width calculations are not\n    // affected by text flow.\n    _flyout.css('left', 0);\n    _flyoutContent.html(content);\n\n    // Use $(window).width() instead of window.innerWidth because\n    // the latter includes scrollbars depending on the browser.\n    windowWidth = _window.width();\n    flyoutWidth = _flyout.outerWidth(true);\n    flyoutHeight = _flyout.outerHeight(true);\n    flyoutHintHeight = _flyoutHint.outerHeight(true);\n\n    // Set the left and top of flyout depending on its type\n    if (flyoutOffset) {\n\n      // Position the flyout so that the hint points to the current\n      // location of the cursor.\n      flyoutStyles.left = flyoutOffset.left;\n      flyoutStyles.top = flyoutOffset.top -\n        flyoutHeight -\n        flyoutHintHeight -\n        FLYOUT_BOTTOM_PADDING;\n\n    } else {\n\n      flyoutTargetBoundingClientRect = options.element.getBoundingClientRect();\n\n      // Set the left of the flyout to the exact middle of the\n      // target element.\n      flyoutStyles.left = flyoutTargetBoundingClientRect.left +\n        (flyoutTargetBoundingClientRect.width / 2);\n\n      // Set the top of the flyout, depending on whether the flyout\n      // should be positioned above or below the target.\n      if (belowTarget) {\n\n        flyoutStyles.top = flyoutTargetBoundingClientRect.bottom +\n          flyoutHintHeight +\n          FLYOUT_TOP_PADDING;\n\n      } else {\n\n        flyoutStyles.top = flyoutTargetBoundingClientRect.top -\n          (flyoutHeight + flyoutHintHeight) -\n          FLYOUT_BOTTOM_PADDING;\n      }\n    }\n\n    flyoutRightEdge = flyoutStyles.left + flyoutWidth;\n    windowRightEdgeMinusPadding = windowWidth - FLYOUT_WINDOW_PADDING;\n\n    // If the right edge of the flyout will be drawn off the right edge of\n    // the screen, move the flyout to the left until its right edge is flush\n    // with the right edge of the screen less the FLYOUT_WINDOW_PADDING.\n    if (flyoutRightEdge >= windowRightEdgeMinusPadding) {\n\n      // Adjust the position of the hint first so that it remains centered\n      // over the element.\n      flyoutHintStyles.left = flyoutStyles.left -\n        (windowRightEdgeMinusPadding - flyoutWidth);\n      // Then move the left edge of the flyout content over until it is\n      // correctly positioned.\n      flyoutStyles.left -= (flyoutRightEdge - windowRightEdgeMinusPadding);\n    }\n\n    // If hint is at least halfway across the flyout, change its orientation.\n    if (flyoutHintStyles.left > flyoutWidth / 2) {\n\n      flyoutHintStyles.left = flyoutHintStyles.left - flyoutHintHeight;\n      rightSideHint = true;\n    }\n\n    // If top of flyout is cut off by window, top-align the flyout.\n    if (flyoutStyles.top < 0) {\n      flyoutStyles.top = 0;\n    }\n\n    // Apply computed styles to the flyout hint.\n    _flyoutHint.css(flyoutHintStyles);\n\n    _flyout.\n      toggleClass('southwest', !rightSideHint && !belowTarget).\n      toggleClass('southeast', rightSideHint && !belowTarget).\n      toggleClass('northwest', !rightSideHint && belowTarget).\n      toggleClass('northeast', rightSideHint && belowTarget).\n      css(flyoutStyles);\n\n    _showFlyout();\n  }\n\n  function _showFlyout() {\n    _flyout.addClass('visible');\n  }\n\n  function _hideFlyout() {\n    _flyout.removeClass('visible');\n  }\n}\n\nmodule.exports = FlyoutRenderer;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/views/FlyoutRenderer.js\n ** module id = 20\n ** module chunks = 0\n **/","'use strict';\n\nvar utils = require('socrata-utils');\nvar _ = require('lodash');\nvar $ = require('jquery');\n\nvar ROW_INSPECTOR_WIDTH = 350;\nvar ROW_INSPECTOR_MAX_CONTENT_HEIGHT = 250;\nvar ROW_INSPECTOR_WINDOW_PADDING = 22;\nvar ROW_INSPECTOR_PADDING_COMPENSATION = 3;\nvar ROW_INSPECTOR_HINT_WIDTH = 10;\n\nvar ROW_INSPECTOR_DEFAULT_TRANSLATIONS = {\n  previous: 'Previous',\n  next: 'Next',\n  defaultLabelUnit: 'Row',\n  showing: 'Showing {0}',\n  paging: '{0} of {1}'\n};\n\nvar _$rowInspectorContainer;\nvar _$rowInspectorToolPanel;\nvar _$rowInspectorContent;\nvar _$rowInspectorToolPanelHint;\nvar _$paginationButtonPrevious;\nvar _$paginationButtonNext;\nvar _$pagingPanel;\nvar _$paginationMessage;\nvar _$paginationPosition;\nvar _$pendingContent;\nvar _$errorContent;\nvar _$stickyBorderBottom;\n\nvar _config;\nvar _state;\n\n/**\n * @function setup\n * @description\n *\n * Adds JavaScript functionality to a row inspector template.\n *\n * In this particular case, the row inspector is a flyout panel\n * that visualizes tabular data. It includes paging between\n * rows of the data, and showing per-column visualizations of\n * the row data.\n *\n * Events and Interaction:\n *\n *   - Example with Successful Payload:\n *\n *     { error: false,\n *       message: null,\n *       position: {pageX: 0, pageY: 0}, // Must be numbers\n *       labelUnit: null, // or a string literal\n *       data: [ // This attribute is optional, a spinner will be shown if missing/null.\n *         [ // Represents a row\n *           {column: 'columnName', value: 'columnValue' }, // Represents a column.\n *           ...\n *         ],\n *         ...\n *       ]\n *     }\n *\n *   - Example with Error Payload:\n *\n *     { error: true,\n *       message: 'There was an error',\n *       position: {pageX: 0, pageY: 0} // Must be numbers\n *     }\n *\n *   Event Names:\n *\n *   SOCRATA_VISUALIZATION_ROW_INSPECTOR_SHOW:\n *   - Places the row inspector where the mouse was clicked.\n *   - Optionally, Accepts a payload (See example payload)\n *   SOCRATA_VISUALIZATION_ROW_INSPECTOR_UPDATE:\n *   - Accepts a payload and loads the first row into the view.\n *   SOCRATA_VISUALIZATION_ROW_INSPECTOR_HIDE:\n *   - Hides the row inspector.\n *\n * @param {Object} config - An object containing translations in a localization-keyed subobject.\n *\n * Example Configuration:\n *   config = {\n *     localization: {\n *       previous: 'PREVIOUS'\n *     }\n *   }\n *\n * These translations will be merged into the default translations.\n * For other available keys, see ROW_INSPECTOR_DEFAULT_TRANSLATIONS in this file.\n */\nfunction setup(config) {\n  _config = _.cloneDeep(config || {});\n\n  _config.localization = _config.localization || {};\n  _config.localization = _.merge({}, ROW_INSPECTOR_DEFAULT_TRANSLATIONS, _config.localization);\n\n  if ($('#socrata-row-inspector').length === 0) {\n\n    _$rowInspectorContainer = $(\n      [\n        '<div id=\"socrata-row-inspector\">',\n          '<div class=\"tool-panel\">',\n            '<div class=\"tool-panel-main\">',\n              '<div class=\"icon-close\"></div>',\n              '<div class=\"sticky-border\"></div>',\n              '<div class=\"tool-panel-inner-container\">',\n                '<!-- Successful query response -->',\n                '<div class=\"row-inspector-content\">',\n                  '<div class=\"row-data-item\">',\n                    '<span class=\"name\"></span>',\n                    '<span class=\"value\"></span>',\n                  '</div>',\n                '</div>',\n                '<!-- Loading spinner while query pending-->',\n                '<div class=\"pending-content\"></div>',\n                '<!-- Error message if row query unsuccessful -->',\n                '<div class=\"error-content\">',\n                  '<div class=\"icon-warning\"></div>',\n                  '<div class=\"error-message\"></div>',\n                '</div>',\n              '</div>',\n              '<div class=\"sticky-border bottom\"></div>',\n              '<div class=\"paging-panel\">',\n                '<button type=\"button\" class=\"l-to-r paging-btn action-btn previous\">',\n                  '<span class=\"caret\"></span>',\n                '</button>',\n                '<button type=\"button\" class=\"r-to-l paging-btn action-btn next\">',\n                  '<span class=\"caret\"></span>',\n                '</button>',\n                '<div class=\"paging-info\">',\n                  '<div class=\"message\">',\n                    '<div></div>',\n                    '<div></div>',\n                  '</div>',\n                '</div>',\n              '</div>',\n              '<div class=\"tool-panel-hint\"></div>',\n            '</div>',\n          '</div>',\n        '</div>'\n      ].join('')\n    );\n\n    $('body').append(_$rowInspectorContainer);\n\n  } else {\n\n    _$rowInspectorContainer = $('#socrata-row-inspector');\n\n  }\n\n  // Grab all children that we run operations on.\n  _$rowInspectorToolPanel = _$rowInspectorContainer.find('.tool-panel');\n  _$rowInspectorContent = _$rowInspectorContainer.find('.row-inspector-content');\n  _$pendingContent = _$rowInspectorContainer.find('.pending-content');\n  _$errorContent = _$rowInspectorContainer.find('.error-content');\n  _$rowInspectorToolPanelHint = _$rowInspectorContainer.find('.tool-panel-hint');\n  _$paginationButtonPrevious = _$rowInspectorContainer.find('.paging-btn.previous');\n  _$paginationButtonNext = _$rowInspectorContainer.find('.paging-btn.next');\n  _$pagingPanel = _$rowInspectorContainer.find('.paging-panel');\n  _$paginationMessage = _$rowInspectorContainer.find('.paging-info .message div:first-child');\n  _$paginationPosition = _$rowInspectorContainer.find('.paging-info .message div + div');\n  _$stickyBorderBottom = _$rowInspectorContainer.find('.sticky-border.bottom');\n\n  // Add translations\n  _$paginationButtonPrevious.find('span').text(_config.localization.previous);\n  _$paginationButtonNext.find('span').text(_config.localization.next);\n\n  // rowInspectorSetup can be called multiple times\n  // but we only want our bindings set once.\n  _attachEventsOnce();\n}\n\nvar _attachEventsOnce = _.once(function() {\n  var $document = $(document);\n  var $body = $(document.body);\n\n  $body.on('SOCRATA_VISUALIZATION_ROW_INSPECTOR_SHOW', function(event, jQueryPayload) {\n    // These events are CustomEvents. jQuery < 3.0 does not understand that\n    // event.detail should be passed as an argument to the handler.\n    var payload = jQueryPayload || _.get(event, 'originalEvent.detail');\n\n    // Defer, otherwise the click that triggered this event will immediately close the flannel.\n    _.defer(_show);\n    _setState(payload);\n  });\n\n  $body.on('SOCRATA_VISUALIZATION_ROW_INSPECTOR_UPDATE', function(event, jQueryPayload) {\n    // These events are CustomEvents. jQuery < 3.0 does not understand that\n    // event.detail should be passed as an argument to the handler.\n    var payload = jQueryPayload || _.get(event, 'originalEvent.detail');\n\n    if (_.isUndefined(payload.position)) {\n      // Reuse position from SOCRATA_VISUALIZATION_ROW_INSPECTOR_SHOW if not specified.\n      payload.position = _state.position;\n    }\n\n    _setState(payload);\n  });\n\n  $body.on('SOCRATA_VISUALIZATION_ROW_INSPECTOR_HIDE', _hide);\n  $body.on('SOCRATA_VISUALIZATION_ROW_INSPECTOR_ADJUST_POSITION', _render);\n\n  $document.on('click', _captureLeftClickAndHide);\n  $document.on('keydown', _captureEscapeAndHide);\n\n  _$paginationButtonPrevious.on('click', _decrementPageByOne);\n  _$paginationButtonNext.on('click', _incrementPageByOne);\n});\n\nfunction _captureLeftClickAndHide(event) {\n  var $target = $(event.target);\n  var isLeftClick = event.which === 1;\n  var isOutsideOfRowInspector = $target.closest(_$rowInspectorContainer).length === 0;\n  var isIconClose = $target.is('.icon-close');\n\n  if (isLeftClick && (isOutsideOfRowInspector || isIconClose)) {\n    _hide();\n  }\n}\n\nfunction _captureEscapeAndHide(event) {\n  if (event.which === 27) {\n    _hide();\n  }\n}\n\nfunction _incrementPageByOne() {\n  _state.pageIndex = Math.min(_state.pageIndex + 1, _state.rows.length - 1);\n  _render();\n}\n\nfunction _decrementPageByOne() {\n  _state.pageIndex = Math.max(0, _state.pageIndex - 1);\n  _render();\n}\n\nfunction _adjustPosition(position) {\n  var hintRightOffset;\n  var hintPositionFromRight;\n  var distanceOutOfView = $(window).scrollTop();\n  var xPosition = position.pageX;\n  var yPosition = position.pageY;\n  var windowWidth = $(window).width();\n  var windowHeight = $(window).innerHeight();\n  var positionFlannelEast = false;\n  var positionFlannelNorth = false;\n\n  var abutsRightEdge = windowWidth <\n    (xPosition + ROW_INSPECTOR_WIDTH + ROW_INSPECTOR_WINDOW_PADDING);\n\n  var panelPositionStyle = {left: '', right: ''};\n  var hintPositionStyle = {left: '', right: ''};\n\n  panelPositionStyle.top = '{0}px'.format(yPosition);\n\n  // Display flannel above clicked point if the point is more than halfway\n  // down the window viewport. Else display flannel below the point.\n  positionFlannelNorth = (yPosition - distanceOutOfView) < (windowHeight / 2);\n\n  if (abutsRightEdge) {\n    positionFlannelEast = xPosition + (ROW_INSPECTOR_WIDTH / 2) >\n      windowWidth - (ROW_INSPECTOR_WINDOW_PADDING + ROW_INSPECTOR_PADDING_COMPENSATION);\n\n    panelPositionStyle.right = '{0}px'.format(\n      ROW_INSPECTOR_WIDTH + ROW_INSPECTOR_PADDING_COMPENSATION + ROW_INSPECTOR_WINDOW_PADDING\n    );\n\n    hintRightOffset = xPosition + ROW_INSPECTOR_WINDOW_PADDING +\n      (positionFlannelEast ? 0 : ROW_INSPECTOR_HINT_WIDTH);\n    hintPositionFromRight = Math.max(0, windowWidth - hintRightOffset);\n\n    hintPositionStyle.right = '{0}px'.format(hintPositionFromRight);\n    hintPositionStyle.left = 'auto';\n  } else {\n    panelPositionStyle.left = '{0}px'.format(xPosition);\n    positionFlannelEast = false;\n  }\n\n  _$rowInspectorToolPanel.css(panelPositionStyle);\n  _$rowInspectorToolPanelHint.css(hintPositionStyle);\n  _$rowInspectorToolPanel.toggleClass('west', !positionFlannelEast);\n  _$rowInspectorToolPanel.toggleClass('east', positionFlannelEast);\n  _$rowInspectorToolPanel.toggleClass('south', !positionFlannelNorth);\n  _$rowInspectorToolPanel.toggleClass('north', positionFlannelNorth);\n}\n\n\nfunction _render() {\n  var rows = _state.rows;\n  var position = _state.position;\n  var hasRows = Array.isArray(rows) && rows.length;\n  var isScrollable;\n  var scrollingElement = _$rowInspectorContainer.find('.tool-panel-inner-container');\n\n  // Set position\n  _adjustPosition(position);\n\n  // Set initial paging button states\n  _$paginationButtonPrevious.prop('disabled', true);\n  _$paginationButtonNext.prop('disabled', true);\n\n  // Conditionally hide the pending content\n  _$pendingContent.toggleClass('visible', !hasRows && !_state.error);\n\n  _renderPage();\n  _renderPagination();\n  _renderError();\n\n  isScrollable = _$rowInspectorContent.innerHeight() >\n    ROW_INSPECTOR_MAX_CONTENT_HEIGHT;\n\n  utils.isolateScrolling(scrollingElement, isScrollable);\n}\n\nfunction _renderError() {\n  var message = _state.message;\n  var $errorMessage = _$rowInspectorContainer.find('.error-message');\n\n  $errorMessage.text(message);\n  _$errorContent.toggleClass('visible', _state.error);\n}\n\nfunction _renderPage() {\n  var row = _.get(_state, ['rows', _state.pageIndex]);\n  var title = _.get(_state, ['titles', _state.pageIndex]);\n\n  _$rowInspectorContent.empty();\n\n  // We may not have a row to render, but we still want to\n  // render pagination and clean out a previously-rendered page.\n  if (!row) {\n    return;\n  }\n\n  utils.assert(Array.isArray(row), 'rowInspector data must be composed of an array of arrays');\n  utils.assert(row.length > 0, 'This row is empty.');\n\n  if (title) {\n    _$rowInspectorContent.append('<h3 class=\"row-inspector-title\">{0}</h3>'.format(title));\n  }\n\n  row.forEach(function(columnValue) {\n    var $rowDataItem = $('<div>', {'class': 'row-data-item'});\n    var $name = $('<span>', {'class': 'name'});\n    var $value = $('<span>', {'class': 'value'});\n\n    utils.assertHasProperties(columnValue, 'column', 'value');\n\n    $name.text(columnValue.column);\n    $value.text(columnValue.value);\n\n    $rowDataItem.append($name).append($value);\n    _$rowInspectorContent.append($rowDataItem);\n  });\n}\n\nfunction _renderPagination() {\n  var numRows = _.get(_state, 'rows.length');\n  var labelUnit = _state.labelUnit;\n\n  if (numRows > 1) {\n    _$paginationMessage.text(_config.localization.showing.format(labelUnit));\n    _$paginationPosition.text(_config.localization.paging.format(_state.pageIndex + 1, numRows));\n    _$paginationButtonPrevious.prop('disabled', _state.pageIndex === 0);\n    _$paginationButtonNext.prop('disabled', _state.pageIndex === numRows - 1);\n\n    _$pagingPanel.addClass('visible');\n    _$stickyBorderBottom.css('bottom', _$pagingPanel.outerHeight());\n  } else {\n    _$pagingPanel.removeClass('visible');\n    _$stickyBorderBottom.css('bottom', 0);\n  }\n}\n\nfunction _show() {\n  _$rowInspectorContainer.addClass('visible');\n}\n\nfunction _hide() {\n  _$rowInspectorContainer.removeClass('visible');\n}\n\nfunction _setState(payload) {\n  utils.assertIsOneOfTypes(payload, 'object');\n\n  utils.assertHasProperties(payload, 'position', 'error');\n  utils.assertHasProperties(payload.position, 'pageX', 'pageY');\n\n  if (payload.data) {\n    utils.assert(_.isArray(payload.data), 'rowInspector row data must be an array');\n  }\n\n  if (payload.titles) {\n    utils.assert(_.isArray(payload.titles), 'rowInspector title data must be an array');\n  }\n\n  _state = {\n    rows: payload.error ? null : payload.data,\n    titles: payload.error ? null : payload.titles,\n    labelUnit: payload.labelUnit || _config.localization.defaultLabelUnit,\n    error: payload.error,\n    message: payload.message,\n    position: payload.position,\n    pageIndex: 0\n  };\n\n  _render();\n}\n\nmodule.exports = {\n  setup: setup\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/views/RowInspector.js\n ** module id = 21\n ** module chunks = 0\n **/","'use strict';\n\nvar GeospaceDataProvider = require('./GeospaceDataProvider');\nvar MetadataProvider = require('./MetadataProvider');\nvar SoqlDataProvider = require('./SoqlDataProvider');\nvar TileserverDataProvider = require('./TileserverDataProvider');\nvar VectorTileManager = require('./VectorTileManager');\n\nmodule.exports = {\n  GeospaceDataProvider: GeospaceDataProvider,\n  MetadataProvider: MetadataProvider,\n  SoqlDataProvider: SoqlDataProvider,\n  TileserverDataProvider: TileserverDataProvider,\n  VectorTileManager: VectorTileManager\n};\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/dataProviders/index.js\n ** module id = 22\n ** module chunks = 0\n **/","'use strict';\n\nvar utils = require('socrata-utils');\nvar DataProvider = require('./DataProvider');\nvar _ = require('lodash');\n\nfunction GeospaceDataProvider(config) {\n\n  _.extend(this, new DataProvider(config));\n\n  utils.assertHasProperty(config, 'domain');\n  utils.assertHasProperty(config, 'datasetUid');\n\n  utils.assertIsOneOfTypes(config.domain, 'string');\n  utils.assertIsOneOfTypes(config.datasetUid, 'string');\n\n  /**\n   * Public methods\n   */\n\n  this.getFeatureExtent = function(columnName) {\n    var url = 'https://{0}/resource/{1}.json?$select=extent({2})'.format(\n      this.getConfigurationProperty('domain'),\n      this.getConfigurationProperty('datasetUid'),\n      columnName\n    );\n    var headers = {\n      Accept: 'application/json'\n    };\n\n    return (\n      new Promise(function(resolve, reject) {\n        var xhr = new XMLHttpRequest();\n\n        function onFail() {\n          var error;\n\n          try {\n            error = JSON.parse(xhr.responseText);\n          } catch (e) {\n            console.log(e);\n            error = xhr.statusText;\n          }\n\n          return reject({\n            status: parseInt(xhr.status, 10),\n            message: xhr.statusText,\n            soqlError: error\n          });\n        }\n\n        xhr.onload = function() {\n          var status = parseInt(xhr.status, 10);\n\n          if (status === 200) {\n\n            try {\n              var responseTextWithoutNewlines = xhr.\n                responseText.\n                replace(/\\n/g, '');\n              var coordinates = _.get(\n                JSON.parse(responseTextWithoutNewlines),\n                '[0].extent_{0}.coordinates[0][0]'.format(columnName)\n              );\n\n              if (!_.isUndefined(coordinates)) {\n\n                return resolve({\n                  southwest: [coordinates[0][1], coordinates[0][0]],\n                  northeast: [coordinates[2][1], coordinates[2][0]]\n                });\n              }\n            } catch (e) {\n              // Let this fall through to the `onFail()` below.\n            }\n          }\n\n          onFail();\n        };\n\n        xhr.onabort = onFail;\n        xhr.onerror = onFail;\n\n        xhr.open('GET', url, true);\n\n        // Set user-defined headers.\n        _.each(headers, function(value, key) {\n          xhr.setRequestHeader(key, value);\n        });\n\n        xhr.send();\n      })\n    );\n  };\n\n  this.getShapefile = function(extent) {\n    var url = 'https://{0}/resource/{1}.geojson'.format(\n      this.getConfigurationProperty('domain'),\n      this.getConfigurationProperty('datasetUid')\n    );\n    var headers = {\n      Accept: 'application/json'\n    };\n    var extentQuery = \"?$select=*&$where=intersects(the_geom, 'MULTIPOLYGON((({0})))')&$limit=5000\";\n    var extentValidationErrorMessage = 'Argument `extent` must be an object ' +\n      'with two keys: `southwest` and `northeast`; the value assigned to ' +\n      'each key must be an array of two numbers in the following format: `[' +\n      'latitude, longitude]`.';\n\n    // Do not use a looser test for falsiness because if an invalid extent is\n    // provided in any form we want to kick an error up to help with debugging.\n    if (!_.isUndefined(extent)) {\n      if (extentIsValid(extent)) {\n\n        url += extentQuery.format(\n          mapExtentToMultipolygon(extent)\n        );\n\n      } else {\n\n        return (\n          new Promise(function(resolve, reject) {\n            return reject({\n              status: -1,\n              message: extentValidationErrorMessage,\n              soqlError: null\n            });\n          })\n        );\n      }\n    }\n\n    return (\n      new Promise(function(resolve, reject) {\n        var xhr = new XMLHttpRequest();\n\n        function onFail() {\n          var error;\n\n          try {\n            error = JSON.parse(xhr.responseText);\n          } catch (e) {\n            console.log(e);\n            error = xhr.statusText;\n          }\n\n          return reject({\n            status: parseInt(xhr.status, 10),\n            message: xhr.statusText,\n            soqlError: error\n          });\n        }\n\n        xhr.onload = function() {\n          var status = parseInt(xhr.status, 10);\n\n          if (status === 200) {\n\n            try {\n              var responseTextWithoutNewlines = xhr.\n                responseText.\n                replace(/\\n/g, '');\n\n              resolve(JSON.parse(responseTextWithoutNewlines));\n\n            } catch (e) {\n              console.log(e);\n              // Let this fall through to the `onFail()` below.\n            }\n          }\n\n          onFail();\n        };\n\n        xhr.onabort = onFail;\n        xhr.onerror = onFail;\n\n        xhr.open('GET', url, true);\n\n        // Set user-defined headers.\n        _.each(headers, function(value, key) {\n          xhr.setRequestHeader(key, value);\n        });\n\n        xhr.send();\n      })\n    );\n  };\n\n  function extentIsValid(extent) {\n\n    return (\n      // Validate that it is an object with northeast and\n      // southwest properties.\n      _.isObject(extent) &&\n      // Next validate the northeast property.\n      _.isArray(extent.northeast) &&\n      extent.northeast.length === 2 &&\n      _.every(extent.northeast, _.isNumber) &&\n      // Then validate the southwest property.\n      _.isArray(extent.southwest) &&\n      extent.southwest.length === 2 &&\n      _.every(extent.southwest, _.isNumber)\n    );\n  }\n\n  /**\n   * Multipolygon queries expect a polygon in clockwise order, starting from\n   * the bottom left. Polygons are closed, meaning that the start and end\n   * points must be identical.\n   *\n   * Example:\n   *\n   * 2----3\n   * |    |\n   * 1,5--4\n   *\n   * Where each pair is: longitude latitude\n   */\n  function mapExtentToMultipolygon(extent) {\n\n    return '{0} {1},{2} {3},{4} {5},{6} {7}, {8} {9}'.format(\n      extent.southwest[1],\n      extent.southwest[0],\n      extent.southwest[1],\n      extent.northeast[0],\n      extent.northeast[1],\n      extent.northeast[0],\n      extent.northeast[1],\n      extent.southwest[0],\n      extent.southwest[1],\n      extent.southwest[0]\n    );\n  }\n}\n\nmodule.exports = GeospaceDataProvider;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/dataProviders/GeospaceDataProvider.js\n ** module id = 23\n ** module chunks = 0\n **/","'use strict';\n\nvar _ = require('lodash');\n\nfunction DataProvider(config) {\n\n  var _defaultConfig = {\n    timeout: 5000\n  };\n  var _config = _.merge(_defaultConfig, config);\n\n  /**\n   * Public methods\n   */\n\n  /**\n   * @param {String} property - The desired configuration property key.\n   *\n   * @return {*} - The configuration property value that was passed in\n   *   at instantiation.\n   */\n  this.getConfigurationProperty = function(property) {\n\n    if (!_.has(_config, property)) {\n\n      throw new Error(\n        'Configuration property `{0}` does not exist.'.format(property)\n      );\n    }\n\n    return _config[property];\n  };\n\n  this.emitEvent = function(name, payload) {\n    this.element[0].dispatchEvent(\n      new window.CustomEvent(\n        name,\n        { detail: payload, bubbles: true }\n      )\n    );\n  };\n\n  /**\n   * Parse headers into a key => value mapping.\n   *\n   * @param {string} headers - Raw headers as a string.\n   *\n   * @return {Object} Parsed headers as key value object.\n   */\n  this.parseHeaders = function(headers) {\n\n    var parsed = {};\n    var key;\n    var val;\n    var colonIndex;\n\n    if (!headers) {\n      return parsed;\n    }\n\n    headers.\n      split('\\n').\n      forEach(function(line) {\n        colonIndex = line.indexOf(':');\n        key = line.substr(0, colonIndex).trim().toLowerCase();\n        val = line.substr(colonIndex + 1).trim();\n\n        if (key) {\n          parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n        }\n      }\n    );\n\n    return parsed;\n  };\n\n  /**\n   * Private methods\n   */\n}\n\nmodule.exports = DataProvider;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/dataProviders/DataProvider.js\n ** module id = 24\n ** module chunks = 0\n **/","'use strict';\n\nvar utils = require('socrata-utils');\nvar DataProvider = require('./DataProvider');\nvar _ = require('lodash');\n\nfunction MetadataProvider(config) {\n  var self = this;\n\n  _.extend(this, new DataProvider(config));\n\n  utils.assertHasProperty(config, 'domain');\n  utils.assertHasProperty(config, 'datasetUid');\n\n  utils.assertIsOneOfTypes(config.domain, 'string');\n  utils.assertIsOneOfTypes(config.datasetUid, 'string');\n\n  /**\n   * Public methods\n   */\n\n  /**\n   * NOTE:\n   * Columns are structured in an Array.\n   * (See: https://localhost/api/docs/types#View)\n   */\n  this.getDatasetMetadata = function() {\n    var url = 'https://{0}/api/views/{1}.json'.format(\n      this.getConfigurationProperty('domain'),\n      this.getConfigurationProperty('datasetUid')\n    );\n\n    return Promise.resolve($.get(url));\n  };\n\n  /**\n   * NOTE:\n   * Columns are structured in an object, where the key is the\n   * API field name and the value is column metadata.\n   */\n  this.getPhidippidesAugmentedDatasetMetadata = function() {\n\n    var url = 'https://{0}/metadata/v1/dataset/{1}.json'.format(\n      this.getConfigurationProperty('domain'),\n      this.getConfigurationProperty('datasetUid')\n    );\n    var headers = {\n      Accept: 'application/json'\n    };\n\n    return new Promise(function(resolve, reject) {\n\n      var xhr = new XMLHttpRequest();\n\n      function onFail() {\n\n        return reject({\n          status: parseInt(xhr.status, 10),\n          message: xhr.statusText\n        });\n      }\n\n      xhr.onload = function() {\n\n        var status = parseInt(xhr.status, 10);\n\n        if (status === 200) {\n\n          try {\n\n            return resolve(\n              JSON.parse(xhr.responseText)\n            );\n          } catch (e) {\n            // Let this fall through to the `onFail()` below.\n          }\n        }\n\n        onFail();\n      };\n\n      xhr.onabort = onFail;\n      xhr.onerror = onFail;\n\n      xhr.open('GET', url, true);\n\n      // Set user-defined headers.\n      _.each(headers, function(value, key) {\n        xhr.setRequestHeader(key, value);\n      });\n\n      xhr.send();\n    });\n  };\n\n  this.isSystemColumn = function(fieldName) {\n    return fieldName[0] === ':';\n  };\n\n  /*\n   * CORE-4645 OBE datasets can have columns that have sub-columns. When converted to the NBE, these\n   * sub-columns become their own columns. This function uses heuristics to figure out if a\n   * column is likely to be a subcolumn (so not guaranteed to be 100% accurate!).\n   *\n   * This code is lifted from frontend: lib/common_metadata_methods.rb.\n   */\n  this.isSubcolumn = function(fieldName, datasetMetadata) {\n    utils.assertIsOneOfTypes(fieldName, 'string');\n\n    var isSubcolumn = false;\n    var columns = datasetMetadata.columns;\n    var fieldNameByName = {};\n\n    var fieldNameWithoutCollisionSuffix = fieldName.replace(/_\\d+$/g, '');\n    var hasExplodedSuffix = /_(address|city|state|zip|type|description)$/.test(fieldNameWithoutCollisionSuffix);\n\n    var matchedColumn = _.find(columns, _.matches({ fieldName: fieldName }));\n    var parentColumnName;\n\n    utils.assert(\n      matchedColumn,\n      'could not find column {0} in dataset {1}'.format(fieldName, datasetMetadata.id)\n    );\n\n    // The naming convention is that child column names are the parent column name, followed by the\n    // child column name in parentheses. Remove the parentheses to get the parent column's name.\n    parentColumnName = matchedColumn.name.replace(/(\\w) +\\(.+\\)$/, '$1');\n\n    /*\n     * CORE-6925: Fairly brittle, but with no other clear option, it seems that\n     * we can and should only flag a column as a subcolumn if it follows the\n     * naming conventions associated with \"exploding\" location, URL, and phone\n     * number columns, which is an OBE-to-NBE occurrence. Robert Macomber has\n     * verified the closed set of suffixes in Slack PM:\n     *\n     *   _type for the type subcolumn on phones (the number has no suffix)\n     *   _description for the description subcolumn on urls (the url itself has no suffix)\n     *   _address, _city, _state, _zip for location columns (the point has no suffix)\n     *\n     * See also https://socrata.slack.com/archives/engineering/p1442959713000621\n     * for an unfortunately lengthy conversation on this topic.\n     *\n     * Complicating this matter... there is no strict guarantee that any suffix\n     * for collision prevention (e.g. `_1`) will belong to a user-given column\n     * or an exploded column consistently. It's possible that a user will have\n     * a column ending in a number. Given that we're already restricting the\n     * columns that we're willing to mark as subcolumns based on the closed set\n     * of (non-numeric) suffixes, and the low probability of this very specific\n     * type of column name similarity, we'll strip numeric parts off the end of\n     * the column name *before* checking the closed set. This leaves us with a\n     * very low (but non-zero) probability that a user-provided column will be\n     * marked as an exploded subcolumn.\n     */\n\n\n    if (parentColumnName !== matchedColumn.name && hasExplodedSuffix) {\n      _.each(columns, function(column) {\n        fieldNameByName[column.name] = fieldNameByName[column.name] || [];\n        fieldNameByName[column.name].push(column.fieldName);\n      });\n\n      // Look for the parent column\n      // There are columns that have the same name as this one, sans parenthetical.\n      // Its field_name naming convention should also match, for us to infer it's a subcolumn.\n      isSubcolumn = (fieldNameByName[parentColumnName] || []).\n        some(function(parentFieldName) {\n          return parentFieldName + '_' === fieldName.substring(0, parentFieldName.length + 1);\n        });\n    }\n\n    return isSubcolumn;\n  };\n\n  // Given a dataset metadata object (see .getDatasetMetadata()),\n  // returns an array of the columns  which are suitable for\n  // display to the user (all columns minus system and subcolumns).\n  //\n  // @return {Object[]}\n  this.getDisplayableColumns = function(datasetMetadata) {\n    utils.assertHasProperty(datasetMetadata, 'columns');\n\n    return _.reject(datasetMetadata.columns, function(column) {\n      return self.isSystemColumn(column.fieldName) ||\n        self.isSubcolumn(column.fieldName, datasetMetadata);\n    });\n  };\n\n\n}\n\nmodule.exports = MetadataProvider;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/dataProviders/MetadataProvider.js\n ** module id = 25\n ** module chunks = 0\n **/","'use strict';\n\nvar utils = require('socrata-utils');\nvar DataProvider = require('./DataProvider');\nvar _ = require('lodash');\n\n/**\n * `SoqlDataProvider` is an implementation of `DataProvider` that enables\n * users to query SoQL data sources on the current domain.\n *\n * @constructor\n *\n * @param {Object} config\n *  @property {String} domain - The domain against which to make the query.\n *  @property {String} datasetUid - The uid of the dataset against which\n *    the user intends to query.\n */\nfunction SoqlDataProvider(config) {\n  'use strict';\n\n  _.extend(this, new DataProvider(config));\n\n  utils.assertHasProperty(config, 'domain');\n  utils.assertHasProperty(config, 'datasetUid');\n\n  utils.assertIsOneOfTypes(config.domain, 'string');\n  utils.assertIsOneOfTypes(config.datasetUid, 'string');\n\n  var _self = this;\n\n  /**\n   * Public methods\n   */\n\n  this.buildBaseQuery = function() {\n    // TODO: Implement mapping of filters array into a query string\n    return '';\n  };\n\n  /**\n   * `.query()` executes a SoQL query against the current domain that returns\n   * key => value pairs. The query string is passed in by the caller, meaning\n   * that at this level of abstraction we have no notion of SoQL grammar.\n   *\n   * A note on `nameAlias` and `valueAlias`:\n   *\n   *   Since it is possible that columns have names that may collide with\n   *   SoQL keywords (e.g. a column named 'null'), we alias all fields in\n   *   the SELECT clause like this:\n   *\n   *     \"SELECT `null` as ALIAS_NAME, `false` AS ALIAS_VALUE...\"\n   *\n   *   These aliases are set by the caller and will also be used as column\n   *   names in the resulting 'table' object returned by the request.\n   *\n   * @param {String} queryString - A valid SoQL query.\n   * @param {String} nameAlias - The alias used for the 'name' column.\n   * @param {String} valueAlias - The alias used for the 'value' column.\n   *\n   * @return {Promise}\n   */\n  this.query = function(queryString, nameAlias, valueAlias) {\n\n    var url = _queryUrl('$query={0}'.format(queryString));\n\n    return _makeSoqlGetRequestWithSalt(url).then(\n      function(data) {\n        return _mapRowsResponseToTable([ nameAlias, valueAlias ], data);\n      }\n    );\n  };\n\n  this.getRowCount = function() {\n    return Promise.resolve(\n      $.get(_queryUrl('$select=count(*)'))\n    ).then(\n      function(data) {\n        return parseInt(_.get(data, '[0].count'), 10);\n      }\n    );\n  };\n\n  /**\n   * `.getRows()` executes a SoQL query against the current domain that\n   * returns all rows. The response is mapped to the DataProvider data schema (1).\n   * The query string is passed in by the caller, meaning\n   * that at this level of abstraction we have no notion of SoQL grammar.\n   *\n   * @param {String[]} columnNames - A list of column names to extract from the response.\n   * @param {String} queryString - A valid SoQL query.\n   *\n   * (1) - The DataProvider data schema:\n   * {\n   *   columns: {String[]},\n   *   rows: {{Object[]}[]}.\n   * }\n   * Row:\n   *\n   * Example:\n   * {\n   *   columns: [ 'date', 'id' ],\n   *   rows: [\n   *    [ '2016-01-15T11:08:45.000', '123' ],\n   *    [ '2016-01-15T11:08:45.000', '345' ]\n   *   ]\n   * }\n   *\n   * @return {Promise}\n   */\n  this.getRows = function(columnNames, queryString) {\n    utils.assertInstanceOf(columnNames, Array);\n    utils.assert(columnNames.length > 0);\n    utils.assertIsOneOfTypes(queryString, 'string');\n    _.each(columnNames, function(columnName) {\n      utils.assertIsOneOfTypes(columnName, 'string');\n    });\n\n    return _makeSoqlGetRequestWithSalt(_queryUrl(queryString)).then(\n      function(soqlData) {\n        return _mapRowsResponseToTable(columnNames, soqlData);\n      }\n    );\n  };\n\n  /**\n   * `.getTableData()`\n   *\n   * Gets a page of data from the dataset. In addition to an offset\n   * and limit, you must specify an ordering and a list of columns.\n   *\n   * @param {String[]} columnNames - Columns to grab data from.\n   * @param {Object[]} order - An array of order clauses. For the moment, there must always\n   *                           be exactly one order clause. A clause looks like:\n   *                           {\n   *                             columnName: {String} - a column,\n   *                             ascending: {Boolean} - ascending or descending\n   *                           }\n   * @param {Number} offset - Skip this many rows.\n   * @param {Number} limit - Fetch this many rows, starting from offset.\n   *\n   * @return {Promise}\n   */\n  this.getTableData = function(columnNames, order, offset, limit) {\n    utils.assertInstanceOf(columnNames, Array);\n    utils.assertIsOneOfTypes(offset, 'number');\n    utils.assertIsOneOfTypes(limit, 'number');\n\n    // We only support one order for the moment.\n    utils.assert(order.length === 1, 'order parameter must be an array with exactly one element.');\n\n    utils.assertHasProperties(order,\n      '[0].ascending',\n      '[0].columnName'\n    );\n\n    var queryString = '$select={0}&$order=`{1}`+{2}&$limit={3}&$offset={4}'.format(\n      columnNames.map(_escapeColumnName).join(','),\n      order[0].columnName,\n      (order[0].ascending ? 'ASC' : 'DESC'),\n      limit,\n      offset\n    );\n\n    return _makeSoqlGetRequestWithSalt(_queryUrl(queryString)).then(function(data) {\n      return _mapRowsResponseToTable(columnNames, data);\n    });\n  };\n\n  /**\n   * Private methods\n   */\n\n  // Returns a Promise for a GET against the given SOQL url.\n  // Adds salt to the end of the URL for cache bust.\n  // On error, rejects with an object: {\n  //   status: HTTP code,\n  //   message: status text,\n  //   soqlError: response JSON\n  // }\n  function _makeSoqlGetRequestWithSalt(url) {\n    return Promise.resolve($.get(_withSalt(url))).\n      catch(function(error) {\n        return Promise.reject({\n          status: parseInt(error.status, 10),\n          message: error.statusText,\n          soqlError: error.responseJSON || error.responseText\n        });\n      });\n  }\n\n  function _escapeColumnName(columnName) {\n    return '`{0}`'.format(columnName);\n  }\n\n  function _queryUrl(queryString) {\n    return 'https://{0}/api/id/{1}.json?{2}'.format(\n      _self.getConfigurationProperty('domain'),\n      _self.getConfigurationProperty('datasetUid'),\n      queryString\n    );\n  }\n\n  /**\n   * Transforms a raw row request result into a 'table' object.\n   *\n   * @param {String[]} columnNames - The list of columns to process.\n   * @param {Object[]} data - The row request result, which is an array of\n   *    objects with keys equal to the column name and values equal to the\n   *    row value for each respective column.\n   *\n   * @return {Object}\n   *   @property {String[]} columns - An ordered list of the column aliases\n   *     present in the query.\n   *   @property {[][]} rows - An array of rows returned by the query.\n   *\n   * The columns array is of the format:\n   *\n   *   [<first column name>, <second column name>, ...]\n   *\n   * Accordingly, each row in the rows array is of the format:\n   *\n   *   [\n   *     <first column value>,\n   *     <second column value>,\n   *     ...\n   *   ]\n   */\n  function _mapRowsResponseToTable(columnNames, data) {\n\n    var table = {\n      columns: columnNames,\n      rows: []\n    };\n\n    if (data.length > 0) {\n\n      var rows = data.map(function(datum) {\n\n        var row = [];\n\n        for (var i = 0; i < table.columns.length; i++) {\n\n          var column = table.columns[i];\n          var value = datum.hasOwnProperty(column) ? datum[column] : undefined;\n\n          row.push(value);\n        }\n\n        return row;\n      });\n\n      table.rows = rows;\n    }\n\n    return table;\n  }\n\n  /**\n   * Transforms a URL to include a salt on the end.\n   * https://socrata.atlassian.net/browse/CHART-204\n   *\n   * @param {string} url\n   * @return {string} salted url\n   */\n  function _withSalt(url) {\n    var hasQuery = _.includes(url, '?');\n    var formatVars = { url: url, salt: new Date().getTime() };\n\n    if (hasQuery) {\n      return '{url}&_={salt}'.format(formatVars);\n    } else {\n      return '{url}?_={salt}'.format(formatVars);\n    }\n  }\n}\n\nmodule.exports = SoqlDataProvider;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/dataProviders/SoqlDataProvider.js\n ** module id = 26\n ** module chunks = 0\n **/","'use strict';\n\nvar utils = require('socrata-utils');\nvar DataProvider = require('./DataProvider');\nvar _ = require('lodash');\n\nvar MAX_FEATURES_PER_TILE = 256 * 256;\nvar DEFAULT_FEATURES_PER_TILE = 50000;\n\n/**\n * @param {Object} config\n *   @property {String[]} tileserverHosts - An array of tileserver hostnames\n *     against which to make requests. Hostnames in this array must include\n *     a protocol (e.g. 'https://tileserver.example.com').\n *   @property {Number} [featuresPerTile] - The maximum number of features\n *     expected per tile. This defaults to (256 * 256). This value will be\n *     provided as the `LIMIT` parameter in the query string.\n *   @property {String} cname - The CNAME of the current domain. This value\n *     will be provided as the 'X-Socrata-Host' header in tile data requests.\n */\nfunction TileserverDataProvider(config) {\n\n  _.extend(this, new DataProvider(config));\n\n  utils.assertHasProperty(config, 'domain');\n  utils.assertHasProperty(config, 'datasetUid');\n  utils.assertHasProperty(config, 'columnName');\n  utils.assertHasProperty(config, 'featuresPerTile');\n  utils.assertHasProperty(config, 'tileserverHosts');\n\n  utils.assertIsOneOfTypes(config.domain, 'string');\n  utils.assertIsOneOfTypes(config.datasetUid, 'string');\n  utils.assertIsOneOfTypes(config.columnName, 'string');\n  utils.assertIsOneOfTypes(config.featuresPerTile, 'number');\n  utils.assertIsOneOfTypes(config.tileserverHosts, 'object');\n\n  var _self = this;\n\n  var _originHost = '{0}//{1}'.format(window.location.protocol, window.location.host);\n  var _instanceRequestIdComponent = _randomNChars(16);\n\n  /**\n   * Public methods\n   */\n\n  /**\n   * Curries datasetUid, columnName and whereClause into a function that can\n   * be called to perform an ajax call for a vector tile\n   *\n   * @param {String} columnName\n   * @param {String} datasetUid\n   * @param {String} [whereClause]\n   * @param {Boolean} [useOriginHost] - Whether or not all tiles should be\n   *   requested from the origin host (as opposed to selecting one of the\n   *   hosts in the `tileserverHosts` configuration property.\n   *\n   * @return {Function}\n   */\n  this.buildTileGetter = function(whereClause, useOriginHost) {\n\n    var domain = this.getConfigurationProperty('domain');\n    var datasetUid = this.getConfigurationProperty('datasetUid');\n    var columnName = this.getConfigurationProperty('columnName');\n    var featuresPerTile = parseInt(this.getConfigurationProperty('featuresPerTile'), 10);\n\n    utils.assertIsOneOfTypes(whereClause, 'string', 'undefined');\n    utils.assertIsOneOfTypes(useOriginHost, 'boolean', 'undefined');\n\n    if (\n      _.isNaN(featuresPerTile) ||\n      featuresPerTile < 0 ||\n      featuresPerTile > MAX_FEATURES_PER_TILE\n    ) {\n\n      featuresPerTile = DEFAULT_FEATURES_PER_TILE;\n    }\n\n    /**\n     * Returns a promise that, when resolved, will provide error details or\n     * the result of the tile data request as an ArrayBuffer.\n     *\n     * @param {Number} zoom\n     * @param {Number} x\n     * @param {Number} y\n     *\n     * @return {Promise}\n     */\n    function tileGetter(zoom, x, y) {\n\n      utils.assertIsOneOfTypes(zoom, 'number');\n      utils.assertIsOneOfTypes(x, 'number');\n      utils.assertIsOneOfTypes(y, 'number');\n\n      var url = '{0}/tiles/{1}/{2}/{3}/{4}/{5}.pbf?'.format(\n        _getHost(x, y, useOriginHost),\n        datasetUid,\n        columnName,\n        zoom,\n        x,\n        y\n      );\n\n      url += '$limit={0}'.format(featuresPerTile);\n\n      if (!_.isEmpty(whereClause)) {\n        url += '&$WHERE={0}'.format(whereClause);\n      }\n\n      return _getArrayBuffer(\n        url,\n        {\n          headers: {\n            'X-Socrata-Host': domain,\n            'X-Socrata-RequestId': _instanceRequestIdComponent + _randomNChars(16)\n          }\n        }\n      );\n    }\n\n    return tileGetter;\n  };\n\n  /**\n   * Private methods\n   */\n\n  function _randomNChars(n) {\n    var text = '';\n    var possible = 'abcdefghijklmnopqrstuvwxyz0123456789';\n\n    for (var i = 0; i < n; i++ ) {\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n    }\n\n    return text;\n  }\n\n  /**\n   * Given the x and y values for a tile and whether to use the the origin host,\n   * if there is an array of tileservers available, return one for a public\n   * tileserver hosts, otherwise return the originating host\n   *\n   * @param {Number} x\n   * @param {Number} y\n   * @param {Boolean} useOriginHost\n   *\n   * @return {String}\n   */\n  function _getHost(x, y, useOriginHost) {\n\n    var tileserverHosts = _self.getConfigurationProperty('tileserverHosts');\n    var index;\n    var host;\n\n    if (useOriginHost || _.isEmpty(tileserverHosts)) {\n\n      host = _originHost;\n\n    } else {\n\n      index = (Math.abs(x) + Math.abs(y)) % tileserverHosts.length;\n      host = tileserverHosts[index];\n    }\n\n    return host;\n  }\n\n  /**\n   * IE9 doesn't support binary data in xhr.response, so we have to\n   * use a righteous hack (See: http://stackoverflow.com/a/4330882).\n   */\n  function _xhrHasVBArray(xhr) {\n\n    return (\n      _.isUndefined(xhr.response) &&\n      _.isDefined(window.VBArray) &&\n      typeof xhr.responseBody === 'unknown' // eslint-disable-line valid-typeof\n    );\n  }\n\n  function _typedArrayFromArrayBufferResponse(xhr) {\n\n    // Handle IE.\n    if (_xhrHasVBArray(xhr)) {\n      return new VBArray(xhr.responseBody).toArray();\n    // Fall back to default for well-behaved browsers.\n    } else if (xhr.response && xhr.response instanceof ArrayBuffer) {\n      return new Uint8Array(xhr.response);\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Makes an AJAX request for an array buffer to Socrata Tileserver.\n   *\n   * @param {String} url\n   * @param {{headers: Object}} configuration\n   *\n   * @return {Promise}\n   */\n  function _getArrayBuffer(url, configuration) {\n\n    return (\n      new Promise(\n        function(resolve, reject) {\n          var xhr = new XMLHttpRequest();\n\n          function onFail() {\n\n            return reject({\n              status: parseInt(xhr.status, 10),\n              headers: _self.parseHeaders(xhr.getAllResponseHeaders()),\n              config: configuration,\n              statusText: xhr.statusText\n            });\n          }\n\n          xhr.onload = function() {\n\n            var arrayBuffer;\n            var status = parseInt(xhr.status, 10);\n\n            if (status === 200) {\n\n              arrayBuffer = _typedArrayFromArrayBufferResponse(xhr);\n\n              if (!_.isUndefined(arrayBuffer)) {\n\n                return resolve({\n                  data: arrayBuffer,\n                  status: status,\n                  headers: _self.parseHeaders(xhr.getAllResponseHeaders()),\n                  config: configuration,\n                  statusText: xhr.statusText\n                });\n              }\n            }\n\n            onFail();\n          };\n\n          xhr.onabort = onFail;\n          xhr.onerror = onFail;\n\n          xhr.open('GET', url, true);\n\n          // Set user-defined headers.\n          _.each(configuration.headers, function(value, key) {\n            xhr.setRequestHeader(key, value);\n          });\n\n          xhr.responseType = 'arraybuffer';\n\n          xhr.send();\n        }\n      ).catch(\n        function(error) {\n          throw error;\n        }\n      )\n    );\n  }\n}\n\nmodule.exports = TileserverDataProvider;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/dataProviders/TileserverDataProvider.js\n ** module id = 27\n ** module chunks = 0\n **/","'use strict';\n\nvar _ = require('lodash');\nvar utils = require('socrata-utils');\nvar d3 = require('d3');\nvar L = require('leaflet');\nvar VectorTile = require('vector-tile').VectorTile;\nvar pbf = require('pbf');\n\n/**\n *\n * VectorTileUtil\n *\n */\n\nvar VectorTileUtil = {\n\n  getTileId: function(tile) {\n    return _.at(tile, ['zoom', 'x', 'y']).join(':');\n  },\n\n  getLeafletTileId: function(tileId) {\n    return tileId.split(':').slice(1, 3).join(':');\n  },\n\n  // Given a point and zoom level, return the x, y, and z values\n  // of the tile containing this point.  The point should be specified\n  // as an object containing lat and lng keys.\n  getTileInfoByPointAndZoomLevel: function(point, zoom) {\n    var lat = point.lat * Math.PI / 180;\n    var lon = point.lng;\n\n    var x = (lon + 180) / 360;\n    var y = (1 - Math.log(Math.tan(lat) + 1 / Math.cos(lat)) / Math.PI) / 2;\n\n    x = x * (1 << zoom);\n    y = y * (1 << zoom);\n\n    return {\n      zoom: zoom,\n      x: parseInt(Math.floor(x)),\n      y: parseInt(Math.floor(y))\n    };\n  },\n\n  getTileTotalPoints: function(tileLayer, tileId) {\n    return _.get(tileLayer, 'totalPointsByTile[{0}]'.format(tileId), 0);\n  },\n\n  // Reads raw VectorTile data and creates an array of\n  // features on each VectorTileLayer instance assigned\n  // to the tile.\n  unpackVectorTile: function(vectorTile) {\n\n    var keys = Object.keys(vectorTile.layers);\n    var i = keys.length;\n    var vectorTileLayer;\n    var features;\n    var j;\n    var vectorTileFeature;\n\n    while (i--) {\n      vectorTileLayer = vectorTile.layers[keys[i]];\n      vectorTileLayer.features = [];\n      features = vectorTileLayer._features;\n      j = features.length;\n\n      while (j--) {\n        vectorTileFeature = vectorTileLayer.feature(j);\n        vectorTileFeature.coordinates = vectorTileFeature.loadGeometry();\n        vectorTileLayer.features.push(vectorTileFeature);\n      }\n\n    }\n\n    return vectorTile;\n  },\n\n  getTileLayerCanvas: function(tileLayer, tileId) {\n    return _.get(tileLayer, '_tiles.' + VectorTileUtil.getLeafletTileId(tileId));\n  },\n\n  hotspots: [\n    ['top'],\n    ['left'],\n    ['bottom'],\n    ['right']\n  ].concat(\n    _.zip(\n      ['top', 'top', 'bottom', 'bottom'],\n      ['left', 'right', 'left', 'right']\n    )\n  ),\n\n  oppositeDirections: {\n    top: 'bottom',\n    bottom: 'top',\n    left: 'right',\n    right: 'left'\n  },\n\n  tileSize: 256,\n\n  tileIdModifiers: {\n    top: function(neighborTile) {\n      neighborTile.y--;\n    },\n    left: function(neighborTile) {\n      neighborTile.x--;\n    },\n    bottom: function(neighborTile) {\n      neighborTile.y++;\n    },\n    right: function(neighborTile) {\n      neighborTile.x++;\n    }\n  },\n\n  tileOffsetModifiers: {\n    top: function(tileOffset) {\n      tileOffset.y -= VectorTileUtil.tileSize;\n    },\n    left: function(tileOffset) {\n      tileOffset.x -= VectorTileUtil.tileSize;\n    },\n    bottom: function(tileOffset) {\n      tileOffset.y += VectorTileUtil.tileSize;\n    },\n    right: function(tileOffset) {\n      tileOffset.x += VectorTileUtil.tileSize;\n    }\n  }\n};\n\n/**\n * VectorTileFeature\n *\n * Depends on `VectorTileUtil`\n */\n\nfunction VectorTileFeature(layer, feature, getFeatureStyle) {\n\n  var keys;\n  var i;\n  var key;\n\n  if (!feature) {\n    return null;\n  }\n\n  // Apply all of the properties of feature to this object.\n  keys = Object.keys(feature);\n  i = keys.length;\n\n  while (i--) {\n    key = keys[i];\n    this[key] = feature[key];\n  }\n\n  this.tileLayer = layer;\n  this.tileSize = layer.options.tileSize;\n  this.map = layer.tileManager.map;\n  // Divisor is the amount by which we divide coordinate values in\n  // order to project them into the vector tile's coordinate space.\n  this.divisor = feature.extent / this.tileSize;\n  this.feature = feature;\n  this.getFeatureStyle = getFeatureStyle;\n}\n\n// Takes a coordinate from a vector tile and turns it into a Leaflet Point.\nVectorTileFeature.prototype.projectGeometryToTilePoint = function(coordinates) {\n  return new L.Point(coordinates.x / this.divisor, coordinates.y / this.divisor);\n};\n\nVectorTileFeature.prototype.draw = function(tileId, offset) {\n\n  var feature = this.feature;\n  var canvas = VectorTileUtil.getTileLayerCanvas(this.tileLayer, tileId);\n\n  switch (feature.type) {\n    case 1: //Point\n      this.drawPoint(canvas, feature.coordinates, this.getFeatureStyle, offset);\n      break;\n\n    case 2: //LineString\n      this.drawLineString(canvas, feature.coordinates, this.getFeatureStyle);\n      break;\n\n    case 3: //Polygon\n      this.drawPolygon(canvas, feature.coordinates, this.getFeatureStyle);\n      break;\n\n    default:\n      throw new Error('Cannot draw VectorTileFeature: unrecognized type: \"{0}\"'.format(feature.type));\n  }\n};\n\nVectorTileFeature.prototype.drawPoint = function(canvas, geometry, computedStyle, offset) {\n  var ctx;\n  var projectedPoint;\n  var color;\n  var radius;\n  var strokeStyle;\n\n  if (_.isUndefined(canvas) ||\n      !_.isObject(computedStyle) ||\n      !computedStyle.hasOwnProperty('color') ||\n      !computedStyle.hasOwnProperty('radius')) {\n    return;\n  }\n\n  ctx = canvas.getContext('2d');\n\n  if (ctx === null) {\n    throw new Error('Could not draw VectorTileFeature point: canvas context is null.');\n  }\n\n  projectedPoint = this.projectGeometryToTilePoint(geometry[0][0]);\n\n  if (offset) {\n    projectedPoint.x += offset.x;\n    projectedPoint.y += offset.y;\n  }\n\n  // Determine point styling based on computed style and map zoom\n  if (_.isFunction(computedStyle.color)) {\n    color = computedStyle.color(this.map.getZoom());\n  } else {\n    color = computedStyle.color;\n  }\n\n  if (_.isFunction(computedStyle.radius)) {\n    radius = computedStyle.radius(this.map.getZoom());\n  } else {\n    radius = computedStyle.radius;\n  }\n\n  if (_.isFunction(computedStyle.strokeStyle)) {\n    strokeStyle = computedStyle.strokeStyle(this.map.getZoom());\n  } else {\n    strokeStyle = computedStyle.strokeStyle;\n  }\n\n  // Draw point\n  ctx.fillStyle = color;\n  ctx.beginPath();\n  ctx.arc(projectedPoint.x, projectedPoint.y, radius, 0, Math.PI * 2);\n  ctx.closePath();\n  ctx.fill();\n\n  if (computedStyle.lineWidth && strokeStyle) {\n\n    ctx.lineWidth = computedStyle.lineWidth;\n    ctx.strokeStyle = strokeStyle;\n    ctx.stroke();\n\n  }\n\n  ctx.restore();\n};\n\nVectorTileFeature.prototype.drawLineString = function(canvas, coordinateArray, computedStyle) {\n\n  var ctx;\n  var projectedCoordinates;\n  var i;\n  var coordinates;\n  var j;\n  var projectedPoint;\n  var coordinateGroupCount;\n  var coordinateCount;\n\n  if (!_.isObject(computedStyle) ||\n      !computedStyle.hasOwnProperty('color') ||\n      !computedStyle.hasOwnProperty('size')) {\n    return;\n  }\n\n  if (_.isUndefined(canvas)) {\n    return;\n  }\n\n  ctx = canvas.getContext('2d');\n\n  if (ctx === null) {\n    throw new Error('Could not draw lineString: canvas context is null.');\n  }\n\n  projectedCoordinates = [];\n\n  ctx.strokeStyle = computedStyle.color;\n  ctx.lineWidth = computedStyle.size;\n\n  ctx.beginPath();\n\n  coordinateGroupCount = coordinateArray.length;\n\n  for (i = 0; i < coordinateGroupCount; i++) {\n\n    coordinates = coordinateArray[i];\n    coordinateCount = coordinates.length;\n\n    for (j = 0; j < coordinateCount; j++) {\n      projectedPoint = this.projectGeometryToTilePoint(coordinates[i]);\n      projectedCoordinates.push(projectedPoint);\n\n      if (j === 0) {\n        ctx.moveTo(projectedPoint.x, projectedPoint.y);\n      } else {\n        ctx.lineTo(projectedPoint.x, projectedPoint.y);\n      }\n\n    }\n  }\n\n  ctx.stroke();\n  ctx.restore();\n};\n\nVectorTileFeature.prototype.drawPolygon = function(canvas, coordinateArray, computedStyle) {\n\n  function validateOutline(computedOutline) {\n    var validatedOutline = null;\n    if (_.has(computedOutline, 'color') && _.has(computedOutline, 'size')) {\n      validatedOutline = computedOutline;\n    }\n    return validatedOutline;\n  }\n\n  var ctx;\n  var outline;\n  var projectedCoordinates;\n  var coordinateGroupCount;\n  var i;\n  var coordinateCount;\n  var j;\n  var projectedPoint;\n  var coordinates;\n\n  if (!_.isObject(computedStyle) ||\n      !computedStyle.hasOwnProperty('color') ||\n      !computedStyle.hasOwnProperty('size')) {\n    return;\n  }\n\n  if (_.isUndefined(canvas)) {\n    return;\n  }\n\n  ctx = canvas.getContext('2d');\n  outline = computedStyle.hasOwnProperty('outline') ? validateOutline(computedStyle.outline) : null;\n\n  projectedCoordinates = [];\n\n  // computedStyle.color may be a function or a value.\n  if (_.isFunction(computedStyle.color)) {\n    ctx.fillStyle = computedStyle.color();\n  } else {\n    ctx.fillStyle = computedStyle.color;\n  }\n\n  if (outline !== null) {\n    ctx.strokeStyle = outline.color;\n    ctx.lineWidth = outline.size;\n  }\n\n  ctx.beginPath();\n\n  coordinateGroupCount = coordinateArray.length;\n\n  for (i = 0; i < coordinateGroupCount; i++) {\n\n    coordinates = coordinateArray[i];\n    coordinateCount = coordinates.length;\n\n    for (j = 0; j < coordinateCount; j++) {\n      projectedPoint = this.projectGeometryToTilePoint(coordinates[j]);\n      projectedCoordinates.push(projectedPoint);\n\n      if (j === 0) {\n        ctx.moveTo(projectedPoint.x, projectedPoint.y);\n      } else {\n        ctx.lineTo(projectedPoint.x, projectedPoint.y);\n      }\n\n    }\n  }\n\n  ctx.closePath();\n  ctx.fill();\n\n  if (outline !== null) {\n    ctx.stroke();\n  }\n\n  ctx.restore();\n};\n\n\n/**\n *\n * VectorTileLayer\n *\n * Originally forked from https://gist.github.com/DGuidi/1716010\n *\n * Depends on `VectorTileFeature`\n */\n\nvar VectorTileLayer = L.TileLayer.Canvas.extend({\n\n  initialize: function(tileManager, options) {\n\n    this.options = {\n      tileSize: VectorTileUtil.tileSize\n    };\n    L.Util.setOptions(this, options);\n\n    this.tileManager = tileManager;\n    this.getFeatureStyle = options.getFeatureStyle;\n    this.featuresByTile = {};\n    this.totalPointsByTile = {};\n    this.quadTreesByTile = {};\n    this.boundaryPointsByTile = {};\n    this.boundaryPointCountByTileAndDirection = {};\n  },\n\n  onAdd: function(map) {\n\n    this.map = map;\n    L.TileLayer.Canvas.prototype.onAdd.call(this, map);\n  },\n\n  // drawTile is a method that Leaflet expects to exist with\n  // the specified signature. This is called when we need to\n  // prepare a tile for rendering, but the actual rendering\n  // is handled by our own `renderTile` method instead (as\n  // a result of needing to fetch and parse protocol buffers.\n  drawTile: function(canvas, tilePoint, zoom) {\n    var tileId = VectorTileUtil.getTileId({x: tilePoint.x, y: tilePoint.y, zoom: zoom});\n\n    this.featuresByTile[tileId] = [];\n    this.totalPointsByTile[tileId] = 0;\n    this.quadTreesByTile[tileId] = this.tileManager.quadTreeFactory([]);\n    this.boundaryPointsByTile[tileId] = {\n      top: [],\n      left: [],\n      bottom: [],\n      right: []\n    };\n    this.boundaryPointCountByTileAndDirection[tileId] = {\n      top: 0,\n      left: 0,\n      right: 0,\n      bottom: 0,\n      topleft: 0,\n      topright: 0,\n      bottomleft: 0,\n      bottomright: 0\n    };\n\n    return this;\n  },\n\n  loadData: function(vectorTileData, tileId, tileRenderedCallback) {\n\n    var features = vectorTileData.features;\n    var i;\n    var featureCount = features.length;\n    var feature;\n    var featureArray;\n    var featurePointCount = 0;\n    var tileSize = this.options.tileSize;\n\n    var style = this.getFeatureStyle({type: 1});\n    var featureRadius;\n    if (_.isFunction(style.radius)) {\n      featureRadius = style.radius(this.map.getZoom());\n    } else {\n      featureRadius = style.radius;\n    }\n\n    if (!this.featuresByTile.hasOwnProperty(tileId) && featureCount > 0) {\n      this.featuresByTile[tileId] = [];\n    }\n\n    if (!this.quadTreesByTile.hasOwnProperty(tileId) && featureCount > 0) {\n      this.quadTreesByTile[tileId] = this.tileManager.quadTreeFactory([]);\n    }\n\n    featureArray = this.featuresByTile[tileId];\n\n    for (i = 0; i < featureCount; i++) {\n      feature = features[i];\n\n      var vectorTileFeature = new VectorTileFeature(this, feature, this.getFeatureStyle(feature));\n      var projectedPoint = vectorTileFeature.projectGeometryToTilePoint(vectorTileFeature.coordinates[0][0]);\n\n      var boundaryPoints = this.boundaryPointsByTile[tileId];\n      if (boundaryPoints) {\n        if (projectedPoint.x <= featureRadius) {\n          boundaryPoints.left.push(vectorTileFeature);\n        } else if (projectedPoint.x >= tileSize - featureRadius) {\n          boundaryPoints.right.push(vectorTileFeature);\n        }\n\n        if (projectedPoint.y <= featureRadius) {\n          boundaryPoints.top.push(vectorTileFeature);\n        } else if (projectedPoint.y >= tileSize - featureRadius) {\n          boundaryPoints.bottom.push(vectorTileFeature);\n        }\n      }\n\n      projectedPoint.count = vectorTileFeature.properties.count;\n      featurePointCount += parseInt(_.get(vectorTileFeature, 'properties.count', 0), 10);\n\n      projectedPoint.tile = tileId;\n      this.quadTreesByTile[tileId].add(projectedPoint);\n\n      featureArray.push(vectorTileFeature);\n    }\n\n    this.totalPointsByTile[tileId] = featurePointCount;\n    this.renderTile(tileId, tileRenderedCallback);\n  },\n\n  renderTileOverlap: function(tileId) {\n    var self = this;\n\n    var tileInfo = _.chain(['z', 'x', 'y']).\n      zipObject(tileId.split(':')).\n      mapValues(Number).\n      value();\n\n    _.each(VectorTileUtil.hotspots, function(hotspot) {\n      var neighbor = _.clone(tileInfo);\n      var offset = {x: 0, y: 0};\n\n      _.each(hotspot, function(direction) {\n        VectorTileUtil.tileIdModifiers[direction](neighbor);\n        VectorTileUtil.tileOffsetModifiers[direction](offset);\n      });\n\n      neighbor.zoom = neighbor.z;\n      neighbor.id = VectorTileUtil.getTileId(neighbor);\n      var features = [];\n\n      _.each(hotspot, function(direction) {\n        if (self.boundaryPointsByTile[neighbor.id]) {\n          features = features.concat(self.boundaryPointsByTile[neighbor.id][VectorTileUtil.oppositeDirections[direction]]);\n        }\n      });\n\n      var featureCount = features.length;\n      var serializedHotspot = hotspot.join('');\n      var boundaryPointCount = self.boundaryPointCountByTileAndDirection[tileId];\n      if (boundaryPointCount && (!boundaryPointCount[serializedHotspot] || boundaryPointCount[serializedHotspot] < featureCount)) {\n        boundaryPointCount[serializedHotspot] = featureCount;\n        for (var i = 0; i < featureCount; i++) {\n          features[i].draw(tileId, offset);\n        }\n      }\n    });\n  },\n\n  renderTile: function(tileId, tileRenderedCallback) {\n\n    var features;\n    var featureCount;\n    var i;\n\n    // First, clear the canvas\n    if (_.has(this._tiles, VectorTileUtil.getLeafletTileId(tileId))) {\n      this.clearTile(tileId);\n    }\n\n    features = this.featuresByTile[tileId];\n    featureCount = features.length;\n\n    for (i = 0; i < featureCount; i++) {\n      features[i].draw(tileId);\n    }\n\n    tileRenderedCallback();\n  },\n\n  clearTile: function(tileId) {\n    var canvas = VectorTileUtil.getTileLayerCanvas(this, tileId);\n    var ctx = canvas.getContext('2d');\n\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n  }\n});\n\n\n/**\n * VectorTileManager\n *\n * Depends on `pbf`, `VectorTileUtil` `VectorTile`, `VectorTileFeature` and `VectorTileLayer`\n */\n\nL.TileLayer.VectorTileManager = L.TileLayer.Canvas.extend({\n\n  initialize: function(options) {\n\n    utils.assertIsOneOfTypes(options, 'object');\n    utils.assertHasProperties(\n      options,\n      'vectorTileGetter',\n      'getFeatureStyle'\n    );\n\n    utils.assertIsOneOfTypes(options.vectorTileGetter, 'function');\n    utils.assertIsOneOfTypes(options.getFeatureStyle, 'function');\n\n    var self = this;\n\n    var pointStyle;\n    var maxThreshold;\n    var tileSize;\n\n    function drawHighlightTile(canvas, tilePoint, zoom, pointsToHighlight) {\n\n      var ctx = canvas.getContext('2d');\n      var tileId = VectorTileUtil.getTileId({ x: tilePoint.x, y: tilePoint.y, zoom: zoom });\n\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n      ctx.fillStyle = pointStyle.highlightColor;\n      ctx.strokeStyle = pointStyle.strokeStyle;\n      ctx.lineWidth = pointStyle.lineWidth;\n\n      var points = _.filter(pointsToHighlight, function(point) {\n        return point.tile === tileId;\n      });\n\n      _.each(points, function(point) {\n        ctx.beginPath();\n        ctx.arc(point.x, point.y, pointStyle.radius(zoom), 0, Math.PI * 2);\n        ctx.closePath();\n        ctx.fill();\n      });\n\n      ctx.restore();\n    }\n\n    this.getFeatureStyle = options.getFeatureStyle;\n\n    pointStyle = this.getFeatureStyle({ type: 1 }); // getPointStyle in featureMap.js\n\n    this.options = {\n      debug: false,\n      // Initialize the layer to be non-interactive so that we do not attempt\n      // to handle events while the layer is loading. This value is then set\n      // to true once the layer has completed loading.\n      interactive: false,\n      tileSize: VectorTileUtil.tileSize,\n      debounceMilliseconds: 500,\n      onRenderStart: _.noop,\n      onRenderComplete: _.noop,\n      // threshold options represent distance to neighboring points permitted for hover and click in px\n      getHoverThreshold: _.noop,\n      maxHoverThreshold: pointStyle.radius(options.maxZoom),\n      maxTileDensity: options.maxTileDensity,\n      tileOverlapZoomThreshold: options.tileOverlapZoomThreshold\n    };\n\n    L.Util.setOptions(this, options);\n\n    // Layers present in the protocol buffer responses.\n    this.layers = {};\n    this.outstandingTileDataRequests = {};\n    this.map = null;\n    this.delayedTileDataRequests = [];\n    this.firstRequest = true;\n    this.debouncedFlushOutstandingQueue = _.debounce(\n      this.flushOutstandingQueue,\n      this.options.debounceMilliseconds\n    );\n\n    // Each tile has its own quad tree containing points in that tile.\n    // On hover, for tiles within the threshold but not containing the hover\n    // point, we map the mouse coordinates to the coordinate space of the\n    // neighboring tile to test the neighboring tile's points that lie within\n    // the threshold of the hover point.\n    //\n    // We create a quad tree factory here to make it easier to make many quad\n    // trees with the same parameters.\n    maxThreshold = this.options.maxHoverThreshold;\n    tileSize = this.options.tileSize;\n\n    this.quadTreeFactory = d3.geom.quadtree();\n    this.quadTreeFactory.extent([\n      [-maxThreshold, -maxThreshold],\n      [tileSize + maxThreshold, tileSize + maxThreshold]\n    ]);\n    this.quadTreeFactory.x(_.property('x'));\n    this.quadTreeFactory.y(_.property('y'));\n\n    // Add a canvas layer for drawing highlighted points.\n    this.hoverHighlightLayer = L.tileLayer.canvas({ zIndex: 2 });\n\n    // Add a less dynamic canvas layer for drawing highlighted clicked points\n    this.clickHighlightLayer = L.tileLayer.canvas({ zIndex: 2 });\n\n    this.currentHoverPoints = [];\n    this.currentClickedPoints = [];\n\n    this.hoverHighlightLayer.drawTile = function(canvas, tilePoint, zoom) {\n      drawHighlightTile(canvas, tilePoint, zoom, self.currentHoverPoints);\n    };\n\n    this.clickHighlightLayer.drawTile = function(canvas, tilePoint, zoom) {\n      drawHighlightTile(canvas, tilePoint, zoom, self.currentClickedPoints);\n    };\n  },\n\n  onAdd: function(map) {\n\n    var self = this;\n    var mapMousedownCallback;\n    var mapMouseupCallback;\n    var mapMousemoveCallback;\n    var mapClickCallback;\n    var mapMouseoutCallback;\n\n    var mapDragstartCallback;\n    var mapZoomstartCallback;\n\n    var flannelClosedCallback;\n    var clearHighlightRequestCallback;\n\n    this.map = map;\n    this.hoverHighlightLayer.addTo(map);\n    this.clickHighlightLayer.addTo(map);\n\n    // For a given tile, mouse offset coordinates, and threshold,\n    // calculate the neighboring tiles (tiles other than the current tile\n    // that the user's mouse is within the threshold of.\n    // Returns array of neighboringTile objects containing\n    // tile id, offset.\n    function getNeighboringTiles(tile, mouseTileOffset, hoverThreshold) {\n\n      var neighboringTiles;\n      var tileSize = self.options.tileSize;\n\n      // Which tile edges are we close to?\n      var edgeTests = {\n        top: mouseTileOffset.y < hoverThreshold,\n        left: mouseTileOffset.x < hoverThreshold,\n        bottom: tileSize - mouseTileOffset.y < hoverThreshold,\n        right: tileSize - mouseTileOffset.x < hoverThreshold\n      };\n\n      // Now get those neighboring tile ids\n      neighboringTiles = _.compact(\n        _.map(\n          VectorTileUtil.hotspots,\n          function(hotspot) {\n\n            // hotspot is ['left'], ['left', 'top'], etc...\n            // This ensures that all edgeTests for the given hotspot values\n            // are true, which means that the mouse is within threshold of\n            // all hotspot values (aka edges).\n            if (_.all(_.at(edgeTests, hotspot), _.identity)) {\n              var neighborTile = _.clone(tile);\n              var neighborOffset = _.clone(mouseTileOffset);\n\n              _.each(hotspot, function(dir) {\n                VectorTileUtil.tileIdModifiers[dir](neighborTile);\n                VectorTileUtil.tileOffsetModifiers[VectorTileUtil.oppositeDirections[dir]](neighborOffset);\n              });\n\n              return {\n                id: VectorTileUtil.getTileId(neighborTile),\n                offset: neighborOffset\n              };\n            }\n\n            return false;\n          }\n        )\n      );\n\n      return neighboringTiles;\n    }\n\n    // Given a mouse event object, adds useful tile-related information to\n    // the event, such as the tile the mouse is hovering over and any points\n    // near the mouse (accounting for neighboring tiles). Keys added:\n    //  - tile: An object containing the x, y, and zoom values of the tile,\n    //          as well as an id in the form 'z:x:y'.\n    //  - tilePoint: Similar to layerPoint, containerPoint, etc. The mouse\n    //               coordinates relative to the current tile.\n    //  - points: An array of points near the mouse (see\n    //            VectorTileManager.options.hoverThreshold). Coordinates are\n    //            relative to the tile containing the point. Each point also\n    //            contains a 'count' key representing the number of rows of\n    //            data that the point represents.\n    function injectTileInfo(e) {\n\n      // TODO handle selecting layers and/or multiple layers better.\n      var layer = self.layers.main;\n\n      e.tile = VectorTileUtil.getTileInfoByPointAndZoomLevel(e.latlng, map.getZoom());\n      e.tile.id = VectorTileUtil.getTileId(e.tile);\n      e.tile.totalPoints = VectorTileUtil.getTileTotalPoints(layer, e.tile.id);\n\n      var tileCanvas = VectorTileUtil.getTileLayerCanvas(layer, e.tile.id);\n      var hoverThreshold = self.options.getHoverThreshold(map.getZoom());\n\n      if (_.isUndefined(tileCanvas)) {\n        e.points = [];\n        return;\n      }\n\n      var canvasBoundingRect = tileCanvas.getBoundingClientRect();\n      var mouseTileOffset = e.tilePoint = { // mouse coordinates relative to tile\n        x: e.originalEvent.clientX - canvasBoundingRect.left,\n        y: e.originalEvent.clientY - canvasBoundingRect.top\n      };\n\n      var tiles = [{id: e.tile.id, offset: mouseTileOffset}].\n        concat(getNeighboringTiles(e.tile, mouseTileOffset, hoverThreshold));\n\n      // For each tile near the mouse, visit nodes of its quad tree and\n      // push any nearby points onto an array.\n      var points = [];\n      _.each(tiles, function(tile) {\n        var qt = layer.quadTreesByTile[tile.id];\n        var point = tile.offset;\n\n        if (qt) {\n          qt.visit(function(node, x1, y1, x2, y2) {\n            var nodePoint = node.point;\n\n            // If this node has a point and it is near the mouse, push it\n            // onto the result array.\n            if (nodePoint) {\n              var dx = Math.pow(nodePoint.x - point.x, 2);\n              var dy = Math.pow(nodePoint.y - point.y, 2);\n              if (dx + dy < Math.pow(hoverThreshold, 2)) {\n                points.push(nodePoint);\n              }\n            }\n\n            // return false if this node's bounding box does not intersect\n            // the square around the mouse to prevent descending into\n            // children that will definitely not contain any nearby points.\n            return (x1 > point.x + hoverThreshold) ||\n              (x2 < point.x - hoverThreshold) ||\n              (y1 > point.y + hoverThreshold) ||\n              (y2 < point.y - hoverThreshold);\n          });\n        }\n      });\n\n      // Redraw highlight layer, but only if set of hover points has changed\n      if (!_.isEqual(self.currentHoverPoints, points)) {\n        self.currentHoverPoints = points;\n        highlightPoints(self.hoverHighlightLayer);\n      }\n\n      e.points = points;\n    }\n\n    function highlightClickedPoints(clickedPoints) {\n\n      if (!_.isEqual(self.currentClickedPoints, clickedPoints)) {\n        self.currentClickedPoints = clickedPoints;\n        highlightPoints(self.clickHighlightLayer);\n      }\n\n      if (_.isEqual(self.currentClickedPoints, self.currentHoverPoints)) {\n        // Remove hover highlighting on points now highlighted by click\n        self.currentHoverPoints = [];\n        highlightPoints(self.hoverHighlightLayer);\n      }\n    }\n\n    function highlightPoints(layerToHighlight) {\n\n      _.each(layerToHighlight._tiles, function(canvas, tileId) {\n\n        var coordinates = tileId.split(':');\n        var tile = { x: coordinates[0], y: coordinates[1] };\n\n        layerToHighlight.drawTile(canvas, tile, map.getZoom());\n      });\n    }\n\n    self.clearClickedPointHighlights = function clearClickedPointHighlights() {\n\n      if (!_.isEmpty(self.currentClickedPoints)) {\n\n        self.currentClickedPoints = [];\n        highlightPoints(self.clickHighlightLayer);\n      }\n    };\n\n    self.clearHoverPointHighlights = function clearHoverPointHighlights() {\n\n      if (!_.isEmpty(self.currentHoverPoints)) {\n\n        self.currentHoverPoints = [];\n        highlightPoints(self.hoverHighlightLayer);\n      }\n    };\n\n    // Handle callbacks for executable functions of events\n    if (_.isFunction(this.options.onMousedown)) {\n\n      mapMousedownCallback = function(e) {\n\n        injectTileInfo(e);\n        self.options.onMousedown(e);\n      };\n\n      map.on('mousedown', mapMousedownCallback);\n    }\n\n    if (_.isFunction(this.options.onMouseup)) {\n\n      mapMouseupCallback = function(e) {\n\n        injectTileInfo(e);\n        self.options.onMouseup(e);\n      };\n\n      map.on('mouseup', mapMouseupCallback);\n    }\n\n    if (_.isFunction(this.options.onMousemove)) {\n\n      mapMousemoveCallback = function(e) {\n\n        if (self.options.hover) {\n          // Only execute mousemove if not disabled during map load\n          if (self.options.interactive) {\n            injectTileInfo(e);\n            self.options.onMousemove(e);\n          }\n        } else {\n          self.options.onMousemove(e);\n        }\n      };\n\n      map.on('mousemove', mapMousemoveCallback);\n    }\n\n    if (_.isFunction(this.options.onClick)) {\n\n      mapClickCallback = function(e) {\n\n        if (self.options.hover && self.options.interactive) {\n\n          injectTileInfo(e);\n\n          // Only execute click if data under cursor does not exceed inspector\n          // row density.\n          //\n          // NOTE: `self.options` (which refers to the VectorTileManager\n          // instance options) is not the same as `this.options` (which refers\n          // to the map instance options).\n          var manyRows = _.sum(e.points, 'count') > self.options.rowInspectorMaxRowDensity;\n\n          if (!manyRows) {\n            highlightClickedPoints(e.points);\n            self.options.onClick(e);\n          } else {\n            // clear any existing highlights that are hanging around\n            self.clearClickedPointHighlights();\n          }\n\n        } else {\n          self.options.onClick(e);\n        }\n      };\n\n      map.on('click', mapClickCallback);\n    }\n\n    if (self.options.hover) {\n      mapMouseoutCallback = function() {\n        self.clearHoverPointHighlights();\n      };\n\n      map.on('mouseout', mapMouseoutCallback);\n\n      // Ensure highlighting on points previously clicked under closed flannel\n      // is cleared, but points highlighted under a new flannel remain.\n      flannelClosedCallback = function(e) {\n        var pointsToKeepHighlighted = self.currentClickedPoints.filter(function(value) {\n          return !_.contains(e.points, value);\n        });\n        highlightClickedPoints(pointsToKeepHighlighted);\n      };\n\n      map.on('flannelclosed', flannelClosedCallback);\n\n      // Upon map refresh due to adding or removing a filter,\n      // remove highlighting on all clicked and moused-over points\n      clearHighlightRequestCallback = function() {\n        self.clearClickedPointHighlights();\n        self.clearHoverPointHighlights();\n      };\n\n      map.on('clearhighlightrequest', clearHighlightRequestCallback);\n    }\n\n    mapDragstartCallback = function() {\n      self.clearHoverPointHighlights();\n      self.clearClickedPointHighlights();\n    };\n\n    map.on('dragstart', mapDragstartCallback);\n\n    mapZoomstartCallback = function() {\n      self.clearHoverPointHighlights();\n      self.clearClickedPointHighlights();\n    };\n\n    map.on('zoomstart', mapZoomstartCallback);\n\n    map.on('layerremove', function(e) {\n\n      // Check to see if the layer removed is this one and if it is,\n      // remove its child layers.\n      if (e.layer._leaflet_id === self._leaflet_id && e.layer.removeChildLayers) {\n\n        e.layer.removeChildLayers(map);\n\n        if (_.isFunction(self.options.onMousedown)) {\n          map.off('mousedown', mapMousedownCallback);\n        }\n\n        if (_.isFunction(self.options.onMouseup)) {\n          map.off('mouseup', mapMouseupCallback);\n        }\n\n        if (_.isFunction(self.options.onMousemove)) {\n          map.off('mousemove', mapMousemoveCallback);\n        }\n\n        if (_.isFunction(self.options.onClick)) {\n          map.off('click', mapClickCallback);\n        }\n\n        if (self.options.hover) {\n          map.off('mouseout', mapMouseoutCallback);\n          map.off('flannelclosed', flannelClosedCallback);\n          map.off('clearhighlightrequest', clearHighlightRequestCallback);\n        }\n\n        map.off('dragstart', mapDragstartCallback);\n        map.off('zoomstart', mapZoomstartCallback);\n      }\n    });\n\n    this.addChildLayers();\n\n    L.TileLayer.Canvas.prototype.onAdd.call(this, map);\n  },\n\n  drawTile: function(canvas, tilePoint, zoom) {\n\n    if (this.options.debug) {\n      this.renderDebugInfo(tilePoint, zoom);\n    }\n\n    this.debounceGetTileData(tilePoint, zoom, this.processVectorTileLayers);\n  },\n\n  debounceGetTileData: function(tilePoint, zoom, callback) {\n\n    var userHasZoomed;\n\n    if (this.firstRequest) {\n      this.lastCommitedZoomLevel = zoom;\n      this.firstRequest = false;\n    }\n\n    userHasZoomed = _.isUndefined(this.lastCommitedZoomLevel) || this.lastCommitedZoomLevel !== zoom;\n\n    this.lastSeenZoomLevel = zoom;\n\n    if (userHasZoomed) {\n\n      this.lastCommitedZoomLevel = undefined;\n      this.delayedTileDataRequests.push({\n        tilePoint: tilePoint,\n        zoom: zoom,\n        callback: callback\n      });\n\n      this.tileLoading(VectorTileUtil.getTileId({x: tilePoint.x, y: tilePoint.y, zoom: zoom}));\n\n    } else {\n\n      this.getTileData(tilePoint, zoom, callback);\n\n    }\n\n    this.debouncedFlushOutstandingQueue();\n  },\n\n  flushOutstandingQueue: function() {\n\n    var self = this;\n\n    this.lastCommitedZoomLevel = this.lastSeenZoomLevel;\n\n    _.each(this.delayedTileDataRequests, function(request) {\n\n      if (request.zoom === self.lastCommitedZoomLevel) {\n        self.getTileData(request.tilePoint, request.zoom, request.callback);\n      } else {\n        // CORE-6027:\n        // Clear the outstandingTileDataRequests because we shouldn't attempt to load tiles\n        // on the previous zoom level.\n        self.outstandingTileDataRequests = {};\n      }\n    });\n\n    this.delayedTileDataRequests.length = 0;\n  },\n\n  getTileData: function(tilePoint, zoom, callback) {\n\n    var self = this;\n    var tileId = VectorTileUtil.getTileId({x: tilePoint.x, y: tilePoint.y, zoom: zoom});\n    var getterPromise;\n\n    // Don't re-request tiles that are already outstanding.\n    if (self.outstandingTileDataRequests.hasOwnProperty(tileId) &&\n      self.outstandingTileDataRequests[tileId] !== null) {\n      return;\n    }\n\n    getterPromise = self.options.vectorTileGetter(zoom, tilePoint.x, tilePoint.y);\n\n    self.tileLoading(tileId, getterPromise);\n\n    getterPromise.then(\n      function(response) {\n\n        if (_.isEmpty(response.data)) {\n          self.tileLoaded(tileId);\n        } else {\n          callback.call(self, response.data, tileId);\n        }\n      },\n      function() {\n        self.tileLoaded(tileId);\n      }\n    ).catch(\n      function(error) {\n        throw error;\n      }\n    );\n  },\n\n  renderDebugInfo: function(tilePoint, zoom) {\n\n    var ctx = this._tiles[tilePoint.x + ':' + tilePoint.y].getContext('2d');\n    var tileSize = this.options.tileSize;\n\n    ctx.strokeStyle = '#000000';\n    ctx.fillStyle = '#ffff00';\n    ctx.font = '12px Arial';\n\n    // Border\n    ctx.strokeRect(0, 0, tileSize, tileSize);\n    // Top-left corner\n    ctx.fillRect(0, 0, 5, 5);\n    // Top-right corner\n    ctx.fillRect(0, (tileSize - 5), 5, 5);\n    // Bottom-left corner\n    ctx.fillRect(tileSize - 5, 0, 5, 5);\n    // Bottom-right corner\n    ctx.fillRect(tileSize - 5, tileSize - 5, 5, 5);\n    // Center\n    ctx.fillRect(tileSize / 2 - 5, tileSize / 2 - 5, 10, 10);\n    // Label\n    ctx.strokeText(zoom + ':' + tilePoint.x + ':' + tilePoint.y, tileSize / 2 - 30, tileSize / 2 - 10);\n  },\n\n  processVectorTileLayers: function(arrayBuffer, tileId) {\n\n    var self = this;\n    var vectorTile;\n    var layerIds;\n    var i;\n    var layerId;\n    var layer;\n\n    function tileRenderedCallback() {\n      self.tileLoaded(tileId);\n    }\n\n    // VectorTile is a Leaflet global variable\n    vectorTile = VectorTileUtil.unpackVectorTile(\n      new VectorTile(\n        new pbf(arrayBuffer)\n      )\n    );\n\n    layerIds = Object.keys(vectorTile.layers);\n    i = layerIds.length;\n\n    if (i === 0) {\n      tileRenderedCallback();\n      return;\n    }\n\n    while (i--) {\n\n      layerId = layerIds[i];\n      layer = vectorTile.layers[layerId];\n\n      if (!this.layers.hasOwnProperty(layerId)) {\n\n        var newLayer = new VectorTileLayer(\n          this,\n          {\n            name: layerId,\n            getFeatureStyle: this.getFeatureStyle\n          }\n        );\n\n        this.layers[layerId] = newLayer;\n        newLayer.addTo(this.map);\n      }\n\n      this.layers[layerId].loadData(layer, tileId, tileRenderedCallback);\n    }\n  },\n\n  addChildLayers: function() {\n\n    var self = this;\n\n    Object.keys(this.layers).forEach(function(layerId) {\n\n      var layer = this.layers[layerId];\n\n      if (layer.hasOwnProperty('_map')) {\n        self.map.addLayer(layer);\n      }\n    });\n  },\n\n  removeChildLayers: function() {\n\n    var self = this;\n\n    Object.keys(self.layers).forEach(function(layerId) {\n\n      var layer = self.layers[layerId];\n\n      self.map.removeLayer(layer);\n    });\n  },\n\n  tileLoading: function(tileId, getterPromise) {\n\n    if (Object.keys(this.outstandingTileDataRequests).length === 0) {\n      this.options.onRenderStart();\n    }\n\n    this.outstandingTileDataRequests[tileId] = getterPromise || null;\n  },\n\n  tileLoaded: function(tileId) {\n\n    var self = this;\n\n    delete this.outstandingTileDataRequests[tileId];\n\n    if (Object.keys(this.outstandingTileDataRequests).length === 0) {\n      if (this.lastCommitedZoomLevel > this.options.tileOverlapZoomThreshold) {\n\n        Object.keys(self.layers).forEach(function(layerId) {\n          var layer = self.layers[layerId];\n\n          _.each(_.keys(layer.featuresByTile), function(tile) {\n            layer.renderTileOverlap(tile);\n          });\n        });\n      }\n\n      // Set the layer's interactivity to true so that we will begin to\n      // handle events.\n      this.options.interactive = true;\n\n      // Clear all related highlights.\n      this.clearClickedPointHighlights();\n      this.clearHoverPointHighlights();\n\n      // Inform the caller that the layer has completed rendering.\n      this.options.onRenderComplete();\n    }\n  }\n});\n\nmodule.exports = {\n  VectorTileUtil: VectorTileUtil,\n  VectorTileFeature: VectorTileFeature,\n  VectorTileLayer: VectorTileLayer\n};\n// module also has the side effect of setting L.TileLayer.VectorTileManager.\n// not sure if this will work for Webpack.\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/dataProviders/VectorTileManager.js\n ** module id = 28\n ** module chunks = 0\n **/","'use strict';\n\nmodule.exports.VectorTile = require('./lib/vectortile.js');\nmodule.exports.VectorTileFeature = require('./lib/vectortilefeature.js');\nmodule.exports.VectorTileLayer = require('./lib/vectortilelayer.js');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vector-tile/index.js\n ** module id = 29\n ** module chunks = 0\n **/","'use strict';\n\n'use strict';\n\nvar VectorTileLayer = require('./vectortilelayer');\n\nmodule.exports = VectorTile;\n\nfunction VectorTile(buffer, end) {\n\n    this.layers = {};\n    this._buffer = buffer;\n\n    end = end || buffer.length;\n\n    while (buffer.pos < end) {\n        var val = buffer.readVarint(),\n            tag = val >> 3;\n\n        if (tag == 3) {\n            var layer = this.readLayer();\n            if (layer.length) this.layers[layer.name] = layer;\n        } else {\n            buffer.skip(val);\n        }\n    }\n}\n\nVectorTile.prototype.readLayer = function() {\n    var buffer = this._buffer,\n        bytes = buffer.readVarint(),\n        end = buffer.pos + bytes,\n        layer = new VectorTileLayer(buffer, end);\n\n    buffer.pos = end;\n\n    return layer;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vector-tile/lib/vectortile.js\n ** module id = 30\n ** module chunks = 0\n **/","'use strict';\n\n'use strict';\n\nvar VectorTileFeature = require('./vectortilefeature.js');\n\nmodule.exports = VectorTileLayer;\nfunction VectorTileLayer(buffer, end) {\n    // Public\n    this.version = 1;\n    this.name = null;\n    this.extent = 4096;\n    this.length = 0;\n\n    // Private\n    this._buffer = buffer;\n    this._keys = [];\n    this._values = [];\n    this._features = [];\n\n    var val, tag;\n\n    end = end || buffer.length;\n\n    while (buffer.pos < end) {\n        val = buffer.readVarint();\n        tag = val >> 3;\n\n        if (tag === 15) {\n            this.version = buffer.readVarint();\n        } else if (tag === 1) {\n            this.name = buffer.readString();\n        } else if (tag === 5) {\n            this.extent = buffer.readVarint();\n        } else if (tag === 2) {\n            this.length++;\n            this._features.push(buffer.pos);\n            buffer.skip(val);\n\n        } else if (tag === 3) {\n            this._keys.push(buffer.readString());\n        } else if (tag === 4) {\n            this._values.push(this.readFeatureValue());\n        } else {\n            buffer.skip(val);\n        }\n    }\n}\n\nVectorTileLayer.prototype.readFeatureValue = function() {\n    var buffer = this._buffer,\n        value = null,\n        bytes = buffer.readVarint(),\n        end = buffer.pos + bytes,\n        val, tag;\n\n    while (buffer.pos < end) {\n        val = buffer.readVarint();\n        tag = val >> 3;\n\n        if (tag == 1) {\n            value = buffer.readString();\n        } else if (tag == 2) {\n            throw new Error('read float');\n        } else if (tag == 3) {\n            value = buffer.readDouble();\n        } else if (tag == 4) {\n            value = buffer.readVarint();\n        } else if (tag == 5) {\n            throw new Error('read uint');\n        } else if (tag == 6) {\n            value = buffer.readSVarint();\n        } else if (tag == 7) {\n            value = Boolean(buffer.readVarint());\n        } else {\n            buffer.skip(val);\n        }\n    }\n\n    return value;\n};\n\n// return feature `i` from this layer as a `VectorTileFeature`\nVectorTileLayer.prototype.feature = function(i) {\n    if (i < 0 || i >= this._features.length) throw new Error('feature index out of bounds');\n\n    this._buffer.pos = this._features[i];\n    var end = this._buffer.readVarint() + this._buffer.pos;\n\n    return new VectorTileFeature(this._buffer, end, this.extent, this._keys, this._values);\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vector-tile/lib/vectortilelayer.js\n ** module id = 31\n ** module chunks = 0\n **/","'use strict';\n\n'use strict';\n\nvar Point = require('point-geometry');\n\nmodule.exports = VectorTileFeature;\n\nfunction VectorTileFeature(buffer, end, extent, keys, values) {\n\n    this.properties = {};\n\n    // Public\n    this.extent = extent;\n    this.type = 0;\n\n    // Private\n    this._buffer = buffer;\n    this._geometry = -1;\n\n    end = end || buffer.length;\n\n    while (buffer.pos < end) {\n        var val = buffer.readVarint(),\n            tag = val >> 3;\n\n        if (tag == 1) {\n            this._id = buffer.readVarint();\n\n        } else if (tag == 2) {\n            var tagEnd = buffer.pos + buffer.readVarint();\n\n            while (buffer.pos < tagEnd) {\n                var key = keys[buffer.readVarint()];\n                var value = values[buffer.readVarint()];\n                this.properties[key] = value;\n            }\n\n        } else if (tag == 3) {\n            this.type = buffer.readVarint();\n\n        } else if (tag == 4) {\n            this._geometry = buffer.pos;\n            buffer.skip(val);\n\n        } else {\n            buffer.skip(val);\n        }\n    }\n}\n\nVectorTileFeature.types = ['Unknown', 'Point', 'LineString', 'Polygon'];\n\nVectorTileFeature.prototype.loadGeometry = function() {\n    var buffer = this._buffer;\n    buffer.pos = this._geometry;\n\n    var bytes = buffer.readVarint(),\n        end = buffer.pos + bytes,\n        cmd = 1,\n        length = 0,\n        x = 0,\n        y = 0,\n        lines = [],\n        line;\n\n    while (buffer.pos < end) {\n        if (!length) {\n            var cmd_length = buffer.readVarint();\n            cmd = cmd_length & 0x7;\n            length = cmd_length >> 3;\n        }\n\n        length--;\n\n        if (cmd === 1 || cmd === 2) {\n            x += buffer.readSVarint();\n            y += buffer.readSVarint();\n\n            if (cmd === 1) {\n                // moveTo\n                if (line) {\n                    lines.push(line);\n                }\n                line = [];\n            }\n\n            line.push(new Point(x, y));\n        } else if (cmd === 7) {\n            // closePolygon\n            line.push(line[0].clone());\n        } else {\n            throw new Error('unknown command ' + cmd);\n        }\n    }\n\n    if (line) lines.push(line);\n\n    return lines;\n};\n\nVectorTileFeature.prototype.bbox = function() {\n    var buffer = this._buffer;\n    buffer.pos = this._geometry;\n\n    var bytes = buffer.readVarint(),\n        end = buffer.pos + bytes,\n\n        cmd = 1,\n        length = 0,\n        x = 0,\n        y = 0,\n        x1 = Infinity,\n        x2 = -Infinity,\n        y1 = Infinity,\n        y2 = -Infinity;\n\n    while (buffer.pos < end) {\n        if (!length) {\n            var cmd_length = buffer.readVarint();\n            cmd = cmd_length & 0x7;\n            length = cmd_length >> 3;\n        }\n\n        length--;\n\n        if (cmd === 1 || cmd === 2) {\n            x += buffer.readSVarint();\n            y += buffer.readSVarint();\n            if (x < x1) x1 = x;\n            if (x > x2) x2 = x;\n            if (y < y1) y1 = y;\n            if (y > y2) y2 = y;\n\n        } else if (cmd !== 7) {\n            throw new Error('unknown command ' + cmd);\n        }\n    }\n\n    return [x1, y1, x2, y2];\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vector-tile/lib/vectortilefeature.js\n ** module id = 32\n ** module chunks = 0\n **/","'use strict';\n\n'use strict';\n\nmodule.exports = Point;\n\nfunction Point(x, y) {\n    this.x = x;\n    this.y = y;\n}\n\nPoint.prototype = {\n    clone: function() { return new Point(this.x, this.y); },\n\n    add:     function(p) { return this.clone()._add(p);     },\n    sub:     function(p) { return this.clone()._sub(p);     },\n    mult:    function(k) { return this.clone()._mult(k);    },\n    div:     function(k) { return this.clone()._div(k);     },\n    rotate:  function(a) { return this.clone()._rotate(a);  },\n    matMult: function(m) { return this.clone()._matMult(m); },\n    unit:    function() { return this.clone()._unit(); },\n    perp:    function() { return this.clone()._perp(); },\n    round:   function() { return this.clone()._round(); },\n\n    mag: function() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    },\n\n    equals: function(p) {\n        return this.x === p.x &&\n               this.y === p.y;\n    },\n\n    dist: function(p) {\n        return Math.sqrt(this.distSqr(p));\n    },\n\n    distSqr: function(p) {\n        var dx = p.x - this.x,\n            dy = p.y - this.y;\n        return dx * dx + dy * dy;\n    },\n\n    angle: function() {\n        return Math.atan2(this.y, this.x);\n    },\n\n    angleTo: function(b) {\n        return Math.atan2(this.y - b.y, this.x - b.x);\n    },\n\n    angleWith: function(b) {\n        return this.angleWithSep(b.x, b.y);\n    },\n\n    // Find the angle of the two vectors, solving the formula for the cross product a x b = |a||b|sin(θ) for θ.\n    angleWithSep: function(x, y) {\n        return Math.atan2(\n            this.x * y - this.y * x,\n            this.x * x + this.y * y);\n    },\n\n    _matMult: function(m) {\n        var x = m[0] * this.x + m[1] * this.y,\n            y = m[2] * this.x + m[3] * this.y;\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    _add: function(p) {\n        this.x += p.x;\n        this.y += p.y;\n        return this;\n    },\n\n    _sub: function(p) {\n        this.x -= p.x;\n        this.y -= p.y;\n        return this;\n    },\n\n    _mult: function(k) {\n        this.x *= k;\n        this.y *= k;\n        return this;\n    },\n\n    _div: function(k) {\n        this.x /= k;\n        this.y /= k;\n        return this;\n    },\n\n    _unit: function() {\n        this._div(this.mag());\n        return this;\n    },\n\n    _perp: function() {\n        var y = this.y;\n        this.y = this.x;\n        this.x = -y;\n        return this;\n    },\n\n    _rotate: function(angle) {\n        var cos = Math.cos(angle),\n            sin = Math.sin(angle),\n            x = cos * this.x - sin * this.y,\n            y = sin * this.x + cos * this.y;\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    _round: function() {\n        this.x = Math.round(this.x);\n        this.y = Math.round(this.y);\n        return this;\n    }\n};\n\n// constructs Point from an array if necessary\nPoint.convert = function (a) {\n    if (a instanceof Point) {\n        return a;\n    }\n    if (Array.isArray(a)) {\n        return new Point(a[0], a[1]);\n    }\n    return a;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/point-geometry/index.js\n ** module id = 33\n ** module chunks = 0\n **/","'use strict';\n\n'use strict';\n\nmodule.exports = Pbf;\n\nvar Buffer = global.Buffer || require('./buffer');\n\nfunction Pbf(buf) {\n    this.buf = !Buffer.isBuffer(buf) ? new Buffer(buf || 0) : buf;\n    this.pos = 0;\n    this.length = this.buf.length;\n}\n\nPbf.Varint  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum\nPbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64\nPbf.Bytes   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields\nPbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32\n\nvar SHIFT_LEFT_32 = (1 << 16) * (1 << 16),\n    SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32,\n    POW_2_63 = Math.pow(2, 63);\n\nPbf.prototype = {\n\n    destroy: function() {\n        this.buf = null;\n    },\n\n    // === READING =================================================================\n\n    readFields: function(readField, result, end) {\n        end = end || this.length;\n\n        while (this.pos < end) {\n            var val = this.readVarint(),\n                tag = val >> 3,\n                startPos = this.pos;\n\n            readField(tag, result, this);\n\n            if (this.pos === startPos) this.skip(val);\n        }\n        return result;\n    },\n\n    readMessage: function(readField, result) {\n        return this.readFields(readField, result, this.readVarint() + this.pos);\n    },\n\n    readFixed32: function() {\n        var val = this.buf.readUInt32LE(this.pos);\n        this.pos += 4;\n        return val;\n    },\n\n    readSFixed32: function() {\n        var val = this.buf.readInt32LE(this.pos);\n        this.pos += 4;\n        return val;\n    },\n\n    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)\n\n    readFixed64: function() {\n        var val = this.buf.readUInt32LE(this.pos) + this.buf.readUInt32LE(this.pos + 4) * SHIFT_LEFT_32;\n        this.pos += 8;\n        return val;\n    },\n\n    readSFixed64: function() {\n        var val = this.buf.readUInt32LE(this.pos) + this.buf.readInt32LE(this.pos + 4) * SHIFT_LEFT_32;\n        this.pos += 8;\n        return val;\n    },\n\n    readFloat: function() {\n        var val = this.buf.readFloatLE(this.pos);\n        this.pos += 4;\n        return val;\n    },\n\n    readDouble: function() {\n        var val = this.buf.readDoubleLE(this.pos);\n        this.pos += 8;\n        return val;\n    },\n\n    readVarint: function() {\n        var buf = this.buf,\n            val, b, b0, b1, b2, b3;\n\n        b0 = buf[this.pos++]; if (b0 < 0x80) return b0;                 b0 = b0 & 0x7f;\n        b1 = buf[this.pos++]; if (b1 < 0x80) return b0 | b1 << 7;       b1 = (b1 & 0x7f) << 7;\n        b2 = buf[this.pos++]; if (b2 < 0x80) return b0 | b1 | b2 << 14; b2 = (b2 & 0x7f) << 14;\n        b3 = buf[this.pos++]; if (b3 < 0x80) return b0 | b1 | b2 | b3 << 21;\n\n        val = b0 | b1 | b2 | (b3 & 0x7f) << 21;\n\n        b = buf[this.pos++]; val += (b & 0x7f) * 0x10000000;         if (b < 0x80) return val;\n        b = buf[this.pos++]; val += (b & 0x7f) * 0x800000000;        if (b < 0x80) return val;\n        b = buf[this.pos++]; val += (b & 0x7f) * 0x40000000000;      if (b < 0x80) return val;\n        b = buf[this.pos++]; val += (b & 0x7f) * 0x2000000000000;    if (b < 0x80) return val;\n        b = buf[this.pos++]; val += (b & 0x7f) * 0x100000000000000;  if (b < 0x80) return val;\n        b = buf[this.pos++]; val += (b & 0x7f) * 0x8000000000000000; if (b < 0x80) return val;\n\n        throw new Error('Expected varint not more than 10 bytes');\n    },\n\n    readVarint64: function() {\n        var startPos = this.pos,\n            val = this.readVarint();\n\n        if (val < POW_2_63) return val;\n\n        var pos = this.pos - 2;\n        while (this.buf[pos] === 0xff) pos--;\n        if (pos < startPos) pos = startPos;\n\n        val = 0;\n        for (var i = 0; i < pos - startPos + 1; i++) {\n            var b = ~this.buf[startPos + i] & 0x7f;\n            val += i < 4 ? b << i * 7 : b * Math.pow(2, i * 7);\n        }\n\n        return -val - 1;\n    },\n\n    readSVarint: function() {\n        var num = this.readVarint();\n        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding\n    },\n\n    readBoolean: function() {\n        return Boolean(this.readVarint());\n    },\n\n    readString: function() {\n        var end = this.readVarint() + this.pos,\n            str = this.buf.toString('utf8', this.pos, end);\n        this.pos = end;\n        return str;\n    },\n\n    readBytes: function() {\n        var end = this.readVarint() + this.pos,\n            buffer = this.buf.slice(this.pos, end);\n        this.pos = end;\n        return buffer;\n    },\n\n    // verbose for performance reasons; doesn't affect gzipped size\n\n    readPackedVarint: function() {\n        var end = this.readVarint() + this.pos, arr = [];\n        while (this.pos < end) arr.push(this.readVarint());\n        return arr;\n    },\n    readPackedSVarint: function() {\n        var end = this.readVarint() + this.pos, arr = [];\n        while (this.pos < end) arr.push(this.readSVarint());\n        return arr;\n    },\n    readPackedBoolean: function() {\n        var end = this.readVarint() + this.pos, arr = [];\n        while (this.pos < end) arr.push(this.readBoolean());\n        return arr;\n    },\n    readPackedFloat: function() {\n        var end = this.readVarint() + this.pos, arr = [];\n        while (this.pos < end) arr.push(this.readFloat());\n        return arr;\n    },\n    readPackedDouble: function() {\n        var end = this.readVarint() + this.pos, arr = [];\n        while (this.pos < end) arr.push(this.readDouble());\n        return arr;\n    },\n    readPackedFixed32: function() {\n        var end = this.readVarint() + this.pos, arr = [];\n        while (this.pos < end) arr.push(this.readFixed32());\n        return arr;\n    },\n    readPackedSFixed32: function() {\n        var end = this.readVarint() + this.pos, arr = [];\n        while (this.pos < end) arr.push(this.readSFixed32());\n        return arr;\n    },\n    readPackedFixed64: function() {\n        var end = this.readVarint() + this.pos, arr = [];\n        while (this.pos < end) arr.push(this.readFixed64());\n        return arr;\n    },\n    readPackedSFixed64: function() {\n        var end = this.readVarint() + this.pos, arr = [];\n        while (this.pos < end) arr.push(this.readSFixed64());\n        return arr;\n    },\n\n    skip: function(val) {\n        var type = val & 0x7;\n        if (type === Pbf.Varint) while (this.buf[this.pos++] > 0x7f) {}\n        else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;\n        else if (type === Pbf.Fixed32) this.pos += 4;\n        else if (type === Pbf.Fixed64) this.pos += 8;\n        else throw new Error('Unimplemented type: ' + type);\n    },\n\n    // === WRITING =================================================================\n\n    writeTag: function(tag, type) {\n        this.writeVarint((tag << 3) | type);\n    },\n\n    realloc: function(min) {\n        var length = this.length || 16;\n\n        while (length < this.pos + min) length *= 2;\n\n        if (length !== this.length) {\n            var buf = new Buffer(length);\n            this.buf.copy(buf);\n            this.buf = buf;\n            this.length = length;\n        }\n    },\n\n    finish: function() {\n        this.length = this.pos;\n        this.pos = 0;\n        return this.buf.slice(0, this.length);\n    },\n\n    writeFixed32: function(val) {\n        this.realloc(4);\n        this.buf.writeUInt32LE(val, this.pos);\n        this.pos += 4;\n    },\n\n    writeSFixed32: function(val) {\n        this.realloc(4);\n        this.buf.writeInt32LE(val, this.pos);\n        this.pos += 4;\n    },\n\n    writeFixed64: function(val) {\n        this.realloc(8);\n        this.buf.writeInt32LE(val & -1, this.pos);\n        this.buf.writeUInt32LE(Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);\n        this.pos += 8;\n    },\n\n    writeSFixed64: function(val) {\n        this.realloc(8);\n        this.buf.writeInt32LE(val & -1, this.pos);\n        this.buf.writeInt32LE(Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);\n        this.pos += 8;\n    },\n\n    writeVarint: function(val) {\n        val = +val;\n\n        if (val <= 0x7f) {\n            this.realloc(1);\n            this.buf[this.pos++] = val;\n\n        } else if (val <= 0x3fff) {\n            this.realloc(2);\n            this.buf[this.pos++] = ((val >>> 0) & 0x7f) | 0x80;\n            this.buf[this.pos++] = ((val >>> 7) & 0x7f);\n\n        } else if (val <= 0x1fffff) {\n            this.realloc(3);\n            this.buf[this.pos++] = ((val >>> 0) & 0x7f) | 0x80;\n            this.buf[this.pos++] = ((val >>> 7) & 0x7f) | 0x80;\n            this.buf[this.pos++] = ((val >>> 14) & 0x7f);\n\n        } else if (val <= 0xfffffff) {\n            this.realloc(4);\n            this.buf[this.pos++] = ((val >>> 0) & 0x7f) | 0x80;\n            this.buf[this.pos++] = ((val >>> 7) & 0x7f) | 0x80;\n            this.buf[this.pos++] = ((val >>> 14) & 0x7f) | 0x80;\n            this.buf[this.pos++] = ((val >>> 21) & 0x7f);\n\n        } else {\n            var pos = this.pos;\n            while (val >= 0x80) {\n                this.realloc(1);\n                this.buf[this.pos++] = (val & 0xff) | 0x80;\n                val /= 0x80;\n            }\n            this.realloc(1);\n            this.buf[this.pos++] = val | 0;\n            if (this.pos - pos > 10) throw new Error('Given varint doesn\\'t fit into 10 bytes');\n        }\n    },\n\n    writeSVarint: function(val) {\n        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);\n    },\n\n    writeBoolean: function(val) {\n        this.writeVarint(Boolean(val));\n    },\n\n    writeString: function(str) {\n        str = String(str);\n        var bytes = Buffer.byteLength(str);\n        this.writeVarint(bytes);\n        this.realloc(bytes);\n        this.buf.write(str, this.pos);\n        this.pos += bytes;\n    },\n\n    writeFloat: function(val) {\n        this.realloc(4);\n        this.buf.writeFloatLE(val, this.pos);\n        this.pos += 4;\n    },\n\n    writeDouble: function(val) {\n        this.realloc(8);\n        this.buf.writeDoubleLE(val, this.pos);\n        this.pos += 8;\n    },\n\n    writeBytes: function(buffer) {\n        var len = buffer.length;\n        this.writeVarint(len);\n        this.realloc(len);\n        for (var i = 0; i < len; i++) this.buf[this.pos++] = buffer[i];\n    },\n\n    writeRawMessage: function(fn, obj) {\n        this.pos++; // reserve 1 byte for short message length\n\n        // write the message directly to the buffer and see how much was written\n        var startPos = this.pos;\n        fn(obj, this);\n        var len = this.pos - startPos;\n\n        var varintLen =\n            len <= 0x7f ? 1 :\n            len <= 0x3fff ? 2 :\n            len <= 0x1fffff ? 3 :\n            len <= 0xfffffff ? 4 : Math.ceil(Math.log(len) / (Math.LN2 * 7));\n\n        // if 1 byte isn't enough for encoding message length, shift the data to the right\n        if (varintLen > 1) {\n            this.realloc(varintLen - 1);\n            for (var i = this.pos - 1; i >= startPos; i--) this.buf[i + varintLen - 1] = this.buf[i];\n        }\n\n        // finally, write the message length in the reserved place and restore the position\n        this.pos = startPos - 1;\n        this.writeVarint(len);\n        this.pos += len;\n    },\n\n    writeMessage: function(tag, fn, obj) {\n        this.writeTag(tag, Pbf.Bytes);\n        this.writeRawMessage(fn, obj);\n    },\n\n    writePackedVarint:   function(tag, arr) { this.writeMessage(tag, writePackedVarint, arr);   },\n    writePackedSVarint:  function(tag, arr) { this.writeMessage(tag, writePackedSVarint, arr);  },\n    writePackedBoolean:  function(tag, arr) { this.writeMessage(tag, writePackedBoolean, arr);  },\n    writePackedFloat:    function(tag, arr) { this.writeMessage(tag, writePackedFloat, arr);    },\n    writePackedDouble:   function(tag, arr) { this.writeMessage(tag, writePackedDouble, arr);   },\n    writePackedFixed32:  function(tag, arr) { this.writeMessage(tag, writePackedFixed32, arr);  },\n    writePackedSFixed32: function(tag, arr) { this.writeMessage(tag, writePackedSFixed32, arr); },\n    writePackedFixed64:  function(tag, arr) { this.writeMessage(tag, writePackedFixed64, arr);  },\n    writePackedSFixed64: function(tag, arr) { this.writeMessage(tag, writePackedSFixed64, arr); },\n\n    writeBytesField: function(tag, buffer) {\n        this.writeTag(tag, Pbf.Bytes);\n        this.writeBytes(buffer);\n    },\n    writeFixed32Field: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed32);\n        this.writeFixed32(val);\n    },\n    writeSFixed32Field: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed32);\n        this.writeSFixed32(val);\n    },\n    writeFixed64Field: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed64);\n        this.writeFixed64(val);\n    },\n    writeSFixed64Field: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed64);\n        this.writeSFixed64(val);\n    },\n    writeVarintField: function(tag, val) {\n        this.writeTag(tag, Pbf.Varint);\n        this.writeVarint(val);\n    },\n    writeSVarintField: function(tag, val) {\n        this.writeTag(tag, Pbf.Varint);\n        this.writeSVarint(val);\n    },\n    writeStringField: function(tag, str) {\n        this.writeTag(tag, Pbf.Bytes);\n        this.writeString(str);\n    },\n    writeFloatField: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed32);\n        this.writeFloat(val);\n    },\n    writeDoubleField: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed64);\n        this.writeDouble(val);\n    },\n    writeBooleanField: function(tag, val) {\n        this.writeVarintField(tag, Boolean(val));\n    }\n};\n\nfunction writePackedVarint(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);   }\nfunction writePackedSVarint(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);  }\nfunction writePackedFloat(arr, pbf)    { for (var i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);    }\nfunction writePackedDouble(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);   }\nfunction writePackedBoolean(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);  }\nfunction writePackedFixed32(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);  }\nfunction writePackedSFixed32(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]); }\nfunction writePackedFixed64(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);  }\nfunction writePackedSFixed64(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]); }\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pbf/index.js\n ** module id = 34\n ** module chunks = 0\n **/","'use strict';\n\n'use strict';\n\n// lightweight Buffer shim for pbf browser build\n// based on code from github.com/feross/buffer (MIT-licensed)\n\nmodule.exports = Buffer;\n\nvar ieee754 = require('ieee754');\n\nvar BufferMethods;\n\nfunction Buffer(length) {\n    var arr;\n    if (length && length.length) {\n        arr = length;\n        length = arr.length;\n    }\n    var buf = new Uint8Array(length || 0);\n    if (arr) buf.set(arr);\n\n    buf.readUInt32LE = BufferMethods.readUInt32LE;\n    buf.writeUInt32LE = BufferMethods.writeUInt32LE;\n    buf.readInt32LE = BufferMethods.readInt32LE;\n    buf.writeInt32LE = BufferMethods.writeInt32LE;\n    buf.readFloatLE = BufferMethods.readFloatLE;\n    buf.writeFloatLE = BufferMethods.writeFloatLE;\n    buf.readDoubleLE = BufferMethods.readDoubleLE;\n    buf.writeDoubleLE = BufferMethods.writeDoubleLE;\n    buf.toString = BufferMethods.toString;\n    buf.write = BufferMethods.write;\n    buf.slice = BufferMethods.slice;\n    buf.copy = BufferMethods.copy;\n\n    buf._isBuffer = true;\n    return buf;\n}\n\nvar lastStr, lastStrEncoded;\n\nBufferMethods = {\n    readUInt32LE: function(pos) {\n        return ((this[pos]) |\n            (this[pos + 1] << 8) |\n            (this[pos + 2] << 16)) +\n            (this[pos + 3] * 0x1000000);\n    },\n\n    writeUInt32LE: function(val, pos) {\n        this[pos] = val;\n        this[pos + 1] = (val >>> 8);\n        this[pos + 2] = (val >>> 16);\n        this[pos + 3] = (val >>> 24);\n    },\n\n    readInt32LE: function(pos) {\n        return ((this[pos]) |\n            (this[pos + 1] << 8) |\n            (this[pos + 2] << 16)) +\n            (this[pos + 3] << 24);\n    },\n\n    readFloatLE:  function(pos) { return ieee754.read(this, pos, true, 23, 4); },\n    readDoubleLE: function(pos) { return ieee754.read(this, pos, true, 52, 8); },\n\n    writeFloatLE:  function(val, pos) { return ieee754.write(this, val, pos, true, 23, 4); },\n    writeDoubleLE: function(val, pos) { return ieee754.write(this, val, pos, true, 52, 8); },\n\n    toString: function(encoding, start, end) {\n        var str = '',\n            tmp = '';\n\n        start = start || 0;\n        end = Math.min(this.length, end || this.length);\n\n        for (var i = start; i < end; i++) {\n            var ch = this[i];\n            if (ch <= 0x7F) {\n                str += decodeURIComponent(tmp) + String.fromCharCode(ch);\n                tmp = '';\n            } else {\n                tmp += '%' + ch.toString(16);\n            }\n        }\n\n        str += decodeURIComponent(tmp);\n\n        return str;\n    },\n\n    write: function(str, pos) {\n        var bytes = str === lastStr ? lastStrEncoded : encodeString(str);\n        for (var i = 0; i < bytes.length; i++) {\n            this[pos + i] = bytes[i];\n        }\n    },\n\n    slice: function(start, end) {\n        return this.subarray(start, end);\n    },\n\n    copy: function(buf, pos) {\n        pos = pos || 0;\n        for (var i = 0; i < this.length; i++) {\n            buf[pos + i] = this[i];\n        }\n    }\n};\n\nBufferMethods.writeInt32LE = BufferMethods.writeUInt32LE;\n\nBuffer.byteLength = function(str) {\n    lastStr = str;\n    lastStrEncoded = encodeString(str);\n    return lastStrEncoded.length;\n};\n\nBuffer.isBuffer = function(buf) {\n    return !!(buf && buf._isBuffer);\n};\n\nfunction encodeString(str) {\n    var length = str.length,\n        bytes = [];\n\n    for (var i = 0, c, lead; i < length; i++) {\n        c = str.charCodeAt(i); // code point\n\n        if (c > 0xD7FF && c < 0xE000) {\n\n            if (lead) {\n                if (c < 0xDC00) {\n                    bytes.push(0xEF, 0xBF, 0xBD);\n                    lead = c;\n                    continue;\n\n                } else {\n                    c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;\n                    lead = null;\n                }\n\n            } else {\n                if (c > 0xDBFF || (i + 1 === length)) bytes.push(0xEF, 0xBF, 0xBD);\n                else lead = c;\n\n                continue;\n            }\n\n        } else if (lead) {\n            bytes.push(0xEF, 0xBF, 0xBD);\n            lead = null;\n        }\n\n        if (c < 0x80) bytes.push(c);\n        else if (c < 0x800) bytes.push(c >> 0x6 | 0xC0, c & 0x3F | 0x80);\n        else if (c < 0x10000) bytes.push(c >> 0xC | 0xE0, c >> 0x6 & 0x3F | 0x80, c & 0x3F | 0x80);\n        else bytes.push(c >> 0x12 | 0xF0, c >> 0xC & 0x3F | 0x80, c >> 0x6 & 0x3F | 0x80, c & 0x3F | 0x80);\n    }\n    return bytes;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pbf/buffer.js\n ** module id = 35\n ** module chunks = 0\n **/","'use strict';\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\nBuffer.poolSize = 8192 // not used by this implementation\n\nvar rootParent = {}\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property\n *     on objects.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\nfunction typedArraySupport () {\n  function Bar () {}\n  try {\n    var arr = new Uint8Array(1)\n    arr.foo = function () { return 42 }\n    arr.constructor = Bar\n    return arr.foo() === 42 && // typed array instances can be augmented\n        arr.constructor === Bar && // constructor can be set\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\n/**\n * Class: Buffer\n * =============\n *\n * The Buffer constructor returns instances of `Uint8Array` that are augmented\n * with function properties for all the node `Buffer` API functions. We use\n * `Uint8Array` so that square bracket notation works as expected -- it returns\n * a single octet.\n *\n * By augmenting the instances, we can avoid modifying the `Uint8Array`\n * prototype.\n */\nfunction Buffer (arg) {\n  if (!(this instanceof Buffer)) {\n    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.\n    if (arguments.length > 1) return new Buffer(arg, arguments[1])\n    return new Buffer(arg)\n  }\n\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    this.length = 0\n    this.parent = undefined\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    return fromNumber(this, arg)\n  }\n\n  // Slightly less common case.\n  if (typeof arg === 'string') {\n    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')\n  }\n\n  // Unusual.\n  return fromObject(this, arg)\n}\n\nfunction fromNumber (that, length) {\n  that = allocate(that, length < 0 ? 0 : checked(length) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < length; i++) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'\n\n  // Assumption: byteLength() return value is always < kMaxLength.\n  var length = byteLength(string, encoding) | 0\n  that = allocate(that, length)\n\n  that.write(string, encoding)\n  return that\n}\n\nfunction fromObject (that, object) {\n  if (Buffer.isBuffer(object)) return fromBuffer(that, object)\n\n  if (isArray(object)) return fromArray(that, object)\n\n  if (object == null) {\n    throw new TypeError('must start with number, buffer, array or string')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined') {\n    if (object.buffer instanceof ArrayBuffer) {\n      return fromTypedArray(that, object)\n    }\n    if (object instanceof ArrayBuffer) {\n      return fromArrayBuffer(that, object)\n    }\n  }\n\n  if (object.length) return fromArrayLike(that, object)\n\n  return fromJsonObject(that, object)\n}\n\nfunction fromBuffer (that, buffer) {\n  var length = checked(buffer.length) | 0\n  that = allocate(that, length)\n  buffer.copy(that, 0, 0, length)\n  return that\n}\n\nfunction fromArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Duplicate of fromArray() to keep fromArray() monomorphic.\nfunction fromTypedArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  // Truncating the elements is probably not what people expect from typed\n  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior\n  // of the old Buffer constructor.\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    array.byteLength\n    that = Buffer._augment(new Uint8Array(array))\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromTypedArray(that, new Uint8Array(array))\n  }\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.\n// Returns a zero-length buffer for inputs that don't conform to the spec.\nfunction fromJsonObject (that, object) {\n  var array\n  var length = 0\n\n  if (object.type === 'Buffer' && isArray(object.data)) {\n    array = object.data\n    length = checked(array.length) | 0\n  }\n  that = allocate(that, length)\n\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n} else {\n  // pre-set for values that may exist in the future\n  Buffer.prototype.length = undefined\n  Buffer.prototype.parent = undefined\n}\n\nfunction allocate (that, length) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = Buffer._augment(new Uint8Array(length))\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that.length = length\n    that._isBuffer = true\n  }\n\n  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1\n  if (fromPool) that.parent = rootParent\n\n  return that\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (subject, encoding) {\n  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)\n\n  var buf = new Buffer(subject, encoding)\n  delete buf.parent\n  return buf\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  var i = 0\n  var len = Math.min(x, y)\n  while (i < len) {\n    if (a[i] !== b[i]) break\n\n    ++i\n  }\n\n  if (i !== len) {\n    x = a[i]\n    y = b[i]\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'raw':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')\n\n  if (list.length === 0) {\n    return new Buffer(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; i++) {\n      length += list[i].length\n    }\n  }\n\n  var buf = new Buffer(length)\n  var pos = 0\n  for (i = 0; i < list.length; i++) {\n    var item = list[i]\n    item.copy(buf, pos)\n    pos += item.length\n  }\n  return buf\n}\n\nfunction byteLength (string, encoding) {\n  if (typeof string !== 'string') string = '' + string\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'binary':\n      // Deprecated\n      case 'raw':\n      case 'raws':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  start = start | 0\n  end = end === undefined || end === Infinity ? this.length : end | 0\n\n  if (!encoding) encoding = 'utf8'\n  if (start < 0) start = 0\n  if (end > this.length) end = this.length\n  if (end <= start) return ''\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'binary':\n        return binarySlice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return 0\n  return Buffer.compare(this, b)\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset) {\n  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff\n  else if (byteOffset < -0x80000000) byteOffset = -0x80000000\n  byteOffset >>= 0\n\n  if (this.length === 0) return -1\n  if (byteOffset >= this.length) return -1\n\n  // Negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)\n\n  if (typeof val === 'string') {\n    if (val.length === 0) return -1 // special case: looking for empty string always fails\n    return String.prototype.indexOf.call(this, val, byteOffset)\n  }\n  if (Buffer.isBuffer(val)) {\n    return arrayIndexOf(this, val, byteOffset)\n  }\n  if (typeof val === 'number') {\n    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {\n      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)\n    }\n    return arrayIndexOf(this, [ val ], byteOffset)\n  }\n\n  function arrayIndexOf (arr, val, byteOffset) {\n    var foundIndex = -1\n    for (var i = 0; byteOffset + i < arr.length; i++) {\n      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex\n      } else {\n        foundIndex = -1\n      }\n    }\n    return -1\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\n// `get` is deprecated\nBuffer.prototype.get = function get (offset) {\n  console.log('.get() is deprecated. Access using array indexes instead.')\n  return this.readUInt8(offset)\n}\n\n// `set` is deprecated\nBuffer.prototype.set = function set (v, offset) {\n  console.log('.set() is deprecated. Access using array indexes instead.')\n  return this.writeUInt8(v, offset)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new Error('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; i++) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) throw new Error('Invalid hex string')\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction binaryWrite (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    var swap = encoding\n    encoding = offset\n    offset = length | 0\n    length = swap\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'binary':\n        return binaryWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction binarySlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; i++) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = Buffer._augment(this.subarray(start, end))\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; i++) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  if (newBuf.length) newBuf.parent = this.parent || this\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n  if (offset < 0) throw new RangeError('index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; i--) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; i++) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    target._set(this.subarray(start, start + len), targetStart)\n  }\n\n  return len\n}\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill (value, start, end) {\n  if (!value) value = 0\n  if (!start) start = 0\n  if (!end) end = this.length\n\n  if (end < start) throw new RangeError('end < start')\n\n  // Fill 0 bytes; we're done\n  if (end === start) return\n  if (this.length === 0) return\n\n  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')\n  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')\n\n  var i\n  if (typeof value === 'number') {\n    for (i = start; i < end; i++) {\n      this[i] = value\n    }\n  } else {\n    var bytes = utf8ToBytes(value.toString())\n    var len = bytes.length\n    for (i = start; i < end; i++) {\n      this[i] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n/**\n * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n */\nBuffer.prototype.toArrayBuffer = function toArrayBuffer () {\n  if (typeof Uint8Array !== 'undefined') {\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      return (new Buffer(this)).buffer\n    } else {\n      var buf = new Uint8Array(this.length)\n      for (var i = 0, len = buf.length; i < len; i += 1) {\n        buf[i] = this[i]\n      }\n      return buf.buffer\n    }\n  } else {\n    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')\n  }\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar BP = Buffer.prototype\n\n/**\n * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n */\nBuffer._augment = function _augment (arr) {\n  arr.constructor = Buffer\n  arr._isBuffer = true\n\n  // save reference to original Uint8Array set method before overwriting\n  arr._set = arr.set\n\n  // deprecated\n  arr.get = BP.get\n  arr.set = BP.set\n\n  arr.write = BP.write\n  arr.toString = BP.toString\n  arr.toLocaleString = BP.toString\n  arr.toJSON = BP.toJSON\n  arr.equals = BP.equals\n  arr.compare = BP.compare\n  arr.indexOf = BP.indexOf\n  arr.copy = BP.copy\n  arr.slice = BP.slice\n  arr.readUIntLE = BP.readUIntLE\n  arr.readUIntBE = BP.readUIntBE\n  arr.readUInt8 = BP.readUInt8\n  arr.readUInt16LE = BP.readUInt16LE\n  arr.readUInt16BE = BP.readUInt16BE\n  arr.readUInt32LE = BP.readUInt32LE\n  arr.readUInt32BE = BP.readUInt32BE\n  arr.readIntLE = BP.readIntLE\n  arr.readIntBE = BP.readIntBE\n  arr.readInt8 = BP.readInt8\n  arr.readInt16LE = BP.readInt16LE\n  arr.readInt16BE = BP.readInt16BE\n  arr.readInt32LE = BP.readInt32LE\n  arr.readInt32BE = BP.readInt32BE\n  arr.readFloatLE = BP.readFloatLE\n  arr.readFloatBE = BP.readFloatBE\n  arr.readDoubleLE = BP.readDoubleLE\n  arr.readDoubleBE = BP.readDoubleBE\n  arr.writeUInt8 = BP.writeUInt8\n  arr.writeUIntLE = BP.writeUIntLE\n  arr.writeUIntBE = BP.writeUIntBE\n  arr.writeUInt16LE = BP.writeUInt16LE\n  arr.writeUInt16BE = BP.writeUInt16BE\n  arr.writeUInt32LE = BP.writeUInt32LE\n  arr.writeUInt32BE = BP.writeUInt32BE\n  arr.writeIntLE = BP.writeIntLE\n  arr.writeIntBE = BP.writeIntBE\n  arr.writeInt8 = BP.writeInt8\n  arr.writeInt16LE = BP.writeInt16LE\n  arr.writeInt16BE = BP.writeInt16BE\n  arr.writeInt32LE = BP.writeInt32LE\n  arr.writeInt32BE = BP.writeInt32BE\n  arr.writeFloatLE = BP.writeFloatLE\n  arr.writeFloatBE = BP.writeFloatBE\n  arr.writeDoubleLE = BP.writeDoubleLE\n  arr.writeDoubleBE = BP.writeDoubleBE\n  arr.fill = BP.fill\n  arr.inspect = BP.inspect\n  arr.toArrayBuffer = BP.toArrayBuffer\n\n  return arr\n}\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; i++) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; i++) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/buffer/index.js\n ** module id = 36\n ** module chunks = 0\n **/","'use strict';\n\nvar lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n;(function (exports) {\n\t'use strict';\n\n  var Arr = (typeof Uint8Array !== 'undefined')\n    ? Uint8Array\n    : Array\n\n\tvar PLUS   = '+'.charCodeAt(0)\n\tvar SLASH  = '/'.charCodeAt(0)\n\tvar NUMBER = '0'.charCodeAt(0)\n\tvar LOWER  = 'a'.charCodeAt(0)\n\tvar UPPER  = 'A'.charCodeAt(0)\n\tvar PLUS_URL_SAFE = '-'.charCodeAt(0)\n\tvar SLASH_URL_SAFE = '_'.charCodeAt(0)\n\n\tfunction decode (elt) {\n\t\tvar code = elt.charCodeAt(0)\n\t\tif (code === PLUS ||\n\t\t    code === PLUS_URL_SAFE)\n\t\t\treturn 62 // '+'\n\t\tif (code === SLASH ||\n\t\t    code === SLASH_URL_SAFE)\n\t\t\treturn 63 // '/'\n\t\tif (code < NUMBER)\n\t\t\treturn -1 //no match\n\t\tif (code < NUMBER + 10)\n\t\t\treturn code - NUMBER + 26 + 26\n\t\tif (code < UPPER + 26)\n\t\t\treturn code - UPPER\n\t\tif (code < LOWER + 26)\n\t\t\treturn code - LOWER + 26\n\t}\n\n\tfunction b64ToByteArray (b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr\n\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow new Error('Invalid string. Length must be a multiple of 4')\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tvar len = b64.length\n\t\tplaceHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = new Arr(b64.length * 3 / 4 - placeHolders)\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length\n\n\t\tvar L = 0\n\n\t\tfunction push (v) {\n\t\t\tarr[L++] = v\n\t\t}\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n\t\t\tpush((tmp & 0xFF0000) >> 16)\n\t\t\tpush((tmp & 0xFF00) >> 8)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n\t\t\tpush(tmp & 0xFF)\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n\t\t\tpush((tmp >> 8) & 0xFF)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\treturn arr\n\t}\n\n\tfunction uint8ToBase64 (uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = \"\",\n\t\t\ttemp, length\n\n\t\tfunction encode (num) {\n\t\t\treturn lookup.charAt(num)\n\t\t}\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n\t\t}\n\n\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t\t\toutput += tripletToBase64(temp)\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1]\n\t\t\t\toutput += encode(temp >> 2)\n\t\t\t\toutput += encode((temp << 4) & 0x3F)\n\t\t\t\toutput += '=='\n\t\t\t\tbreak\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n\t\t\t\toutput += encode(temp >> 10)\n\t\t\t\toutput += encode((temp >> 4) & 0x3F)\n\t\t\t\toutput += encode((temp << 2) & 0x3F)\n\t\t\t\toutput += '='\n\t\t\t\tbreak\n\t\t}\n\n\t\treturn output\n\t}\n\n\texports.toByteArray = b64ToByteArray\n\texports.fromByteArray = uint8ToBase64\n}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/base64-js/lib/b64.js\n ** module id = 37\n ** module chunks = 0\n **/","'use strict';\n\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ieee754/index.js\n ** module id = 38\n ** module chunks = 0\n **/","'use strict';\n\nvar toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/buffer/~/isarray/index.js\n ** module id = 39\n ** module chunks = 0\n **/","'use strict';\n\nvar _ = require('lodash');\nvar $ = require('jquery');\nvar utils = require('socrata-utils');\nvar ChoroplethMap = require('./views/ChoroplethMap');\nvar MetadataProvider = require('./dataProviders/MetadataProvider');\nvar GeospaceDataProvider = require('./dataProviders/GeospaceDataProvider');\nvar SoqlDataProvider = require('./dataProviders/SoqlDataProvider');\nvar SoqlHelpers = require('./dataProviders/SoqlHelpers');\n\nvar DEFAULT_BASE_LAYER_URL = 'https://a.tiles.mapbox.com/v3/socrata-apps.3ecc65d4/{z}/{x}/{y}.png';\nvar DEFAULT_BASE_LAYER_OPACITY = 0.8;\nvar NAME_ALIAS = '__NAME_ALIAS__';\nvar VALUE_ALIAS = '__VALUE_ALIAS__';\nvar BASE_QUERY = 'SELECT `{0}` AS {1}, COUNT(*) AS {2} {3} GROUP BY `{0}` ORDER BY COUNT(*) DESC NULL LAST LIMIT 200';\nvar WINDOW_RESIZE_RERENDER_DELAY = 200;\n\n/**\n * Instantiates a Socrata Choropleth Visualization from the\n * `socrata-visualizations` package.\n *\n * @param vif - https://docs.google.com/document/d/15oKmDfv39HrhgCJRTKtYadG8ZQvFUeyfx4kR_NZkBgc\n */\n$.fn.socrataChoroplethMap = function(vif) {\n\n  // Verify important properties got passed in\n  utils.assertHasProperties(\n    vif,\n    'columnName',\n    'configuration',\n    'datasetUid',\n    'domain',\n    'unit'\n  );\n\n  utils.assertHasProperties(\n    vif.unit,\n    'one',\n    'other'\n  );\n\n  utils.assertHasProperties(\n    vif.configuration,\n    'computedColumnName',\n    'localization',\n    'shapefile'\n  );\n\n  utils.assertHasProperties(\n    vif.configuration.localization,\n    'NO_VALUE',\n    'FLYOUT_UNFILTERED_AMOUNT_LABEL',\n    'FLYOUT_FILTERED_AMOUNT_LABEL',\n    'FLYOUT_SELECTED_NOTICE'\n  );\n\n  utils.assertHasProperties(\n    vif.configuration.shapefile,\n    'geometryLabel',\n    'primaryKey',\n    'uid'\n  );\n\n  /**\n   * Setup visualization\n   */\n  var $element = $(this);\n\n  var visualization = new ChoroplethMap($element, vif);\n\n  // Setup Data Providers\n  var shapefileMetadataProviderConfig = {\n    domain: vif.domain,\n    datasetUid: vif.configuration.shapefile.uid\n  };\n\n  var shapefileMetadataProvider = new MetadataProvider(\n    shapefileMetadataProviderConfig\n  );\n\n  var datasetGeospaceDataProviderConfig = {\n    domain: vif.domain,\n    datasetUid: vif.datasetUid\n  };\n\n  var datasetGeospaceDataProvider = new GeospaceDataProvider(\n    datasetGeospaceDataProviderConfig\n  );\n\n  var shapefileGeospaceDataProviderConfig = {\n    domain: vif.domain,\n    datasetUid: vif.configuration.shapefile.uid\n  };\n\n  var shapefileGeospaceDataProvider = new GeospaceDataProvider(\n    shapefileGeospaceDataProviderConfig\n  );\n\n  var soqlDataProviderConfig = {\n    domain: vif.domain,\n    datasetUid: vif.datasetUid\n  };\n\n  var unfilteredSoqlDataProvider = new SoqlDataProvider(\n    soqlDataProviderConfig\n  );\n\n  var filteredSoqlDataProvider = new SoqlDataProvider(\n    soqlDataProviderConfig\n  );\n\n  var cachedShapefile;\n\n  var datasetColumnExtentDataProvider = new SoqlDataProvider(\n    soqlDataProviderConfig\n  );\n\n  var shapefileMetadataRequest;\n  var featureExtentRequest;\n  var cachedGeometryLabel;\n  var rerenderOnResizeTimeout;\n  var _lastRenderedVif;\n\n  _attachEvents();\n\n  if (_.isString(vif.configuration.shapefile.geometryLabel)) {\n    // This fake shapefile dataset metadata response is used so that we can\n    // conform to the promise chain all the way down to visualization render,\n    // rather than conditionally requiring one or two requests to complete\n    // before proceeding.\n    shapefileMetadataRequest = Promise.resolve({\n      geometryLabel: vif.configuration.shapefile.geometryLabel\n    });\n\n  } else {\n\n    shapefileMetadataRequest = shapefileMetadataProvider.\n      getPhidippidesAugmentedDatasetMetadata().\n      then(\n        function(shapefileMetadata) {\n          return shapefileMetadata;\n        },\n        function(error) {\n          _logError(error);\n\n          // If the shapefile metadata request fails, we can still proceed,\n          // albeit with degraded flyout behavior. This is because the only\n          // thing we're trying to get from the shapefile metadata is the\n          // geometryLabel (the column in the shapefile that corresponds to a\n          // human-readable name for each region) and, if it is not present,\n          // the visualization will simply not show the human-readable name in\n          // the flyout at all (it will still show values).\n          //\n          // Accordingly, we still want to resolve this promise in its error\n          // state.\n          return {\n            geometryLabel: null\n          };\n        }\n      );\n\n  }\n\n  featureExtentRequest = datasetGeospaceDataProvider.\n    getFeatureExtent(vif.columnName).\n    // If the request has succeeded, return the response (using _.identity());\n    // if it failed then log the resulting error.\n    then(\n      _.identity,\n      _logError\n    );\n\n  Promise.\n    all([shapefileMetadataRequest, featureExtentRequest]).\n    then(function(values) {\n      var shapefileMetadata = values[0];\n      var featureExtent = values[1];\n\n      shapefileGeospaceDataProvider.\n        getShapefile(featureExtent).\n        then(\n          function(shapefile) {\n\n            // First cache the geometryLabel and shapefile so that we only need\n            // to request them once per page load.\n            //\n            // Downstream users of geometryLabel expect null, but will probably\n            // behave ok with undefined; regardless, default to null if the\n            // property does not exist.\n            cachedGeometryLabel = shapefileMetadata.geometryLabel || null;\n            cachedShapefile = shapefile;\n            // Next, render base layer.\n            visualization.updateTileLayer(_getRenderOptions(vif));\n            // Finally, make the data queries and prepare to draw the choropleth\n            // regions.\n            _updateData(vif);\n          },\n          function(error) {\n            _logError(error);\n          }\n        );\n      }\n    );\n\n  function _getRenderOptions(vifToRender) {\n\n    return {\n      baseLayer: {\n        url: vifToRender.configuration.baseLayerUrl || DEFAULT_BASE_LAYER_URL,\n        opacity: vifToRender.configuration.baseLayerOpacity || DEFAULT_BASE_LAYER_OPACITY\n      },\n      showFiltered: vifToRender.filters.length > 0,\n      vif: vifToRender\n    };\n  }\n\n  /**\n   * Fetches SOQL data and aggregates with shapefile geoJSON\n   */\n  function _updateData(vifToRender) {\n    var whereClauseComponents = SoqlHelpers.whereClauseFilteringOwnColumn(vifToRender);\n    var unfilteredQueryString = BASE_QUERY.format(\n      vifToRender.configuration.computedColumnName,\n      NAME_ALIAS,\n      VALUE_ALIAS,\n      ''\n    );\n    var filteredQueryString = BASE_QUERY.format(\n      vifToRender.configuration.computedColumnName,\n      NAME_ALIAS,\n      VALUE_ALIAS,\n      (whereClauseComponents) ? 'WHERE {0}'.format(whereClauseComponents) : ''\n    );\n    var unfilteredSoqlQuery = unfilteredSoqlDataProvider.\n      query(unfilteredQueryString, NAME_ALIAS, VALUE_ALIAS)\n      ['catch'](function(error) {\n        _logError(error);\n        visualization.renderError();\n      });\n    var filteredSoqlQuery = filteredSoqlDataProvider.\n      query(filteredQueryString, NAME_ALIAS, VALUE_ALIAS)\n      ['catch'](function(error) {\n        _logError(error);\n        visualization.renderError();\n      });\n\n    Promise.\n      all([unfilteredSoqlQuery, filteredSoqlQuery]).\n      then(function(values) {\n        var unfilteredQueryResponse = values[0].rows.map(function(row) {\n          var value = parseInt(row[1], 10);\n\n          return {\n            name: row[0],\n            value: value\n          };\n        });\n        var filteredQueryResponse = values[1].rows.map(function(row) {\n          var value = parseInt(row[1], 10);\n\n          return {\n            name: row[0],\n            value: value\n          };\n        });\n\n        // Consolidate configuration and data into one object\n        var aggregatedData = _aggregateGeoJsonData(\n          cachedGeometryLabel,\n          vifToRender.configuration.shapefile.primaryKey,\n          cachedShapefile,\n          unfilteredQueryResponse,\n          filteredQueryResponse,\n          vifToRender\n        );\n\n        if (vifToRender) {\n          _lastRenderedVif = vifToRender;\n        }\n\n        visualization.render(\n          aggregatedData,\n          _getRenderOptions(_lastRenderedVif)\n        );\n      })\n      ['catch'](function(error) {\n        _logError(error);\n        visualization.renderError();\n      });\n  }\n\n  /**\n   * Data Formatting Functions\n   */\n\n  /**\n   * See CardVisualizationChoroplethHelpers.js in the frontend repo for more\n   * details about _aggregateGeoJsonData\n   *\n   * Consolidates the given geojson data into one object.\n   *\n   * @param {String} geometryLabel - The name of the property that should be\n   *   used as the 'human-readable' name for a region.\n   * @param {String} primaryKey - Name of the property to be used as the primary key\n   * @param {Object} geojsonRegions - A geoJson-formatted object.\n   * @param {Object[]} unfilteredData - An array of objects with 'name' and\n   *   'value' keys (the unfiltered values of the data).\n   * @param {Object[]} filteredData - An array of objects with 'name' and\n   *   'value' keys (the filtered values of the data).\n   * @param {Object[]} vifToRender - The vif that is being rendered.\n   *\n   * @return {Object} (See _mergeRegionAndAggregateData)\n   */\n  function _aggregateGeoJsonData(\n    geometryLabel,\n    primaryKey,\n    geojsonRegions,\n    unfilteredData,\n    filteredData,\n    vifToRender) {\n\n    var unfilteredDataAsHash = _.mapValues(_.indexBy(unfilteredData, 'name'), 'value');\n    var filteredDataAsHash = _.mapValues(_.indexBy(filteredData, 'name'), 'value');\n    var ownFilterOperands = vifToRender.\n      filters.\n      filter(\n        function(filter) {\n\n          return (\n            (filter.columnName === vifToRender.columnName) &&\n            (filter.function === 'binaryComputedGeoregionOperator') &&\n            (filter.arguments.computedColumnName === vifToRender.configuration.computedColumnName)\n          );\n        }\n      ).\n      map(\n        function(filter) {\n          return filter.arguments.operand;\n        }\n      );\n\n    return _mergeRegionAndAggregateData(\n      geometryLabel,\n      primaryKey,\n      geojsonRegions,\n      unfilteredDataAsHash,\n      filteredDataAsHash,\n      ownFilterOperands\n    );\n  }\n\n  /**\n   * See CardVisualizationChoroplethHelpers.js in the frontend repo for more\n   * details about _mergeRegionAndAggregateData\n   *\n   * @param {String} geometryLabel - The name of the property that should be\n   *   used as the 'human-readable' name for a region.\n   * @param {String} primaryKey - Name of the property to be used as the primary key\n   * @param {Object} geojsonRegions - The source GeoJSON shape file.\n   * @param {Object} unfilteredDataAsHash - The aggregate unfiltered values\n   *   associated with each region.\n   * @param {Object} filteredDataAsHash - The aggregate filtered values\n   *   associated with each region.\n   * @param {String[]} activeFilterNames - An array of currently-filtered regions\n   *   keyed by id.\n   *\n   * @return {Object} - A GeoJSON shape file.\n   *   @property {Object} crs - The GeoJSON shape file's coordinate reference\n   *     system (CRS). We do not modify this.\n   *   @property {Object[]} features - An array of GeoJSON feature objects\n   *     with the following properties:\n   *     @property {Object} geometry - The feature's geometry property.\n   *     @property {Object} properties - The properties associated with this\n   *       feature augmented with the unfiltered and filtered aggregate\n   *       values with which it is associated.\n   *     @property {String} type - The GeoJSON type associated with this\n   *       feature.\n   *   @property {String} type - The GeoJSON Type associated with this shape\n   *     file.\n   */\n  function _mergeRegionAndAggregateData(\n    geometryLabel,\n    primaryKey,\n    geojsonRegions,\n    unfilteredDataAsHash,\n    filteredDataAsHash,\n    ownFilterOperands\n  ) {\n\n    var newFeatures = _.chain(_.get(geojsonRegions, 'features', [])).\n      filter(function(geojsonFeature) {\n        return _.get(geojsonFeature, 'properties.{0}'.format(primaryKey));\n      }).\n      map(function(geojsonFeature) {\n        var name = _.get(geojsonFeature, 'properties.{0}'.format(primaryKey));\n        var humanReadableName = _.get(geojsonFeature, 'properties.{0}'.format(geometryLabel), '');\n        var properties = {};\n\n        properties[primaryKey] = name;\n        properties[vif.configuration.shapefile.columns.name] = humanReadableName;\n        properties[vif.configuration.shapefile.columns.filtered] = filteredDataAsHash[name] || null;\n        properties[vif.configuration.shapefile.columns.unfiltered] = unfilteredDataAsHash[name];\n        properties[vif.configuration.shapefile.columns.selected] = _.contains(ownFilterOperands, name);\n\n        // Create a new object to get rid of superfluous shapefile-specific\n        // fields coming out of the backend.\n        return {\n          geometry: geojsonFeature.geometry,\n          properties: properties,\n          type: geojsonFeature.type\n        };\n      }).value();\n\n    return {\n      crs: geojsonRegions.crs,\n      features: newFeatures,\n      type: geojsonRegions.type\n    };\n  }\n\n  /**\n   * Event handling\n   */\n  function _attachEvents() {\n\n    // Destroy on (only the first) 'SOCRATA_VISUALIZATION_DESTROY' event.\n    $element.one('SOCRATA_VISUALIZATION_DESTROY', function() {\n      clearTimeout(rerenderOnResizeTimeout);\n      visualization.destroy();\n      _detachEvents();\n    });\n\n    $(window).on('resize', _handleWindowResize);\n\n    $element.on('SOCRATA_VISUALIZATION_CHOROPLETH_FEATURE_FLYOUT', _handleFeatureFlyout);\n    $element.on('SOCRATA_VISUALIZATION_CHOROPLETH_LEGEND_FLYOUT', _handleLegendFlyout);\n    $element.on('SOCRATA_VISUALIZATION_CHOROPLETH_FLYOUT_HIDE', _hideFlyout);\n    $element.on('SOCRATA_VISUALIZATION_CHOROPLETH_SELECT_REGION', _handleSelection);\n    $element.on('SOCRATA_VISUALIZATION_INVALIDATE_SIZE', visualization.invalidateSize);\n    $element.on('SOCRATA_VISUALIZATION_RENDER_VIF', _handleRenderVif);\n  }\n\n  function _detachEvents() {\n\n    $(window).off('resize', _handleWindowResize);\n\n    $element.off('SOCRATA_VISUALIZATION_CHOROPLETH_FEATURE_FLYOUT', _handleFeatureFlyout);\n    $element.off('SOCRATA_VISUALIZATION_CHOROPLETH_LEGEND_FLYOUT', _handleLegendFlyout);\n    $element.off('SOCRATA_VISUALIZATION_CHOROPLETH_FLYOUT_HIDE', _hideFlyout);\n    $element.off('SOCRATA_VISUALIZATION_CHOROPLETH_SELECT_REGION', _handleSelection);\n    $element.off('SOCRATA_VISUALIZATION_INVALIDATE_SIZE', visualization.invalidateSize);\n    $element.off('SOCRATA_VISUALIZATION_RENDER_VIF', _handleRenderVif);\n  }\n\n  function _handleWindowResize() {\n\n    clearTimeout(rerenderOnResizeTimeout);\n\n    rerenderOnResizeTimeout = setTimeout(\n      visualization.invalidateSize,\n      // Add some jitter in order to make sure multiple visualizations are\n      // unlikely to all attempt to rerender themselves at the exact same\n      // moment.\n      WINDOW_RESIZE_RERENDER_DELAY + Math.floor(Math.random() * 10)\n    );\n  }\n\n  function _handleFeatureFlyout(event) {\n    var payload = event.originalEvent.detail;\n    var flyoutPayload;\n    var flyoutContent;\n    var flyoutTable;\n    var flyoutElements;\n    var flyoutTitle;\n    var flyoutUnfilteredValueLabelCell;\n    var flyoutUnfilteredValueCell;\n    var flyoutUnfilteredValueRow;\n    var filteredRowClass;\n    var flyoutFilteredValueLabelCell;\n    var flyoutFilteredValueCell;\n    var flyoutFilteredValueRow;\n    var flyoutSpacerRow;\n    var flyoutSelectedNoticeLabel;\n    var flyoutSelectedNoticeRow;\n\n    if (payload !== null) {\n\n      flyoutContent = $(document.createDocumentFragment());\n      flyoutTable = $('<table>', { 'class': 'socrata-flyout-table' });\n      flyoutElements = [];\n\n      // 'Datum Title'\n      flyoutTitle = $(\n        '<div>',\n        {\n          'class': 'socrata-flyout-title'\n        }\n      ).text(payload.title);\n\n      // 'Total: XXX rows'\n      flyoutUnfilteredValueLabelCell = $(\n        '<td>',\n        {\n          'class': 'socrata-flyout-cell'\n        }\n      ).text(payload.unfilteredValueLabel);\n\n      flyoutUnfilteredValueCell = $(\n        '<td>',\n        {\n          'class': 'socrata-flyout-cell'\n        }\n      ).text(payload.unfilteredValue);\n\n      flyoutUnfilteredValueRow = $(\n        '<tr>',\n        {\n          'class': 'socrata-flyout-row'\n        }\n      ).append([\n        flyoutUnfilteredValueLabelCell,\n        flyoutUnfilteredValueCell\n      ]);\n\n      flyoutElements.push(flyoutUnfilteredValueRow);\n\n      // If we are showing filtered data, then\n      // show the filtered data on the flyout.\n      if (payload.hasOwnProperty('filteredValue')) {\n\n        filteredRowClass = (payload.selected) ?\n          'socrata-flyout-cell is-selected' :\n          'socrata-flyout-cell emphasis';\n\n        // 'Filtered: XXX rows'\n        flyoutFilteredValueLabelCell = $(\n          '<td>',\n          {\n            'class': filteredRowClass\n          }\n        ).text(payload.filteredValueLabel);\n\n        flyoutFilteredValueCell = $(\n          '<td>',\n          {\n            'class': filteredRowClass\n          }\n        ).text(payload.filteredValue);\n\n        flyoutFilteredValueRow = $(\n          '<tr>',\n          {\n            'class': 'socrata-flyout-row'\n          }\n        ).append([\n          flyoutFilteredValueLabelCell,\n          flyoutFilteredValueCell\n        ]);\n\n        flyoutElements.push(flyoutFilteredValueRow);\n      }\n\n      // If we are hovering over a region we are\n      // currently filtering by, then display a special\n      // flyout message.\n      if (payload.selected) {\n\n        // 'This visualization is currently filtered...'\n        flyoutSpacerRow = $(\n          '<tr>',\n          {\n            'class': 'socrata-flyout-row',\n            'colspan': '2'\n          }\n        ).append(\n          $('<td>', { 'class': 'socrata-flyout-cell' }).html('&#8203;')\n        );\n\n        flyoutSelectedNoticeLabel = $(\n          '<td>',\n          {\n            'class': 'socrata-flyout-cell'\n          }\n        ).text(payload.selectedNotice);\n\n        flyoutSelectedNoticeRow = $(\n          '<tr>',\n          {\n            'class': 'socrata-flyout-row',\n            'colspan': '2'\n          }\n        ).append([\n          flyoutSelectedNoticeLabel\n        ]);\n\n        flyoutElements.push(flyoutSpacerRow);\n        flyoutElements.push(flyoutSelectedNoticeRow);\n      }\n\n      flyoutTable.append(flyoutElements);\n\n      flyoutContent.append([\n        flyoutTitle,\n        flyoutTable\n      ]);\n\n      flyoutPayload = {\n        flyoutOffset: {\n          left: payload.clientX,\n          top: payload.clientY\n        },\n        content: flyoutContent,\n        rightSideHint: false,\n        belowTarget: false\n      };\n    }\n\n    // Dispatch new event for example\n    _dispatchFlyout(flyoutPayload);\n  }\n\n  function _handleLegendFlyout(event) {\n\n    var payload = event.originalEvent.detail;\n    var flyoutContent = '<div class=\"flyout-title\">{0}</div>'.format(payload.title);\n\n    // Assemble payload\n    var flyoutPayload = {\n      element: payload.element,\n      content: flyoutContent,\n      rightSideHint: false,\n      belowTarget: false\n    };\n\n    // Dispatch new event for example\n    _dispatchFlyout(flyoutPayload);\n  }\n\n  function _hideFlyout() {\n\n    _dispatchFlyout(null);\n  }\n\n  function _handleSelection(event) {\n    var payload = event.originalEvent.detail;\n    var newVif = _.cloneDeep(_lastRenderedVif);\n    var ownFilterOperands = newVif.\n      filters.\n      filter(\n        function(filter) {\n\n          return (\n            (filter.columnName === newVif.columnName) &&\n            (filter.function === 'binaryComputedGeoregionOperator') &&\n            (filter.arguments.computedColumnName === newVif.configuration.computedColumnName)\n          );\n        }\n      ).\n      map(\n        function(filter) {\n          return filter.arguments.operand;\n        }\n      );\n\n    newVif.filters = newVif.\n      filters.\n      filter(function(filter) {\n\n        return (\n          (filter.columnName !== newVif.columnName) &&\n          (filter.function !== 'binaryComputedGeoregionOperator') &&\n          (filter.arguments.computedColumnName !== newVif.configuration.computedColumnName)\n        );\n      });\n\n    if (ownFilterOperands.indexOf(payload.shapefileFeatureId) === -1) {\n\n      newVif.\n        filters.\n        push(\n          {\n            'columnName': newVif.columnName,\n            'function': 'binaryComputedGeoregionOperator',\n            'arguments': {\n              'computedColumnName': newVif.configuration.computedColumnName,\n              'operator': '=',\n              'operand': payload.shapefileFeatureId\n            }\n          }\n        );\n    }\n\n    $element[0].dispatchEvent(\n      new window.CustomEvent(\n        'SOCRATA_VISUALIZATION_VIF_UPDATED',\n        {\n          detail: newVif,\n          bubbles: true\n        }\n      )\n    );\n  }\n\n  function _handleRenderVif(event) {\n    var newVif = event.originalEvent.detail;\n\n    if (newVif.type !== 'choroplethMap') {\n      throw new Error(\n        'Cannot update VIF; old type: `choroplethMap`, new type: `{0}`.'.\n          format(\n            newVif.type\n          )\n        );\n    }\n\n    _updateData(newVif);\n  }\n\n  function _dispatchFlyout(payload) {\n\n    $element[0].dispatchEvent(\n      new window.CustomEvent(\n        'SOCRATA_VISUALIZATION_CHOROPLETH_FLYOUT_EVENT',\n        {\n          detail: payload,\n          bubbles: true\n        }\n      )\n    );\n  }\n\n  function _logError(error) {\n    if (window.console && window.console.error) {\n      console.error(error);\n    }\n  }\n\n  return this;\n};\n\nmodule.exports = $.fn.socrataChoroplethMap;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/ChoroplethMap.js\n ** module id = 40\n ** module chunks = 0\n **/","'use strict';\n\nvar utils = require('socrata-utils');\nvar _ = require('lodash');\n\nvar VALID_BINARY_OPERATORS = ['=', '!=', '<', '<=', '>', '>='];\n\n/**\n * 'Public' methods\n */\n\n/**\n * @param {Object} vif\n */\nfunction whereClauseNotFilteringOwnColumn(vif) {\n  var whereClauseComponents = _whereClauseFromVif(vif, false);\n\n  if (whereClauseComponents) {\n    return whereClauseComponents;\n  }\n\n  return '';\n}\n\n/**\n * @param {Object} vif\n */\nfunction whereClauseFilteringOwnColumn(vif) {\n  var whereClauseComponents = _whereClauseFromVif(vif, true);\n\n  if (whereClauseComponents) {\n    return whereClauseComponents;\n  }\n\n  return '';\n}\n\n/**\n * 'Private' methods\n */\n\nfunction _whereClauseFromVif(vif, filterOwnColumn) {\n  var filters = vif.filters || [];\n\n  utils.assertHasProperties(\n    vif,\n    'columnName',\n    'filters'\n  );\n  utils.assertIsOneOfTypes(vif.columnName, 'string');\n  utils.assertInstanceOf(filters, Array);\n\n  return filters.\n    filter(\n      function(filter) {\n        return filterOwnColumn || (filter.columnName !== vif.columnName);\n      }\n    ).map(\n      _filterToWhereClauseComponent\n    ).\n    join(' AND ');\n}\n\nfunction _filterToWhereClauseComponent(filter) {\n  utils.assertHasProperties(\n    filter,\n    'columnName',\n    'function',\n    'arguments'\n  );\n\n  switch (filter.function) {\n    case 'binaryOperator':\n      return _binaryOperatorWhereClauseComponent(filter);\n    case 'binaryComputedGeoregionOperator':\n      return _binaryComputedGeoregionOperatorWhereClauseComponent(filter);\n    case 'isNull':\n      return _isNullWhereClauseComponent(filter);\n    case 'timeRange':\n      return _timeRangeWhereClauseComponent(filter);\n    case 'valueRange':\n      return _valueRangeWhereClauseComponent(filter);\n    default:\n      throw new Error(\n        'Invalid filter function: `{0}`.'.format(filter.function)\n      );\n  }\n}\n\nfunction _soqlEncodeColumnName(columnName) {\n  utils.assertIsOneOfTypes(columnName, 'string');\n\n  return '`{0}`'.format(\n    columnName.replace(/\\-/g, '_')\n  );\n}\n\nfunction _soqlEncodeValue(value) {\n  // Note: These conditionals will fall through.\n  if (_.isString(value)) {\n    return _soqlEncodeString(value);\n  }\n\n  if (_.isDate(value)) {\n    return _soqlEncodeDate(value);\n  }\n\n  if (_.isNumber(value) || _.isBoolean(value)) {\n    return value;\n  }\n\n  throw new Error(\n    'Cannot soql-encode value of type: {0}'.format(typeof value)\n  );\n}\n\nfunction _soqlEncodeString(value) {\n  return \"'{0}'\".format(value.replace(/'/g, \"''\"));\n}\n\nfunction _soqlEncodeDate(value) {\n  return _soqlEncodeString(\n    _serializeFloatingTimestamp(\n      value\n    )\n  );\n}\n\nfunction _serializeFloatingTimestamp(date) {\n  function _formatToTwoPlaces(value) {\n    return (value < 10) ?\n      '0' + value.toString() :\n      value.toString();\n  }\n\n  return '{0}-{1}-{2}T{3}:{4}:{5}'.format(\n    date.getFullYear(),\n    // The month component of JavaScript dates is 0-indexed (I have no idea\n    // why) so when we are serializing a JavaScript date as ISO-8601 date we\n    // need to increment the month value.\n    _formatToTwoPlaces(date.getMonth() + 1),\n    _formatToTwoPlaces(date.getDate()),\n    _formatToTwoPlaces(date.getHours()),\n    _formatToTwoPlaces(date.getMinutes()),\n    _formatToTwoPlaces(date.getSeconds())\n  );\n}\n\nfunction _binaryOperatorWhereClauseComponent(filter) {\n  utils.assertHasProperties(\n    filter,\n    'columnName',\n    'arguments',\n    'arguments.operator',\n    'arguments.operand'\n  );\n  utils.assert(\n    VALID_BINARY_OPERATORS.indexOf(filter.arguments.operator) > -1,\n    'Invalid binary operator: `{0}`'.format(filter.arguments.operator)\n  );\n\n  return '{0} {1} {2}'.format(\n    _soqlEncodeColumnName(filter.columnName),\n    filter.arguments.operator,\n    _soqlEncodeValue(filter.arguments.operand)\n  );\n}\n\nfunction _binaryComputedGeoregionOperatorWhereClauseComponent(filter) {\n  utils.assertHasProperties(\n    filter,\n    'columnName',\n    'arguments',\n    'arguments.computedColumnName',\n    'arguments.operator',\n    'arguments.operand'\n  );\n  utils.assert(\n    VALID_BINARY_OPERATORS.indexOf(filter.arguments.operator) > -1,\n    'Invalid binary operator: `{0}`'.format(filter.arguments.operator)\n  );\n\n  return '{0} {1} {2}'.format(\n    _soqlEncodeColumnName(filter.arguments.computedColumnName),\n    filter.arguments.operator,\n    _soqlEncodeValue(filter.arguments.operand)\n  );\n}\n\nfunction _isNullWhereClauseComponent(filter) {\n  utils.assertHasProperties(\n    filter,\n    'columnName',\n    'arguments',\n    'arguments.isNull'\n  );\n\n  return '{0} {1}' .format(\n    _soqlEncodeColumnName(filter.columnName),\n    filter.arguments.isNull ? 'IS NULL' : 'IS NOT NULL'\n  );\n}\n\nfunction _timeRangeWhereClauseComponent(filter) {\n  utils.assertHasProperties(\n    filter,\n    'columnName',\n    'arguments',\n    'arguments.start',\n    'arguments.end'\n  );\n\n  return '{0} >= {1} AND {0} < {2}'.format(\n    _soqlEncodeColumnName(filter.columnName),\n    _soqlEncodeValue(filter.arguments.start),\n    _soqlEncodeValue(filter.arguments.end)\n  );\n}\n\nfunction _valueRangeWhereClauseComponent(filter) {\n  utils.assertHasProperties(\n    filter,\n    'columnName',\n    'arguments',\n    'arguments.start',\n    'arguments.end'\n  );\n\n  return '{0} >= {1} AND {0} < {2}'.format(\n    _soqlEncodeColumnName(filter.columnName),\n    _soqlEncodeValue(filter.arguments.start),\n    _soqlEncodeValue(filter.arguments.end)\n  );\n}\n\nmodule.exports = {\n  whereClauseNotFilteringOwnColumn: whereClauseNotFilteringOwnColumn,\n  whereClauseFilteringOwnColumn: whereClauseFilteringOwnColumn\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/dataProviders/SoqlHelpers.js\n ** module id = 41\n ** module chunks = 0\n **/","'use strict';\n\nvar _ = require('lodash');\nvar $ = require('jquery');\nvar utils = require('socrata-utils');\nvar ColumnChart = require('./views/ColumnChart');\nvar SoqlDataProvider = require('./dataProviders/SoqlDataProvider');\nvar SoqlHelpers = require('./dataProviders/SoqlHelpers');\n\nvar NAME_INDEX = 0;\nvar UNFILTERED_INDEX = 1;\nvar FILTERED_INDEX = 2;\nvar SELECTED_INDEX = 3;\nvar SOQL_DATA_PROVIDER_NAME_ALIAS = '__NAME_ALIAS__';\nvar SOQL_DATA_PROVIDER_VALUE_ALIAS = '__VALUE_ALIAS__';\nvar BASE_QUERY = 'SELECT `{0}` AS {1}, COUNT(*) AS {2} {3} GROUP BY `{0}` ORDER BY COUNT(*) DESC NULL LAST LIMIT 200';\nvar WINDOW_RESIZE_RERENDER_DELAY = 200;\n\n/**\n * Temporary polyfills until we can come up with a better implementation and include it somewhere else.\n */\n\nString.prototype.visualSize = _.memoize(\n  function(fontSize) {\n    var $ruler = $('#ruler');\n    var dimensions;\n\n    if ($ruler.length < 1) {\n      $('body').append('<span class=\"ruler\" id=\"ruler\"></span>');\n      $ruler = $('#ruler');\n    }\n    if (!fontSize) {\n      fontSize = '';\n    }\n    $ruler.css('font-size', fontSize);\n    $ruler.text(this + '');\n    dimensions = {width: $ruler.width(), height: $ruler.height()};\n    $ruler.remove();\n\n    return dimensions;\n  },\n  function(fontSize) { // memoization key\n    return this + '|' + fontSize;\n  }\n);\n\nString.prototype.visualLength = function(fontSize) {\n  return this.visualSize(fontSize).width;\n};\n\n/**\n * Instantiates a Socrata ColumnChart Visualization from the\n * `socrata-visualizations` package.\n *\n * Supported event triggers:\n * - invalidateSize: Forces a rerender, useful if the hosting page has resized the container.\n *\n * @param vif - https://docs.google.com/document/d/15oKmDfv39HrhgCJRTKtYadG8ZQvFUeyfx4kR_NZkBgc\n */\n$.fn.socrataColumnChart = function(vif) {\n\n  utils.assertHasProperties(\n    vif,\n    'columnName',\n    'configuration',\n    'datasetUid',\n    'domain',\n    'unit'\n  );\n\n  utils.assertHasProperties(\n    vif.unit,\n    'one',\n    'other'\n  );\n\n  utils.assertHasProperties(\n    vif.configuration,\n    'localization'\n  );\n\n  utils.assertHasProperties(\n    vif.configuration.localization,\n    'NO_VALUE',\n    'FLYOUT_UNFILTERED_AMOUNT_LABEL',\n    'FLYOUT_FILTERED_AMOUNT_LABEL',\n    'FLYOUT_SELECTED_NOTICE'\n  );\n\n  var $element = $(this);\n\n  // SoQL returns row results for display as columns.\n  // We need separate data providers for 'unfiltered'\n  // and 'filtered' requests, which are merged below.\n  var unfilteredSoqlDataProviderConfig = {\n    domain: vif.domain,\n    datasetUid: vif.datasetUid\n  };\n  var unfilteredSoqlDataProvider = new SoqlDataProvider(\n    unfilteredSoqlDataProviderConfig\n  );\n\n  var filteredSoqlDataProviderConfig = {\n    domain: vif.domain,\n    datasetUid: vif.datasetUid\n  };\n  var filteredSoqlDataProvider = new SoqlDataProvider(\n    filteredSoqlDataProviderConfig\n  );\n\n  vif.configuration.columns = {\n    name: NAME_INDEX,\n    unfilteredValue: UNFILTERED_INDEX,\n    filteredValue: FILTERED_INDEX,\n    selected: SELECTED_INDEX\n  };\n\n  var visualization = new ColumnChart($element, vif);\n  var visualizationData = [];\n  var rerenderOnResizeTimeout;\n  var _lastRenderedVif;\n\n  _attachEvents();\n  _updateData(vif);\n\n  /**\n   * Configuration\n   */\n\n  function _getRenderOptions(vifToRender) {\n    return {\n      showAllLabels: true,\n      showFiltered: true,\n      vif: vifToRender\n    };\n  }\n\n  /**\n   * Event handling\n   */\n\n  function _attachEvents() {\n\n    // Destroy on (only the first) 'SOCRATA_VISUALIZATION_DESTROY' event.\n    $element.one('SOCRATA_VISUALIZATION_DESTROY', function() {\n      clearTimeout(rerenderOnResizeTimeout);\n      visualization.destroy();\n      _detachEvents();\n    });\n\n    $(window).on('resize', _handleWindowResize);\n\n    $element.on('SOCRATA_VISUALIZATION_COLUMN_FLYOUT', _handleVisualizationFlyout);\n    $element.on('SOCRATA_VISUALIZATION_COLUMN_SELECTION', _handleSelection);\n    $element.on('SOCRATA_VISUALIZATION_COLUMN_OPTIONS', _handleExpandedToggle);\n    $element.on('SOCRATA_VISUALIZATION_INVALIDATE_SIZE', visualization.invalidateSize);\n    $element.on('SOCRATA_VISUALIZATION_RENDER_VIF', _handleRenderVif);\n  }\n\n  function _detachEvents() {\n\n    $(window).off('resize', _handleWindowResize);\n\n    $element.off('SOCRATA_VISUALIZATION_COLUMN_FLYOUT', _handleVisualizationFlyout);\n    $element.off('SOCRATA_VISUALIZATION_COLUMN_SELECTION', _handleSelection);\n    $element.off('SOCRATA_VISUALIZATION_COLUMN_OPTIONS', _handleExpandedToggle);\n    $element.off('SOCRATA_VISUALIZATION_INVALIDATE_SIZE', visualization.invalidateSize);\n    $element.off('SOCRATA_VISUALIZATION_RENDER_VIF', _handleRenderVif);\n  }\n\n  function _handleWindowResize() {\n\n    clearTimeout(rerenderOnResizeTimeout);\n\n    rerenderOnResizeTimeout = setTimeout(\n      _render,\n      // Add some jitter in order to make sure multiple visualizations are\n      // unlikely to all attempt to rerender themselves at the exact same\n      // moment.\n      WINDOW_RESIZE_RERENDER_DELAY + Math.floor(Math.random() * 10)\n    );\n  }\n\n  function _render(vifToRender) {\n    if (vifToRender) {\n      _lastRenderedVif = vifToRender;\n    }\n\n    visualization.render(\n      visualizationData,\n      _getRenderOptions(_lastRenderedVif)\n    );\n  }\n\n  function _handleVisualizationFlyout(event) {\n\n    var payload = event.originalEvent.detail;\n    var flyoutPayload = null;\n    var flyoutContent = null;\n    var flyoutTable = null;\n    var flyoutElements = null;\n    var flyoutTitle;\n    var flyoutUnfilteredValueLabelCell;\n    var flyoutUnfilteredValueCell;\n    var flyoutUnfilteredValueRow;\n    var filteredRowClass;\n    var flyoutFilteredValueLabelCell;\n    var flyoutFilteredValueCell;\n    var flyoutFilteredValueRow;\n    var flyoutSpacerRow;\n    var flyoutSelectedNoticeLabel;\n    var flyoutSelectedNoticeRow;\n\n    if (payload !== null) {\n\n      flyoutContent = $(document.createDocumentFragment());\n      flyoutTable = $('<table>', { 'class': 'socrata-flyout-table' });\n      flyoutElements = [];\n\n      // 'Datum Title'\n      flyoutTitle = $(\n        '<div>',\n        {\n          'class': 'socrata-flyout-title'\n        }\n      ).text(payload.title);\n\n      // 'Total: XXX rows'\n      flyoutUnfilteredValueLabelCell = $(\n        '<td>',\n        {\n          'class': 'socrata-flyout-cell'\n        }\n      ).text(payload.unfilteredValueLabel);\n\n      flyoutUnfilteredValueCell = $(\n        '<td>',\n        {\n          'class': 'socrata-flyout-cell'\n        }\n      ).text(payload.unfilteredValue);\n\n      flyoutUnfilteredValueRow = $(\n        '<tr>',\n        {\n          'class': 'socrata-flyout-row'\n        }\n      ).append([\n        flyoutUnfilteredValueLabelCell,\n        flyoutUnfilteredValueCell\n      ]);\n\n      flyoutElements.push(flyoutUnfilteredValueRow);\n\n      // If we are showing filtered data, then\n      // show the filtered data on the flyout.\n      if (payload.hasOwnProperty('filteredValue')) {\n\n        filteredRowClass = (payload.selected) ?\n          'socrata-flyout-cell is-selected' :\n          'socrata-flyout-cell emphasis';\n\n        // 'Filtered: XXX rows'\n        flyoutFilteredValueLabelCell = $(\n          '<td>',\n          {\n            'class': filteredRowClass\n          }\n        ).text(payload.filteredValueLabel);\n\n        flyoutFilteredValueCell = $(\n          '<td>',\n          {\n            'class': filteredRowClass\n          }\n        ).text(payload.filteredValue);\n\n        flyoutFilteredValueRow = $(\n          '<tr>',\n          {\n            'class': 'socrata-flyout-row'\n          }\n        ).append([\n          flyoutFilteredValueLabelCell,\n          flyoutFilteredValueCell\n        ]);\n\n        flyoutElements.push(flyoutFilteredValueRow);\n      }\n\n      // If we are hovering over a bar we are\n      // currently filtering by, then display a special\n      // flyout message.\n      if (payload.selected) {\n\n        // 'This visualization is currently filtered...'\n        flyoutSpacerRow = $(\n          '<tr>',\n          {\n            'class': 'socrata-flyout-row',\n            'colspan': '2'\n          }\n        ).append(\n          $('<td>', { 'class': 'socrata-flyout-cell' }).html('&#8203;')\n        );\n\n        flyoutSelectedNoticeLabel = $(\n          '<td>',\n          {\n            'class': 'socrata-flyout-cell'\n          }\n        ).text(payload.selectedNotice);\n\n        flyoutSelectedNoticeRow = $(\n          '<tr>',\n          {\n            'class': 'socrata-flyout-row',\n            'colspan': '2'\n          }\n        ).append([\n          flyoutSelectedNoticeLabel\n        ]);\n\n        flyoutElements.push(flyoutSpacerRow);\n        flyoutElements.push(flyoutSelectedNoticeRow);\n      }\n\n      flyoutTable.append(flyoutElements);\n\n      flyoutContent.append([\n        flyoutTitle,\n        flyoutTable\n      ]);\n\n      flyoutPayload = {\n        element: payload.element,\n        content: flyoutContent,\n        rightSideHint: false,\n        belowTarget: false\n      };\n    }\n\n    $element[0].dispatchEvent(\n      new window.CustomEvent(\n        'SOCRATA_VISUALIZATION_COLUMN_CHART_FLYOUT',\n        {\n          detail: flyoutPayload,\n          bubbles: true\n        }\n      )\n    );\n  }\n\n  function _handleSelection(event) {\n    var payload = event.originalEvent.detail;\n    var newVif = _.cloneDeep(_lastRenderedVif);\n    var ownFilterOperands = newVif.\n      filters.\n      filter(function(filter) {\n        return filter.columnName === newVif.columnName;\n      }).map(function(filter) {\n        return filter.arguments.operand;\n      });\n\n    newVif.filters = newVif.\n      filters.\n      filter(function(filter) {\n        return filter.columnName !== newVif.columnName;\n      });\n\n    if (ownFilterOperands.indexOf(payload.name) === -1) {\n\n      newVif.filters.push(\n        {\n          'columnName': newVif.columnName,\n          'function': 'binaryOperator',\n          'arguments': {\n            'operator': '=',\n            'operand': payload.name\n          }\n        }\n      );\n    }\n\n    $element[0].dispatchEvent(\n      new window.CustomEvent(\n        'SOCRATA_VISUALIZATION_VIF_UPDATED',\n        {\n          detail: newVif,\n          bubbles: true\n        }\n      )\n    );\n  }\n\n  function _handleExpandedToggle() {// event) { ---> Linting sucks\n\n    // var payload = event.originalEvent.detail;\n\n    // TODO: Implement.\n  }\n\n  function _handleRenderVif(event) {\n    var newVif = event.originalEvent.detail;\n\n    if (newVif.type !== 'columnChart') {\n      throw new Error(\n        'Cannot update VIF; old type: `columnChart`, new type: `{0}`.'.\n          format(\n            newVif.type\n          )\n        );\n    }\n\n    _updateData(newVif);\n  }\n\n  /**\n   * Data requests\n   */\n\n  function _updateData(vifToRender) {\n\n    var unfilteredQueryString = BASE_QUERY.format(\n      vifToRender.columnName,\n      SOQL_DATA_PROVIDER_NAME_ALIAS,\n      SOQL_DATA_PROVIDER_VALUE_ALIAS,\n      ''\n    );\n\n    var unfilteredSoqlQuery = unfilteredSoqlDataProvider.\n      query(\n        unfilteredQueryString,\n        SOQL_DATA_PROVIDER_NAME_ALIAS,\n        SOQL_DATA_PROVIDER_VALUE_ALIAS\n      )\n      ['catch'](function(error) {\n        _logError(error);\n        visualization.renderError();\n      });\n\n    var whereClauseComponents = SoqlHelpers.whereClauseFilteringOwnColumn(vifToRender);\n    var filteredQueryString = BASE_QUERY.format(\n      vifToRender.columnName,\n      SOQL_DATA_PROVIDER_NAME_ALIAS,\n      SOQL_DATA_PROVIDER_VALUE_ALIAS,\n      (whereClauseComponents.length > 0) ?\n        'WHERE {0}'.format(whereClauseComponents) :\n        ''\n    );\n\n    var filteredSoqlQuery = filteredSoqlDataProvider.\n      query(\n        filteredQueryString,\n        SOQL_DATA_PROVIDER_NAME_ALIAS,\n        SOQL_DATA_PROVIDER_VALUE_ALIAS\n      )\n      ['catch'](function(error) {\n        _logError(error);\n        visualization.renderError();\n      });\n\n    Promise.\n      all([unfilteredSoqlQuery, filteredSoqlQuery]).\n      then(function(values) {\n        var unfilteredQueryResponse = values[0];\n        var filteredQueryResponse = values[1];\n\n        visualizationData = _mergeUnfilteredAndFilteredData(\n          vifToRender,\n          unfilteredQueryResponse,\n          filteredQueryResponse\n        );\n\n        _render(vifToRender);\n      })\n      ['catch'](function(error) {\n        _logError(error);\n        visualization.renderError();\n      });\n  }\n\n  function _mergeUnfilteredAndFilteredData(renderedVif, unfiltered, filtered) {\n    var unfilteredAsHash;\n    var filteredAsHash;\n    var selectedColumns = renderedVif.\n      filters.\n      filter(function(filter) {\n        return filter.columnName === renderedVif.columnName;\n      }).\n      map(function(filter) {\n        return filter.arguments.operand;\n      });\n\n    unfilteredAsHash = _.indexBy(\n      unfiltered.rows,\n      unfiltered.columns.indexOf(SOQL_DATA_PROVIDER_NAME_ALIAS)\n    );\n\n    filteredAsHash = _.indexBy(\n      filtered.rows,\n      filtered.columns.indexOf(SOQL_DATA_PROVIDER_NAME_ALIAS)\n    );\n\n    return Object.keys(unfilteredAsHash).map(function(name) {\n      var datumIsSelected = selectedColumns.indexOf(name) > -1;\n      var result = [undefined, undefined, undefined, undefined];\n\n      result[NAME_INDEX] = (_.isNull(name) || _.isUndefined(name)) ? '' : name;\n      result[UNFILTERED_INDEX] = Number(unfilteredAsHash[name][1]);\n      result[FILTERED_INDEX] = (filteredAsHash.hasOwnProperty(name)) ?\n        Number(filteredAsHash[name][1]) :\n        0;\n      result[SELECTED_INDEX] = datumIsSelected;\n\n      return result;\n    });\n  }\n\n  function _logError(error) {\n    if (window.console && window.console.error) {\n      console.error(error);\n    }\n  }\n\n  return this;\n};\n\nmodule.exports = $.fn.socrataColumnChart;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/ColumnChart.js\n ** module id = 42\n ** module chunks = 0\n **/","'use strict';\n\nvar _ = require('lodash');\nvar $ = require('jquery');\nvar utils = require('socrata-utils');\nvar FeatureMap = require('./views/FeatureMap');\nvar GeospaceDataProvider = require('./dataProviders/GeospaceDataProvider');\nvar TileserverDataProvider = require('./dataProviders/TileserverDataProvider');\nvar SoqlDataProvider = require('./dataProviders/SoqlDataProvider');\nvar MetadataProvider = require('./dataProviders/MetadataProvider');\n\nvar DEFAULT_TILESERVER_HOSTS = [\n  'https://tileserver1.api.us.socrata.com',\n  'https://tileserver2.api.us.socrata.com',\n  'https://tileserver3.api.us.socrata.com',\n  'https://tileserver4.api.us.socrata.com'\n];\nvar DEFAULT_FEATURES_PER_TILE = 256 * 256;\n// known in data lens as \"simple blue\"\nvar DEFAULT_BASE_LAYER_URL = 'https://a.tiles.mapbox.com/v3/socrata-apps.3ecc65d4/{z}/{x}/{y}.png';\nvar DEFAULT_BASE_LAYER_OPACITY = 0.42;\nvar WINDOW_RESIZE_RERENDER_DELAY = 200;\n\n/**\n * Instantiates a Socrata FeatureMap Visualization from the\n * `socrata-visualizations` package.\n *\n * @param vif - https://docs.google.com/document/d/15oKmDfv39HrhgCJRTKtYadG8ZQvFUeyfx4kR_NZkBgc\n */\n$.fn.socrataFeatureMap = function(vif) {\n\n  utils.assertHasProperties(\n    vif,\n    'columnName',\n    'configuration',\n    'datasetUid',\n    'domain',\n    'unit'\n  );\n\n  utils.assertHasProperties(\n    vif.unit,\n    'one',\n    'other'\n  );\n\n  utils.assertHasProperties(\n    vif.configuration,\n    'localization'\n  );\n\n  utils.assertHasProperties(\n    vif.configuration.localization,\n    'FLYOUT_FILTER_NOTICE',\n    'FLYOUT_FILTER_OR_ZOOM_NOTICE',\n    'FLYOUT_DENSE_DATA_NOTICE',\n    'FLYOUT_CLICK_TO_INSPECT_NOTICE',\n    'FLYOUT_CLICK_TO_LOCATE_USER_TITLE',\n    'FLYOUT_CLICK_TO_LOCATE_USER_NOTICE',\n    'FLYOUT_LOCATING_USER_TITLE',\n    'FLYOUT_LOCATE_USER_ERROR_TITLE',\n    'FLYOUT_LOCATE_USER_ERROR_NOTICE',\n    'FLYOUT_PAN_ZOOM_DISABLED_WARNING_TITLE',\n    'ROW_INSPECTOR_ROW_DATA_QUERY_FAILED',\n    'USER_CURRENT_POSITION'\n  );\n\n  var $element = $(this);\n  var datasetMetadata;\n\n  // Geospace has knowledge of the extents of a column, which\n  // we use to modify point data queries with a WITHIN_BOX clause.\n  var geospaceDataProviderConfig = {\n    domain: vif.domain,\n    datasetUid: vif.datasetUid\n  };\n  var geospaceDataProvider = new GeospaceDataProvider(\n    geospaceDataProviderConfig\n  );\n\n  // Tileserver serves tile data using the standard {z}/{x}/{y} URL\n  // format. It returns protocol buffers containing point offsets from\n  // the tile origin (top left).\n  var tileserverDataProviderConfig = {\n    domain: vif.domain,\n    datasetUid: vif.datasetUid,\n    columnName: vif.columnName,\n    featuresPerTile: DEFAULT_FEATURES_PER_TILE,\n    tileserverHosts: vif.configuration.tileserverHosts || DEFAULT_TILESERVER_HOSTS\n  };\n  var tileserverDataProvider = new TileserverDataProvider(\n    tileserverDataProviderConfig\n  );\n\n  // SoQL returns row results for display in the row inspector\n  var soqlDataProviderConfig = {\n    domain: vif.domain,\n    datasetUid: vif.datasetUid\n  };\n  var soqlDataProvider = new SoqlDataProvider(\n    soqlDataProviderConfig\n  );\n\n  if (vif.configuration.datasetMetadata) {\n\n    // If the caller already has datasetMetadata, it can be passed through as\n    // a configuration property.\n    datasetMetadata = vif.configuration.datasetMetadata;\n\n  } else {\n\n    // Otherwise, we also need to fetch the dataset metadata for the\n    // specified dataset so that we can use its column definitions when\n    // formatting data for the row inspector.\n    var metadataProviderConfig = {\n      domain: vif.domain,\n      datasetUid: vif.datasetUid\n    };\n    var metadataProvider = new MetadataProvider(\n      metadataProviderConfig\n    );\n\n    // Make the dataset metadata request before initializing the visualization\n    // in order to ensure that the column metadata is present before any of the\n    // row inspector events (which expect it to be present) can be fired.\n    //\n    // If this request fails, we will fall back to listing columns\n    // alphabetically instead of in the order in which they appear in the\n    // dataset grid view.\n    metadataProvider.\n      getDatasetMetadata().\n      then(\n        handleDatasetMetadataRequestSuccess,\n        handleDatasetMetadataRequestError\n      )['catch'](function(e) {\n        logError(e);\n      });\n  }\n\n  var visualization = new FeatureMap(\n    $element,\n    vif\n  );\n  // The visualizationRenderOptions may change in response to user actions\n  // and are passed as an argument to every render call.\n  var visualizationRenderOptions = {\n    baseLayer: {\n      url: vif.configuration.baseLayerUrl || DEFAULT_BASE_LAYER_URL,\n      opacity: vif.configuration.baseLayerOpacity || DEFAULT_BASE_LAYER_OPACITY\n    }\n  };\n  var rerenderOnResizeTimeout;\n\n  /**\n   * Initial data requests to set up visualization state\n   */\n\n  // We query the extent of the features we are rendering in order to make\n  // individual tile requests more performant (through the use of a\n  // WITHIN_BOX query clause).\n  geospaceDataProvider.\n    getFeatureExtent(vif.columnName).\n    then(\n      handleFeatureExtentQuerySuccess,\n      handleFeatureExtentQueryError\n    )['catch'](function(e) {\n      logError(e);\n    });\n\n  initializeVisualization();\n\n  /**\n   * Events\n   */\n\n  function attachEvents() {\n\n    // Destroy on (only the first) 'SOCRATA_VISUALIZATION_DESTROY' event.\n    $element.one('SOCRATA_VISUALIZATION_DESTROY', function() {\n      clearTimeout(rerenderOnResizeTimeout);\n      visualization.destroy();\n      detachEvents();\n    });\n\n    $element.on('SOCRATA_VISUALIZATION_FLYOUT_SHOW', handleVisualizationFlyoutShow);\n    $element.on('SOCRATA_VISUALIZATION_FLYOUT_HIDE', handleVisualizationFlyoutHide);\n    $element.on('SOCRATA_VISUALIZATION_ROW_INSPECTOR_QUERY', handleRowInspectorQuery);\n    $element.on('SOCRATA_VISUALIZATION_INVALIDATE_SIZE', visualization.invalidateSize);\n  }\n\n  function detachEvents() {\n\n    $element.off('SOCRATA_VISUALIZATION_FLYOUT_SHOW', handleVisualizationFlyoutShow);\n    $element.off('SOCRATA_VISUALIZATION_FLYOUT_HIDE', handleVisualizationFlyoutHide);\n    $element.off('SOCRATA_VISUALIZATION_ROW_INSPECTOR_QUERY', handleRowInspectorQuery);\n    $element.off('SOCRATA_VISUALIZATION_INVALIDATE_SIZE', visualization.invalidateSize);\n  }\n\n  /**\n   * Event handlers\n   */\n\n  function _handleWindowResize() {\n\n    clearTimeout(rerenderOnResizeTimeout);\n\n    rerenderOnResizeTimeout = setTimeout(\n      renderIfReady,\n      // Add some jitter in order to make sure multiple visualizations are\n      // unlikely to all attempt to rerender themselves at the exact same\n      // moment.\n      WINDOW_RESIZE_RERENDER_DELAY + Math.floor(Math.random() * 10)\n    );\n  }\n\n  function handleDatasetMetadataRequestSuccess(data) {\n\n    datasetMetadata = data;\n  }\n\n  function handleDatasetMetadataRequestError(error) {\n\n    // The only consumer of dataset metadata is the row inspector flyout.\n    // If the request fails, we won't show the row inspector on click.\n    console.error('Failed to fetch dataset metadata: {0}'.format(error));\n  }\n\n  function handleFeatureExtentQuerySuccess(response) {\n    updateRenderOptionsBounds(response);\n    renderIfReady();\n  }\n\n  function handleFeatureExtentQueryError() {\n    renderError();\n  }\n\n  function handleVisualizationFlyoutShow(event) {\n    var payload = event.originalEvent.detail;\n    var $flyoutContent = null;\n    var $flyoutTitle;\n    var $flyoutNotice;\n    var flyoutPayload;\n\n    event.stopPropagation();\n\n    if (payload !== null) {\n\n      $flyoutContent = $(document.createDocumentFragment());\n\n      // 'Datum Title'\n      $flyoutTitle = $(\n        '<div>',\n        {\n          'class': 'socrata-flyout-title'\n        }\n      ).text(payload.title);\n\n      $flyoutContent.append($flyoutTitle);\n\n      if (payload.hasOwnProperty('notice') && payload.notice) {\n\n        $flyoutNotice = $(\n          '<div>',\n          {\n            'class': 'socrata-flyout-notice'\n          }\n        ).text(payload.notice);\n\n        $flyoutContent.append($flyoutNotice);\n      }\n\n      if (payload.hasOwnProperty('flyoutOffset') && payload.flyoutOffset) {\n\n        flyoutPayload = {\n          flyoutOffset: payload.flyoutOffset,\n          content: $flyoutContent,\n          rightSideHint: false,\n          belowTarget: false\n        };\n\n      } else {\n\n        flyoutPayload = {\n          element: payload.element,\n          content: $flyoutContent,\n          rightSideHint: false,\n          belowTarget: false\n        };\n\n      }\n\n      $element[0].dispatchEvent(\n        new CustomEvent(\n          'SOCRATA_VISUALIZATION_FEATURE_MAP_FLYOUT',\n          {\n            detail: flyoutPayload,\n            bubbles: true\n          }\n        )\n      );\n    }\n  }\n\n  function handleVisualizationFlyoutHide() {\n    $element[0].dispatchEvent(\n      new window.CustomEvent(\n        'SOCRATA_VISUALIZATION_FEATURE_MAP_FLYOUT',\n        {\n          detail: null,\n          bubbles: true\n        }\n      )\n    );\n  }\n\n  function handleRowInspectorQuery(event) {\n    if (!datasetMetadata) {\n      // Dataset metadata request either failed or isn't ready yet.\n      // Pop up an error.\n      handleRowInspectorQueryError();\n      return;\n    }\n\n    var payload = event.originalEvent.detail;\n\n    var query = '$offset=0&$limit={0}&$order=distance_in_meters({1}, \"POINT({2} {3})\"){4}'.\n      format(\n        payload.rowCount,\n        vif.columnName,\n        payload.latLng.lng,\n        payload.latLng.lat,\n        generateWithinBoxClause(vif.columnName, payload.queryBounds)\n      );\n\n    var displayableColumns = metadataProvider.getDisplayableColumns(datasetMetadata);\n\n    function generateWithinBoxClause(columnName, bounds) {\n\n      return '&$where=within_box({0}, {1}, {2})'.format(\n        columnName,\n        '{0}, {1}'.format(bounds.northeast.lat, bounds.northeast.lng),\n        '{0}, {1}'.format(bounds.southwest.lat, bounds.southwest.lng)\n      );\n    }\n\n    soqlDataProvider.\n      getRows(_.pluck(displayableColumns, 'fieldName'), query).\n      then(\n        handleRowInspectorQuerySuccess,\n        handleRowInspectorQueryError\n      )['catch'](function(e) {\n        logError(e);\n      });\n\n    event.stopPropagation();\n  }\n\n  function handleRowInspectorQuerySuccess(data) {\n\n    $element[0].dispatchEvent(\n      new window.CustomEvent(\n        'SOCRATA_VISUALIZATION_ROW_INSPECTOR_UPDATE',\n        {\n          detail: {\n            data: formatRowInspectorData(datasetMetadata, data),\n            error: false,\n            message: null\n          },\n          bubbles: true\n        }\n      )\n    );\n  }\n\n  function handleRowInspectorQueryError() {\n\n    $element[0].dispatchEvent(\n      new window.CustomEvent(\n        'SOCRATA_VISUALIZATION_ROW_INSPECTOR_UPDATE',\n        {\n          detail: {\n            data: null,\n            error: true,\n            message: vif.configuration.localization.ROW_INSPECTOR_ROW_DATA_QUERY_FAILED\n          },\n          bubbles: true\n        }\n      )\n    );\n  }\n\n  /**\n   * Helper functions\n   */\n\n  function initializeVisualization() {\n\n    attachEvents();\n\n    // For now, we don't need to use any where clause but the default\n    // one, so we just inline the call to\n    // updateRenderOptionsVectorTileGetter.\n    updateRenderOptionsVectorTileGetter(soqlDataProvider.buildBaseQuery(vif.filters), vif.configuration.useOriginHost);\n    renderIfReady();\n  }\n\n  function updateRenderOptionsBounds(extent) {\n\n    var southWest = L.latLng(extent.southwest[0], extent.southwest[1]);\n    var northEast = L.latLng(extent.northeast[0], extent.northeast[1]);\n\n    visualizationRenderOptions.bounds = L.latLngBounds(southWest, northEast);\n  }\n\n  function updateRenderOptionsVectorTileGetter(whereClause, useOriginHost) {\n\n    useOriginHost = useOriginHost || false;\n\n    visualizationRenderOptions.vectorTileGetter = tileserverDataProvider.buildTileGetter(\n      whereClause,\n      useOriginHost\n    );\n  }\n\n  function renderIfReady() {\n\n    var hasBounds = visualizationRenderOptions.hasOwnProperty('bounds');\n    var hasTileGetter = visualizationRenderOptions.hasOwnProperty('vectorTileGetter');\n\n    if (hasBounds && hasTileGetter) {\n\n      visualization.render(visualizationRenderOptions);\n    }\n  }\n\n  function renderError() {\n    visualization.renderError();\n  }\n\n  function formatRowInspectorData(datasetMetadata, data) {\n\n    // Each of our rows will be mapped to 'formattedRowData', an array of\n    // objects.  Each row corresponds to a single page in the flannel.\n    return data.rows.map(\n      function(row) {\n        return orderRowDataByColumnIndex(\n          datasetMetadata.columns,\n          data.columns,\n          row\n        );\n      }\n    );\n  }\n\n  function orderRowDataByColumnIndex(datasetMetadataColumns, columnNames, row) {\n\n    var formattedRowData = [];\n\n    // This method takes in the column name of the subColumn\n    // (e.g. Crime Location (address)) and the parentColumnName of that\n    // subColumn (e.g. Crime Location) and returns the subColumn string\n    // within the parentheses (address).\n    function extractSubColumnName(existingName, parentColumnName) {\n\n      var subColumnMatch = existingName.match(/\\(([^()]+)\\)$/);\n\n      if (subColumnMatch.length >= 2) {\n\n        var existingNameSuffix = subColumnMatch[1];\n\n        if (_.contains(['address', 'city', 'state', 'zip'], existingNameSuffix)) {\n          return existingNameSuffix;\n        }\n      }\n\n      return existingName.replace('{0} '.format(parentColumnName), '');\n    }\n\n    columnNames.forEach(\n      function(columnName) {\n        var columnMetadata = _.find(datasetMetadataColumns, {fieldName: columnName});\n\n        if (_.isPlainObject(columnMetadata)) {\n\n          var columnValue = row[columnNames.indexOf(columnName)];\n          columnValue = _.isUndefined(columnValue) ? '' : columnValue;\n\n          // If we're formatting a sub-column, first find the parent\n          // column name and position, and then format accordingly.\n          // Otherwise, just format the normal column.\n          //\n          // NOTE: We can rely upon sub-columns being added after their\n          // corresponding parent columns.\n          if (columnMetadata.isSubcolumn) {\n\n            // For example, if column name is 'crime_location_address'\n            // or 'crime_location_zip', the parentColumnName would be\n            // 'crime_location'.\n            var parentColumnName = columnName.slice(0, columnName.lastIndexOf('_'));\n            var parentColumnMetadata = _.find(datasetMetadataColumns, {fieldName: parentColumnName});\n\n            if (_.isPlainObject(parentColumnMetadata)) {\n\n              var parentPosition = parentColumnMetadata.position;\n              var subColumnName = extractSubColumnName(columnName, parentColumnName);\n              var subColumnDatum = {\n                column: subColumnName,\n                value: _.isObject(columnValue) ? [columnValue] : columnValue,\n                format: columnMetadata.format,\n                physicalDatatype: columnMetadata.physicalDatatype\n              };\n\n              formattedRowData[parentPosition].value.push(subColumnDatum);\n            }\n\n          } else {\n\n            // If the column value is an object (e.g. a coordinate point),\n            // we should format it slightly differently.\n            formattedRowData[columnMetadata.position] = {\n              column: columnName,\n              value: _.isObject(columnValue) ? [columnValue] : columnValue,\n              format: _.isObject(columnValue) ? undefined : columnMetadata.format,\n              physicalDatatype: columnMetadata.physicalDatatype\n            };\n\n          }\n        }\n      }\n    );\n\n    // Since we are updating individual indices of formattedRowData\n    // out of order, it is possible that we may not update all of them.\n    // Un-updated indices will default to undefined, and the following\n    // filter will collapse the array down to only defined values.\n    return formattedRowData.\n      filter(\n        function(datum) {\n          return !_.isUndefined(datum);\n        }\n      );\n  }\n\n  function logError(e) {\n\n    if (console && console.error) {\n      console.error(e);\n    }\n  }\n\n  return this;\n};\n\nmodule.exports = $.fn.socrataFeatureMap;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/FeatureMap.js\n ** module id = 43\n ** module chunks = 0\n **/","'use strict';\n\nvar _ = require('lodash');\nvar $ = require('jquery');\nvar utils = require('socrata-utils');\nvar Table = require('./views/Table');\nvar Pager = require('./views/Pager');\nvar SoqlDataProvider = require('./dataProviders/SoqlDataProvider');\nvar MetadataProvider = require('./dataProviders/MetadataProvider');\n\nvar ROW_HEIGHT_PX = 39;\n\n$.fn.socrataTable = function(vif) {\n  'use strict';\n\n  utils.assertHasProperties(\n    vif,\n    'configuration',\n    'datasetUid',\n    'domain',\n    'unit.one',\n    'unit.other',\n    'configuration.order'\n  );\n\n  utils.assert(\n    Array.isArray(vif.configuration.order),\n    'jQuery.fn.socrataTable: VIF configuration must include an \"order\" key whose is an Array.'\n  );\n\n  utils.assertEqual(\n    vif.configuration.order.length,\n    1\n  );\n\n  utils.assertHasProperties(\n    vif.configuration.order[0],\n    'ascending',\n    'columnName'\n  );\n\n  var $element = $(this);\n\n  var soqlDataProvider = new SoqlDataProvider(\n    _.pick(vif, 'datasetUid', 'domain')\n  );\n\n  var metadataProvider = new MetadataProvider(\n    _.pick(vif, 'datasetUid', 'domain')\n  );\n\n  // Returns a promise for the dataset metadata.\n  // The response is cached for the duration of this\n  // table component's existence.\n  var _getDatasetMetadata = _.once(function() {\n    return metadataProvider.getDatasetMetadata();\n  });\n\n  var visualization = new Table($element, vif);\n  var pager = new Pager($element, vif);\n\n  // Holds all state regarding the table's visual presentation.\n  // Do _NOT_ update this directly, use _setState() or _updateState().\n  // This is to ensure all state changes are reflected in the UI.\n  var _renderState = {\n    // Is the table busy?\n    busy: false,\n\n    // Holds result of last successful data fetch, plus\n    // the metadata regarding that request (start index,\n    // order, etc).\n    // {\n    //   rows: <data from SoqlDataProvider>,\n    //   columns: <data from SoqlDataProvider>,\n    //   datasetMetadata: <data from SoqlDataProvider>,\n    //   startIndex: index of first row (offset),\n    //   pageSize: number of items in page (not necessarily in rows[]).\n    //   order: {\n    //     [ // only one element supported.\n    //       {\n    //         columnName: <name of column to sort by>,\n    //         ascending: boolean\n    //       }\n    //     ]\n    //   }\n    // }\n    fetchedData: null,\n\n    datasetRowCount: null\n  };\n\n  _attachEvents();\n\n  $element.addClass('socrata-paginated-table');\n\n  soqlDataProvider.getRowCount().then(function(rowCount) {\n    _updateState({ datasetRowCount: rowCount });\n  });\n\n  _render();\n\n  _setDataQuery(\n    0, // Offset\n    _computePageSize(),\n    _.get(vif, 'configuration.order')\n  ).then(function() {\n    visualization.freezeColumnWidthsAndRender();\n  });\n\n  /**\n   * Configuration\n   */\n\n  function _getRenderOptions() {\n    return _.get(vif, 'configuration.order');\n  }\n\n  /**\n   * Event Handling\n   */\n  function _attachEvents() {\n    $element.one('SOCRATA_VISUALIZATION_DESTROY', function() {\n      visualization.destroy();\n      _detachEvents();\n    });\n\n    $element.on('SOCRATA_VISUALIZATION_COLUMN_CLICKED', _handleColumnClicked);\n    $element.on('SOCRATA_VISUALIZATION_COLUMN_FLYOUT', _handleColumnFlyout);\n    $element.on('SOCRATA_VISUALIZATION_CELL_FLYOUT', _handleCellFlyout);\n    $element.on('SOCRATA_VISUALIZATION_PAGINATION_PREVIOUS', _handlePrevious);\n    $element.on('SOCRATA_VISUALIZATION_PAGINATION_NEXT', _handleNext);\n    $element.on('SOCRATA_VISUALIZATION_INVALIDATE_SIZE', _handleSizeChange);\n  }\n\n  function _detachEvents() {\n    $element.off('SOCRATA_VISUALIZATION_COLUMN_CLICKED', _handleColumnClicked);\n    $element.off('SOCRATA_VISUALIZATION_COLUMN_FLYOUT', _handleColumnFlyout);\n    $element.off('SOCRATA_VISUALIZATION_CELL_FLYOUT', _handleCellFlyout);\n    $element.off('SOCRATA_VISUALIZATION_PAGINATION_PREVIOUS', _handlePrevious);\n    $element.off('SOCRATA_VISUALIZATION_PAGINATION_NEXT', _handleNext);\n    $element.off('SOCRATA_VISUALIZATION_INVALIDATE_SIZE', _handleSizeChange);\n  }\n\n  function _render() {\n    if (_renderState.fetchedData) {\n      visualization.render(\n        _renderState.fetchedData,\n        _renderState.fetchedData.order\n      );\n\n      pager.render({\n        unit: vif.unit,\n        startIndex: _renderState.fetchedData.startIndex,\n        endIndex: Math.min(_renderState.fetchedData.startIndex + _renderState.fetchedData.rows.length, _renderState.datasetRowCount),\n        datasetRowCount: _renderState.datasetRowCount,\n        disabled: _renderState.busy || !_.isFinite(_renderState.datasetRowCount)\n      });\n\n      $element.addClass('loaded');\n    } else {\n      // No fetched data. Render placeholders, so we can determine pager heights.\n      $element.removeClass('loaded');\n      pager.render({\n        unit: vif.unit,\n        startIndex: 0,\n        endIndex: 0,\n        datasetRowCount: 0,\n        disabled: true\n      });\n\n    }\n  }\n\n  function _handleColumnClicked(event) {\n    var alreadySorted;\n    var newOrder;\n    var columnName = event.originalEvent.detail;\n\n    utils.assertIsOneOfTypes(event.originalEvent.detail, 'string');\n\n    if (_renderState.busy) { return; }\n\n    utils.assert(\n      _.include(_.pluck(_renderState.fetchedData.columns, 'fieldName'), columnName),\n      'column name not found to sort by: {0}'.format(columnName)\n    );\n\n    alreadySorted = _renderState.fetchedData.order[0].columnName === columnName;\n\n    if (alreadySorted) {\n\n      // Toggle sort direction;\n      newOrder = _.cloneDeep(_renderState.fetchedData.order);\n      newOrder[0].ascending = !newOrder[0].ascending;\n    } else {\n      newOrder = [{\n        columnName: columnName,\n        ascending: true\n      }]\n    }\n\n    _setDataQuery(\n      0,\n      _renderState.fetchedData.pageSize,\n      newOrder\n    );\n  }\n\n  function _handleColumnFlyout(event) {\n    var payload = event.originalEvent.detail;\n\n    $element[0].dispatchEvent(\n      new window.CustomEvent(\n        'SOCRATA_VISUALIZATION_TABLE_FLYOUT',\n        {\n          detail: payload,\n          bubbles: true\n        }\n      )\n    );\n  }\n\n  function _handleCellFlyout(event) {\n    var payload = event.originalEvent.detail;\n\n    $element[0].dispatchEvent(\n      new window.CustomEvent(\n        'SOCRATA_VISUALIZATION_TABLE_FLYOUT',\n        {\n          detail: payload,\n          bubbles: true\n        }\n      )\n    );\n  }\n\n  function _handleNext() {\n    _setDataQuery(\n      _renderState.fetchedData.startIndex + _renderState.fetchedData.pageSize,\n      _renderState.fetchedData.pageSize,\n      _renderState.fetchedData.order\n    );\n  }\n  function _handlePrevious() {\n    _setDataQuery(\n      Math.max(0, _renderState.fetchedData.startIndex - _renderState.fetchedData.pageSize),\n      _renderState.fetchedData.pageSize,\n      _renderState.fetchedData.order\n    );\n  }\n\n  function _handleSizeChange() {\n    var pageSize = _computePageSize();\n    var oldPageSize = _.get(_renderState, 'fetchedData.pageSize');\n    // Canceling inflight requests is hard.\n    // If we're currently fetching data, ignore the size change.\n    // The size will be rechecked once the current request\n    // is complete.\n    if (!_renderState.busy && oldPageSize !== pageSize && _renderState.fetchedData) {\n      _setDataQuery(\n        _renderState.fetchedData.startIndex,\n        pageSize,\n        _renderState.fetchedData.order\n      );\n    }\n  }\n\n  function _computePageSize() {\n    var overallHeight = $element.height();\n    var pagerHeight = $element.find('.socrata-pager').outerHeight();\n    var heightRemaining = overallHeight - pagerHeight;\n    return visualization.howManyRowsCanFitInHeight(heightRemaining);\n  }\n\n  /**\n   * Data Requests\n   */\n\n  function _setDataQuery(startIndex, pageSize, order) {\n    utils.assert(order.length === 1, 'order parameter must be an array with exactly one element.');\n\n    if (_renderState.busy) {\n      throw new Error('Called _makeDataRequest while a request already in progress - not allowed.');\n    }\n\n    _updateState({ busy: true });\n\n    var displayableColumns = _getDisplayableColumns();\n    var soqlData = displayableColumns.then(function(displayableColumns) {\n      return soqlDataProvider.getTableData(\n        _.pluck(displayableColumns, 'fieldName'),\n        order,\n        startIndex,\n        pageSize\n      );\n    });\n\n    return Promise.all([\n      _getDatasetMetadata(),\n      displayableColumns,\n      soqlData\n    ]).then(function(resolutions) {\n      var datasetMetadata = resolutions[0];\n      var displayableColumns = resolutions[1];\n      var soqlData = resolutions[2];\n\n      // Rows can either be undefined OR of the exact length of the\n      // displayableColumns.\n      utils.assert(_.all(soqlData.rows, function(row) {\n        return !row || displayableColumns.length === row.length;\n      }));\n\n      soqlData.rows.length = pageSize; // Pad/trim row count to fit display.\n      _updateState({\n        fetchedData: {\n          rows: soqlData.rows,\n          columns: displayableColumns,\n          startIndex: startIndex,\n          pageSize: pageSize,\n          order: order\n        },\n        busy: false\n      });\n\n    }).catch(function(error) {\n      try {\n        console.error('Error while fulfilling table data request: {0}'.format(error));\n        _updateState({ busy: false });\n      } catch (updateStateError) {\n        console.error('Error while processing failed SODA request (reported separately)', updateStateError);\n      }\n      throw error;\n    });\n  }\n\n  function _getDisplayableColumns() {\n    return _getDatasetMetadata().then(metadataProvider.getDisplayableColumns);\n  }\n\n  function _getVif() {\n    var newVif = _.cloneDeep(vif);\n    _.set(\n      newVif,\n      'configuration.order',\n      _.cloneDeep(\n        _.get(_renderState, 'fetchedData.order', vif.configuration.order)\n      )\n    );\n\n    return newVif;\n  }\n\n  // Updates only specified UI state.\n  function _updateState(newPartialState) {\n    _setState(_.extend(\n      {},\n      _renderState,\n      newPartialState\n    ));\n  }\n\n  // Replaces entire UI state.\n  function _setState(newState) {\n    var becameIdle;\n    var changedOrder;\n    if (!_.isEqual(_renderState, newState)) {\n      becameIdle = !newState.busy && _renderState.busy;\n      changedOrder = !_.isEqual(\n          _.get(_renderState, 'fetchedData.order'),\n          _.get(newState, 'fetchedData.order')\n        );\n\n      _renderState = newState;\n\n      if (becameIdle) {\n        _handleSizeChange();\n      }\n\n      if (changedOrder) {\n        $element[0].dispatchEvent(\n          new window.CustomEvent(\n            'SOCRATA_VISUALIZATION_VIF_UPDATED',\n            { detail: _getVif(), bubbles: true }\n          )\n        );\n      }\n\n      _render();\n    }\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/Table.js\n ** module id = 44\n ** module chunks = 0\n **/","'use strict';\n\nvar _ = require('lodash');\nvar $ = require('jquery');\nvar utils = require('socrata-utils');\nvar moment = require('moment');\nvar TimelineChart = require('./views/TimelineChart');\nvar SoqlDataProvider = require('./dataProviders/SoqlDataProvider');\nvar SoqlHelpers = require('./dataProviders/SoqlHelpers');\n\nvar MAX_LEGAL_JAVASCRIPT_DATE_STRING = '9999-01-01';\nvar DATE_INDEX = 0;\nvar UNFILTERED_INDEX = 1;\nvar FILTERED_INDEX = 2;\nvar SELECTED_INDEX = 3;\nvar SOQL_PRECISION_START_ALIAS = '__START__';\nvar SOQL_PRECISION_END_ALIAS = '__END__';\nvar SOQL_DATA_PROVIDER_NAME_ALIAS = '__NAME_ALIAS__';\nvar SOQL_DATA_PROVIDER_VALUE_ALIAS = '__VALUE_ALIAS__';\nvar PRECISION_QUERY = \"SELECT min({0}) AS {2}, max({0}) AS {3} WHERE {0} < '{1}'\";\nvar DATA_QUERY_PREFIX = 'SELECT {3}(`{0}`) AS {1}, count(*) AS {2}';\nvar DATA_QUERY_SUFFIX = 'GROUP BY {0}';\nvar DATA_QUERY_WHERE_CLAUSE_PREFIX = 'WHERE';\nvar DATA_QUERY_WHERE_CLAUSE_SUFFIX = \"`{0}` IS NOT NULL AND `{0}` < '{1}' AND (1=1)\";\n//'SELECT {2}({0}) AS {4}, {3} AS {5} {1} GROUP BY {4}'.  format(fieldName, whereClause, dateTruncFunction, aggregationClause, dateAlias, valueAlias)\nvar WINDOW_RESIZE_RERENDER_DELAY = 200;\n\n/**\n * Instantiates a Socrata ColumnChart Visualization from the\n * `socrata-visualizations` package.\n *\n * @param vif - https://docs.google.com/document/d/15oKmDfv39HrhgCJRTKtYadG8ZQvFUeyfx4kR_NZkBgc\n */\n$.fn.socrataTimelineChart = function(vif) {\n  utils.assertHasProperties(\n    vif,\n    'columnName',\n    'configuration.localization',\n    'datasetUid',\n    'domain',\n    'unit.one',\n    'unit.other'\n  );\n\n  utils.assertHasProperties(\n    vif.configuration.localization,\n    'NO_VALUE',\n    'FLYOUT_UNFILTERED_AMOUNT_LABEL',\n    'FLYOUT_FILTERED_AMOUNT_LABEL',\n    'FLYOUT_SELECTED_NOTICE'\n  );\n\n  var $element = $(this);\n\n  var soqlDataProviderConfig = {\n    domain: vif.domain,\n    datasetUid: vif.datasetUid\n  };\n\n  var precisionSoqlDataProvider = new SoqlDataProvider(\n    soqlDataProviderConfig\n  );\n\n  // SoQL returns row results for display as columns.\n  // We need separate data providers for 'unfiltered'\n  // and 'filtered' requests, which are merged below.\n  var unfilteredSoqlDataProvider = new SoqlDataProvider(\n    soqlDataProviderConfig\n  );\n\n  var filteredSoqlDataProvider = new SoqlDataProvider(\n    soqlDataProviderConfig\n  );\n\n  vif.configuration.columns = {\n    date: DATE_INDEX,\n    unfilteredValue: UNFILTERED_INDEX,\n    filteredValue: FILTERED_INDEX,\n    selected: SELECTED_INDEX\n  };\n\n  var visualization = new TimelineChart($element, vif);\n  var visualizationData = transformChartDataForRendering([]);\n  var precision;\n  var rerenderOnResizeTimeout;\n  var _lastRenderedVif;\n\n  _attachEvents();\n  _updateData(vif);\n\n  /**\n   * Configuration\n   */\n\n  function _getRenderOptions(vifToRender) {\n    return {\n      showAllLabels: true,\n      showFiltered: false,\n      precision: precision,\n      vif: vifToRender\n    };\n  }\n\n  function transformChartDataForRendering(chartData) {\n    var minDate = null;\n    var maxDate = null;\n    var minValue = Number.POSITIVE_INFINITY;\n    var maxValue = Number.NEGATIVE_INFINITY;\n    var meanValue;\n    var allValues = chartData.map(function(datum) {\n\n      if (minDate === null) {\n        minDate = datum.date;\n      } else if (datum.date < minDate) {\n        minDate = datum.date;\n      }\n\n      if (maxDate === null) {\n        maxDate = datum.date;\n      } else if (datum.date > maxDate) {\n        maxDate = datum.date;\n      }\n\n      if (datum.total < minValue) {\n        minValue = datum.total;\n      }\n\n      if (datum.total > maxValue) {\n        maxValue = datum.total;\n      }\n\n      return {\n        date: datum.date.toDate(),\n        filtered: datum.filtered,\n        unfiltered: datum.total\n      };\n    });\n\n    minValue = (minValue > 0) ? 0 : minValue;\n    maxValue = (maxValue < 0) ? 0 : maxValue;\n    meanValue = (maxValue + minValue) / 2;\n\n    return {\n      minDate: minDate ? minDate.toDate() : null,\n      maxDate: maxDate ? maxDate.toDate() : null,\n      minValue: minValue,\n      meanValue: meanValue,\n      maxValue: maxValue,\n      values: allValues\n    };\n  }\n\n  /**\n   * Event handling\n   */\n\n  function _attachEvents() {\n\n    // Destroy on (only the first) 'SOCRATA_VISUALIZATION_DESTROY' event.\n    $element.one('SOCRATA_VISUALIZATION_DESTROY', function() {\n      clearTimeout(rerenderOnResizeTimeout);\n      visualization.destroy();\n      _detachEvents();\n    });\n\n    $(window).on('resize', _handleWindowResize);\n\n    $element.on('SOCRATA_VISUALIZATION_TIMELINE_FLYOUT', _handleVisualizationFlyout);\n    $element.on('SOCRATA_VISUALIZATION_TIMELINE_FILTER', _handleSelection);\n    $element.on('SOCRATA_VISUALIZATION_INVALIDATE_SIZE', visualization.invalidateSize);\n    $element.on('SOCRATA_VISUALIZATION_RENDER_VIF', _handleRenderVif);\n  }\n\n  function _detachEvents() {\n\n    $(window).off('resize', _handleWindowResize);\n\n    $element.off('SOCRATA_VISUALIZATION_TIMELINE_FLYOUT', _handleVisualizationFlyout);\n    $element.off('SOCRATA_VISUALIZATION_TIMELINE_FILTER', _handleSelection);\n    $element.off('SOCRATA_VISUALIZATION_INVALIDATE_SIZE', visualization.invalidateSize);\n    $element.off('SOCRATA_VISUALIZATION_RENDER_VIF', _handleRenderVif);\n  }\n\n  function _handleWindowResize() {\n    clearTimeout(rerenderOnResizeTimeout);\n\n    rerenderOnResizeTimeout = setTimeout(\n      _render,\n      // Add some jitter in order to make sure multiple visualizations are\n      // unlikely to all attempt to rerender themselves at the exact same\n      // moment.\n      WINDOW_RESIZE_RERENDER_DELAY + Math.floor(Math.random() * 10)\n    );\n  }\n\n  function _render(vifToRender) {\n    if (vifToRender) {\n      _lastRenderedVif = vifToRender;\n    }\n\n    visualization.render(\n      visualizationData,\n      _getRenderOptions(_lastRenderedVif)\n    );\n  }\n\n  function _handleVisualizationFlyout(event) {\n\n    var payload = event.originalEvent.detail;\n    var flyoutPayload = null;\n    var flyoutContent = null;\n    var flyoutTable = null;\n    var flyoutElements = null;\n    var flyoutTitle;\n    var flyoutUnfilteredValueLabelCell;\n    var flyoutUnfilteredValueCell;\n    var flyoutUnfilteredValueRow;\n    var filteredRowClass;\n    var flyoutFilteredValueLabelCell;\n    var flyoutFilteredValueCell;\n    var flyoutFilteredValueRow;\n    var flyoutSpacerRow;\n    var flyoutSelectedNoticeLabel;\n    var flyoutSelectedNoticeRow;\n\n    if (payload !== null) {\n\n      flyoutContent = $(document.createDocumentFragment());\n      flyoutTable = $('<table>', { 'class': 'socrata-flyout-table' });\n      flyoutElements = [];\n\n      // 'Datum Title'\n      flyoutTitle = $(\n        '<div>',\n        {\n          'class': 'socrata-flyout-title'\n        }\n      ).text(payload.title);\n\n      // 'Total: XXX rows'\n      flyoutUnfilteredValueLabelCell = $(\n        '<td>',\n        {\n          'class': 'socrata-flyout-cell'\n        }\n      ).text(payload.unfilteredLabel);\n\n      flyoutUnfilteredValueCell = $(\n        '<td>',\n        {\n          'class': 'socrata-flyout-cell'\n        }\n      ).text(payload.unfilteredValue);\n\n      flyoutUnfilteredValueRow = $(\n        '<tr>',\n        {\n          'class': 'socrata-flyout-row'\n        }\n      ).append([\n        flyoutUnfilteredValueLabelCell,\n        flyoutUnfilteredValueCell\n      ]);\n\n      flyoutElements.push(flyoutUnfilteredValueRow);\n\n      // If we are showing filtered data, then\n      // show the filtered data on the flyout.\n      if (payload.hasOwnProperty('filteredValue')) {\n\n        filteredRowClass = (payload.filteredBySelection) ?\n          'socrata-flyout-cell is-selected' :\n          'socrata-flyout-cell emphasis';\n\n        // 'Filtered: XXX rows'\n        flyoutFilteredValueLabelCell = $(\n          '<td>',\n          {\n            'class': filteredRowClass\n          }\n        ).text(payload.filteredLabel);\n\n        flyoutFilteredValueCell = $(\n          '<td>',\n          {\n            'class': filteredRowClass\n          }\n        ).text(payload.filteredValue);\n\n        flyoutFilteredValueRow = $(\n          '<tr>',\n          {\n            'class': 'socrata-flyout-row'\n          }\n        ).append([\n          flyoutFilteredValueLabelCell,\n          flyoutFilteredValueCell\n        ]);\n\n        flyoutElements.push(flyoutFilteredValueRow);\n      }\n\n      // If we are hovering over a bar we are\n      // currently filtering by, then display a special\n      // flyout message.\n      if (payload.selected) {\n\n        // 'This visualization is currently filtered...'\n        flyoutSpacerRow = $(\n          '<tr>',\n          {\n            'class': 'socrata-flyout-row',\n            'colspan': '2'\n          }\n        ).append(\n          $('<td>', { 'class': 'socrata-flyout-cell' }).html('&#8203;')\n        );\n\n        flyoutSelectedNoticeLabel = $(\n          '<td>',\n          {\n            'class': 'socrata-flyout-cell'\n          }\n        ).text(payload.selectedNotice);\n\n        flyoutSelectedNoticeRow = $(\n          '<tr>',\n          {\n            'class': 'socrata-flyout-row',\n            'colspan': '2'\n          }\n        ).append([\n          flyoutSelectedNoticeLabel\n        ]);\n\n        flyoutElements.push(flyoutSpacerRow);\n        flyoutElements.push(flyoutSelectedNoticeRow);\n      }\n\n      flyoutTable.append(flyoutElements);\n\n      flyoutContent.append([\n        flyoutTitle,\n        flyoutTable\n      ]);\n\n      flyoutPayload = {\n        element: payload.element,\n        content: flyoutContent,\n        rightSideHint: false,\n        belowTarget: false\n      };\n    }\n\n    $element[0].dispatchEvent(\n      new window.CustomEvent(\n        'SOCRATA_VISUALIZATION_TIMELINE_CHART_FLYOUT',\n        {\n          detail: flyoutPayload,\n          bubbles: true\n        }\n      )\n    );\n  }\n\n  function _handleSelection(event) {\n    var payload = event.originalEvent.detail;\n    var newVif = _.cloneDeep(_lastRenderedVif);\n    var ownFilterStartEnd = newVif.\n      filters.\n      filter(function(filter) {\n        return filter.columnName === newVif.columnName && filter.function === 'timeRangeFilter';\n      }).map(function(filter) {\n        return filter.arguments;\n      });\n\n    newVif.filters = newVif.\n      filters.\n      filter(function(filter) {\n        return filter.columnName !== newVif.columnName;\n      });\n\n    if (\n      payload !== null &&\n      payload.hasOwnProperty('start') &&\n      payload.hasOwnProperty('end')\n    ) {\n\n      newVif.filters.push(\n        {\n          'columnName': newVif.columnName,\n          'function': 'timeRange',\n          'arguments': {\n            'start': payload.start.toISOString().substring(0, 19),\n            'end': payload.end.toISOString().substring(0, 19)\n          }\n        }\n      );\n    }\n\n    $element[0].dispatchEvent(\n      new window.CustomEvent(\n        'SOCRATA_VISUALIZATION_VIF_UPDATED',\n        {\n          detail: newVif,\n          bubbles: true\n        }\n      )\n    );\n  }\n\n  function _handleRenderVif(event) {\n    var newVif = event.originalEvent.detail;\n\n    if (newVif.type !== 'timelineChart') {\n      throw new Error(\n        'Cannot update VIF; old type: `timelineChart`, new type: `{0}`.'.\n          format(\n            newVif.type\n          )\n        );\n    }\n\n    _updateData(newVif);\n  }\n\n  /**\n   * Data requests\n   */\n\n  function handleError(error) {\n    _logError(error);\n    visualization.renderError();\n  }\n\n  function _updateData(vifToRender) {\n    var precisionQueryString = PRECISION_QUERY.format(\n      vifToRender.columnName,\n      MAX_LEGAL_JAVASCRIPT_DATE_STRING,\n      SOQL_PRECISION_START_ALIAS,\n      SOQL_PRECISION_END_ALIAS\n    );\n\n    var precisionPromise = vifToRender.configuration.precision ?\n      Promise.resolve(vifToRender.configuration.precision) :\n      precisionSoqlDataProvider.\n        getRows(\n          [ SOQL_PRECISION_START_ALIAS, SOQL_PRECISION_END_ALIAS ],\n          '$query=' + precisionQueryString\n        ).\n        then(mapQueryResponseToPrecision);\n\n    var dataPromise = precisionPromise.\n      then(mapPrecisionToDataQuery).\n      then(mapQueryToPromises);\n\n    Promise.all([ dataPromise, precisionPromise ]).\n      then(renderDataFromPromises)\n      ['catch'](handleError);\n\n    function mapQueryResponseToPrecision(response) {\n      var startIndex = _.indexOf(response.columns, SOQL_PRECISION_START_ALIAS);\n      var endIndex = _.indexOf(response.columns, SOQL_PRECISION_END_ALIAS);\n      var domainStartDate = _.first(response.rows)[startIndex];\n      var domainEndDate = _.first(response.rows)[endIndex];\n\n      var domain = {\n        start: moment(domainStartDate, moment.ISO_8601),\n        end: moment(domainEndDate, moment.ISO_8601)\n      };\n\n      if (!domain.start.isValid()) {\n        domain.start = null;\n        console.warn('Invalid start date on {0} ({1})'.format(vifToRender.columnName, domainStartDate));\n      }\n\n      if (!domain.end.isValid()) {\n        domain.end = null;\n        console.warn('Invalid end date on {0} ({1})'.format(vifToRender.columnName, domainEndDate));\n      }\n\n      // Return undefined if the domain is undefined, null, or malformed\n      // in some way.  Later on, we will test if datasetPrecision is\n      // undefined and display the proper error message.\n      // By examining the return of getTimelineDomain, these are the\n      // only checks we need.\n      if (_.isUndefined(domain) || _.isNull(domain.start) || _.isNull(domain.end)) {\n        throw 'Timeline Domain is invalid: {0}'.format(domain);\n      }\n\n      // Otherwise, return the precision as a string.\n      // Moment objects are inherently mutable. Therefore, the .add()\n      // call in the first condition will need to be accounted for in\n      // the second condition. We're doing this instead of just cloning\n      // the objects because moment.clone is surprisingly slow (something\n      // like 40ms).\n      if (domain.start.add('years', 1).isAfter(domain.end)) {\n        precision = 'DAY';\n      // We're actually checking for 20 years but have already added one\n      // to the original domain start date in the if block above.\n      } else if (domain.start.add('years', 19).isAfter(domain.end)) {\n        precision = 'MONTH';\n      } else {\n        precision = 'YEAR';\n      }\n\n      return precision;\n    }\n\n    function mapPrecisionToDataQuery(precision) {\n      var date_trunc_function;\n\n      switch (precision) {\n        case 'YEAR':\n          date_trunc_function = 'date_trunc_y';\n          break;\n        case 'MONTH':\n          date_trunc_function = 'date_trunc_ym';\n          break;\n        case 'DAY':\n          date_trunc_function = 'date_trunc_ymd';\n          break;\n        default:\n          throw 'precision was invalid: {0}'.format(precision);\n      }\n\n      return (\n        DATA_QUERY_PREFIX.format(\n          vifToRender.columnName,\n          SOQL_DATA_PROVIDER_NAME_ALIAS,\n          SOQL_DATA_PROVIDER_VALUE_ALIAS,\n          date_trunc_function\n        ) +\n        ' {0} ' +\n        DATA_QUERY_SUFFIX.format(SOQL_DATA_PROVIDER_NAME_ALIAS)\n      );\n    }\n\n    function mapQueryToPromises(dataQueryString) {\n      var unfilteredWhereClause = '{0} {1}'.format(\n        DATA_QUERY_WHERE_CLAUSE_PREFIX,\n        DATA_QUERY_WHERE_CLAUSE_SUFFIX.format(vifToRender.columnName, MAX_LEGAL_JAVASCRIPT_DATE_STRING)\n      );\n      var whereClauseFilterComponents = SoqlHelpers.whereClauseNotFilteringOwnColumn(vifToRender);\n      var filteredWhereClause = '{0} {1} {2} {3}'.format(\n        DATA_QUERY_WHERE_CLAUSE_PREFIX,\n        whereClauseFilterComponents,\n        (whereClauseFilterComponents.length > 0) ? 'AND' : '',\n        DATA_QUERY_WHERE_CLAUSE_SUFFIX.format(vifToRender.columnName, MAX_LEGAL_JAVASCRIPT_DATE_STRING)\n      );\n      var unfilteredSoqlQuery = unfilteredSoqlDataProvider.\n        query(\n          dataQueryString.format(unfilteredWhereClause),\n          SOQL_DATA_PROVIDER_NAME_ALIAS,\n          SOQL_DATA_PROVIDER_VALUE_ALIAS\n        )['catch'](handleError);\n      var filteredSoqlQuery = filteredSoqlDataProvider.\n        query(\n          dataQueryString.format(filteredWhereClause),\n          SOQL_DATA_PROVIDER_NAME_ALIAS,\n          SOQL_DATA_PROVIDER_VALUE_ALIAS\n        )['catch'](handleError);\n\n      return Promise.all([unfilteredSoqlQuery, filteredSoqlQuery]);\n    }\n\n    function renderDataFromPromises(promiseResults) {\n      var values = promiseResults[0];\n      precision = promiseResults[1];\n      var unfilteredQueryResponse = values[0];\n      var filteredQueryResponse = values[1];\n\n      visualizationData = _mergeUnfilteredAndFilteredData(\n        unfilteredQueryResponse,\n        filteredQueryResponse,\n        precision\n      );\n\n      _render(vifToRender);\n    }\n  }\n\n  function _mergeUnfilteredAndFilteredData(unfiltered, filtered, precision) {\n\n    var unfilteredAsHash = _.indexBy(\n      unfiltered.rows,\n      unfiltered.columns.indexOf(SOQL_DATA_PROVIDER_NAME_ALIAS)\n    );\n    var filteredAsHash = _.indexBy(\n      filtered.rows,\n      filtered.columns.indexOf(SOQL_DATA_PROVIDER_NAME_ALIAS)\n    );\n    var dates = Object.keys(unfilteredAsHash).map(function(date) {\n      return moment((_.isNull(date) || _.isUndefined(date)) ? '' : date);\n    });\n    var timeStart = _.min(dates);\n    var timeEnd = _.max(dates);\n    var timeData = Array(timeEnd.diff(timeStart, precision));\n    _.each(unfiltered.rows, function(item) {\n      var date = item[DATE_INDEX];\n      var dateAsMoment = moment((_.isNull(date) || _.isUndefined(date)) ? '' : date);\n      var timeSlot = dateAsMoment.diff(timeStart, precision);\n\n      // Default to null in case we don't receive a value associated with\n      // this date. If we do not, the result of Number(item.value) is NaN\n      // and the timeline chart breaks because it tries to use NaN to\n      // calculate the height of the chart.\n      var unfilteredValue = !_.isUndefined(item[UNFILTERED_INDEX]) ?\n        Number(item[UNFILTERED_INDEX]) :\n        null;\n\n      var filteredValue;\n      // If the filtered value exists, use it.\n      if (filteredAsHash.hasOwnProperty(item[DATE_INDEX])) {\n        filteredValue = Number(filteredAsHash[item[DATE_INDEX]][1])\n      } else {\n        // If the filtered value does not exist but the unfiltered value for\n        // the same date interval exists, then the value has just been filtered\n        // and we should show '0'.\n        if (!_.isUndefined(item[UNFILTERED_INDEX])) {\n          filteredValue = 0;\n        // If the unfiltered value for the same date interval does not exist,\n        // then the value should actually be rendered as being null.\n        } else {\n          filteredValue = null;\n        }\n      }\n\n      timeData[timeSlot] = {\n        date: dateAsMoment,\n        filtered: filteredValue,\n        total: unfilteredValue\n      };\n    });\n\n    return transformChartDataForRendering(\n        _.map(timeData, function(item, i) {\n          if (_.isUndefined(item)) {\n            item = {\n              date: moment(timeStart, moment.ISO_8601).add(i, precision),\n              filtered: null,\n              total: null\n            };\n          }\n          return item;\n        })\n      );\n  }\n\n  function _logError(error) {\n    if (console && _.isFunction(console.error)) {\n      console.error(error);\n    }\n  }\n\n  return this;\n};\n\nmodule.exports = $.fn.socrataTimelineChart;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/TimelineChart.js\n ** module id = 45\n ** module chunks = 0\n **/"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACh/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACz4CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACv2DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACrTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC1+BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtmFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACxVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC/jCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACj9RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC/ZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC5OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC9LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACzQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC9xCA;AACA;AACA;AACA;AACA;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC5IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AC7aA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AClKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AC/gDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC7HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACruBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC9OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AChhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACziBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;","sourceRoot":""}