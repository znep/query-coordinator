import _ from 'lodash';

import Actions from './Actions';
import Environment from '../StorytellerEnvironment';
import { assert, assertIsOneOfTypes } from 'common/js_utils';
import httpRequest, { storytellerHeaders } from '../services/httpRequest';
import { storyStore } from './stores/StoryStore';
import { dispatcher } from './Dispatcher';

export default { saveDraft };

/**
 * Saves a new draft of a story.
 * Emits STORY_SAVE_STARTED, STORY_SAVE_FAILED, and STORY_SAVED as steps are completed.
 *
 * @param {string} storyUid - The UID of the story to save.
 * @return {Promise<string>} A promise for the new story draft's digest.
 */
function saveDraft(storyUid) {
  assertIsOneOfTypes(storyUid, 'string');
  assert(storyStore.doesStoryExist(storyUid), 'Cannot save draft of non-existent story');

  const storyJson = storyStore.serializeStory(storyUid);

  // Should be updated from the X-Story-Digest header in the last save repsonse
  const storyDigest = storyStore.getStoryDigest(storyUid);

  dispatcher.dispatch({
    action: Actions.STORY_SAVE_STARTED,
    storyUid: storyUid
  });

  const headers = storytellerHeaders();

  // This story will only have a digest if a
  // saved draft exists. I.e., goals which have just
  // been migrated will not have a digest.
  if (storyDigest) {
    headers['If-Match'] = storyDigest;
  }

  const url = Environment.IS_GOAL ?
    `/stories/api/stat/v1/goals/${storyUid}/narrative/drafts` :
    `/stories/api/v1/stories/${storyUid}/drafts`;

  return httpRequest('POST', url, {
    data: storyJson,
    headers: headers
  }).
  then(({ data, jqXHR }) => {
    dispatcher.dispatch({
      action: Actions.STORY_UPDATED,
      updatedAt: data.updatedAt,
      storyUid: storyUid
    });

    // Get the new draft digest from the response X-Story-Digest header.
    const newDigest = jqXHR.getResponseHeader('X-Story-Digest');
    if (_.isString(newDigest) && newDigest.length > 0) {
      return newDigest;
    } else {
      return handleError({ data });
    }
  }, (error) => {
    let responseJSON;
    try {
      responseJSON = JSON.parse(error.response);
    } catch (_err) {
      responseJSON = error.response;
    }

    const errorData = {
      status: error.statusCode,
      responseJSON: responseJSON
    };
    return handleError({ data: errorData });
  }).
  then((newDigest) => {
    dispatcher.dispatch({
      action: Actions.STORY_SAVED,
      storyUid: storyUid,
      digest: newDigest
    });

    return newDigest;
  });

  // This function was originally written as a handler for $.Deferred.fail which
  // could be reached either upon the initial AJAX call's failure or upon a lack
  // of story digest header in an otherwise successful response. The latter case
  // invoked this handler with a string, while the former case used an error,
  // but manipulated either object to create a consistent dispatched payload.
  function handleError({ data }) {
    const { status, responseJSON } = data;
    const errorReportingLabel = 'StoryDraftCreator#saveDraft';
    const errorMessage = `${errorReportingLabel}: Saving over already saved version (story: ${storyUid}, status: ${status}).`;

    dispatcher.dispatch({
      action: Actions.STORY_SAVE_FAILED,
      storyUid: storyUid,
      message: data,
      conflictingUserId: _.get(responseJSON, 'conflictingUserId'),
      // A 412 (Precondition Failed) means our If-Match check failed, indicating someone else already
      // saved over the version of the story our user is editing. Aside: it's not 409 (Conflict) because
      // this error is generated by the If-Match, which is a precondition header.
      // Downstream code needs to handle this case specially, so it is called out as a separate field.
      conflict: status === 412,
      errorReporting: {
        message: errorMessage,
        label: errorReportingLabel
      }
    });

    return Promise.reject(errorMessage);
  }
}
